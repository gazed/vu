// Code generated by go-vk from vk.xml at 2024-09-26 06:25:38.5523233 -0400 EDT m=+0.770852401. DO NOT EDIT.

package vk

import (
	"syscall"
	"unsafe"
)

// AcquireDrmDisplayEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireDrmDisplayEXT.html
func AcquireDrmDisplayEXT(physicalDevice PhysicalDevice, drmFd int32, display DisplayKHR) (r error) {
	var rsys uintptr

	if vkAcquireDrmDisplayEXT.fnHandle == nil {
		vkAcquireDrmDisplayEXT.fnHandle = dlHandle.NewProc("vkAcquireDrmDisplayEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkAcquireDrmDisplayEXT.fnHandle.Addr(), uintptr(physicalDevice), uintptr(drmFd), uintptr(display))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAcquireDrmDisplayEXT = &vkCommand{"vkAcquireDrmDisplayEXT", 3, true, nil}

// AcquireNextImage2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImage2KHR.html
func AcquireNextImage2KHR(device Device, acquireInfo *AcquireNextImageInfoKHR) (imageIndex uint32, r error) {
	// Parameter is a singular input, requires translation - acquireInfo
	var pAcquireInfo *_vkAcquireNextImageInfoKHR
	if acquireInfo != nil {
		pAcquireInfo = acquireInfo.Vulkanize()
	}

	// imageIndex is a binding-allocated single return value and will be populated by Vulkan
	ptr_pImageIndex := &imageIndex

	var rsys uintptr

	if vkAcquireNextImage2KHR.fnHandle == nil {
		vkAcquireNextImage2KHR.fnHandle = dlHandle.NewProc("vkAcquireNextImage2KHR")
	}
	rsys, _, _ = syscall.SyscallN(vkAcquireNextImage2KHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pAcquireInfo)), uintptr(unsafe.Pointer(ptr_pImageIndex)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAcquireNextImage2KHR = &vkCommand{"vkAcquireNextImage2KHR", 3, true, nil}

// AcquireNextImageKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html
func AcquireNextImageKHR(device Device, swapchain SwapchainKHR, timeout uint64, semaphore Semaphore, fence Fence) (imageIndex uint32, r error) {
	// imageIndex is a binding-allocated single return value and will be populated by Vulkan
	ptr_pImageIndex := &imageIndex

	var rsys uintptr

	if vkAcquireNextImageKHR.fnHandle == nil {
		vkAcquireNextImageKHR.fnHandle = dlHandle.NewProc("vkAcquireNextImageKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkAcquireNextImageKHR.fnHandle.Addr(), uintptr(device), uintptr(swapchain), uintptr(timeout), uintptr(semaphore), uintptr(fence), uintptr(unsafe.Pointer(ptr_pImageIndex)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAcquireNextImageKHR = &vkCommand{"vkAcquireNextImageKHR", 6, true, nil}

// AcquirePerformanceConfigurationINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquirePerformanceConfigurationINTEL.html
func AcquirePerformanceConfigurationINTEL(device Device, acquireInfo *PerformanceConfigurationAcquireInfoINTEL) (configuration PerformanceConfigurationINTEL, r error) {
	// Parameter is a singular input, requires translation - acquireInfo
	var pAcquireInfo *_vkPerformanceConfigurationAcquireInfoINTEL
	if acquireInfo != nil {
		pAcquireInfo = acquireInfo.Vulkanize()
	}

	// configuration is a binding-allocated single return value and will be populated by Vulkan
	ptr_pConfiguration := &configuration

	var rsys uintptr

	if vkAcquirePerformanceConfigurationINTEL.fnHandle == nil {
		vkAcquirePerformanceConfigurationINTEL.fnHandle = dlHandle.NewProc("vkAcquirePerformanceConfigurationINTEL")
	}
	rsys, _, _ = syscall.SyscallN(vkAcquirePerformanceConfigurationINTEL.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pAcquireInfo)), uintptr(unsafe.Pointer(ptr_pConfiguration)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAcquirePerformanceConfigurationINTEL = &vkCommand{"vkAcquirePerformanceConfigurationINTEL", 3, true, nil}

// AcquireProfilingLockKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireProfilingLockKHR.html
func AcquireProfilingLockKHR(device Device, info *AcquireProfilingLockInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkAcquireProfilingLockInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	var rsys uintptr

	if vkAcquireProfilingLockKHR.fnHandle == nil {
		vkAcquireProfilingLockKHR.fnHandle = dlHandle.NewProc("vkAcquireProfilingLockKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkAcquireProfilingLockKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAcquireProfilingLockKHR = &vkCommand{"vkAcquireProfilingLockKHR", 2, true, nil}

// AllocateCommandBuffers: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateCommandBuffers.html
func AllocateCommandBuffers(device Device, allocateInfo *CommandBufferAllocateInfo) (commandBuffers []CommandBuffer, r error) {
	// Parameter is a singular input, requires translation - allocateInfo
	var pAllocateInfo *_vkCommandBufferAllocateInfo
	if allocateInfo != nil {
		pAllocateInfo = allocateInfo.Vulkanize()
	}

	// Parameter is binding-allocated array populated by Vulkan; length is possibly embedded in a struct (pAllocateInfo->commandBufferCount) - commandBuffers
	commandBuffers = make([]CommandBuffer, pAllocateInfo.commandBufferCount)
	pCommandBuffers := &commandBuffers[0]
	var rsys uintptr

	if vkAllocateCommandBuffers.fnHandle == nil {
		vkAllocateCommandBuffers.fnHandle = dlHandle.NewProc("vkAllocateCommandBuffers")
	}
	rsys, _, _ = syscall.SyscallN(vkAllocateCommandBuffers.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pAllocateInfo)), uintptr(unsafe.Pointer(pCommandBuffers)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAllocateCommandBuffers = &vkCommand{"vkAllocateCommandBuffers", 3, true, nil}

// AllocateDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateDescriptorSets.html
func AllocateDescriptorSets(device Device, allocateInfo *DescriptorSetAllocateInfo) (descriptorSets []DescriptorSet, r error) {
	// Parameter is a singular input, requires translation - allocateInfo
	var pAllocateInfo *_vkDescriptorSetAllocateInfo
	if allocateInfo != nil {
		pAllocateInfo = allocateInfo.Vulkanize()
	}

	// Parameter is binding-allocated array populated by Vulkan; length is possibly embedded in a struct (pAllocateInfo->descriptorSetCount) - descriptorSets
	descriptorSets = make([]DescriptorSet, pAllocateInfo.descriptorSetCount)
	pDescriptorSets := &descriptorSets[0]
	var rsys uintptr

	if vkAllocateDescriptorSets.fnHandle == nil {
		vkAllocateDescriptorSets.fnHandle = dlHandle.NewProc("vkAllocateDescriptorSets")
	}
	rsys, _, _ = syscall.SyscallN(vkAllocateDescriptorSets.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pAllocateInfo)), uintptr(unsafe.Pointer(pDescriptorSets)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAllocateDescriptorSets = &vkCommand{"vkAllocateDescriptorSets", 3, true, nil}

// AllocateMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateMemory.html
func AllocateMemory(device Device, allocateInfo *MemoryAllocateInfo, allocator *AllocationCallbacks) (memory DeviceMemory, r error) {
	// Parameter is a singular input, requires translation - allocateInfo
	var pAllocateInfo *_vkMemoryAllocateInfo
	if allocateInfo != nil {
		pAllocateInfo = allocateInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// memory is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMemory := &memory

	var rsys uintptr

	if vkAllocateMemory.fnHandle == nil {
		vkAllocateMemory.fnHandle = dlHandle.NewProc("vkAllocateMemory")
	}
	rsys, _, _ = syscall.SyscallN(vkAllocateMemory.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pAllocateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pMemory)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAllocateMemory = &vkCommand{"vkAllocateMemory", 4, true, nil}

// BeginCommandBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBeginCommandBuffer.html
func BeginCommandBuffer(commandBuffer CommandBuffer, beginInfo *CommandBufferBeginInfo) (r error) {
	// Parameter is a singular input, requires translation - beginInfo
	var pBeginInfo *_vkCommandBufferBeginInfo
	if beginInfo != nil {
		pBeginInfo = beginInfo.Vulkanize()
	}

	var rsys uintptr

	if vkBeginCommandBuffer.fnHandle == nil {
		vkBeginCommandBuffer.fnHandle = dlHandle.NewProc("vkBeginCommandBuffer")
	}
	rsys, _, _ = syscall.SyscallN(vkBeginCommandBuffer.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pBeginInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBeginCommandBuffer = &vkCommand{"vkBeginCommandBuffer", 2, true, nil}

// BindAccelerationStructureMemoryNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindAccelerationStructureMemoryNV.html
func BindAccelerationStructureMemoryNV(device Device, bindInfos []BindAccelerationStructureMemoryInfoNV) (r error) {
	bindInfoCount := len(bindInfos)
	// bindInfos is an input slice that requires translation to an internal type
	var pBindInfos unsafe.Pointer
	if len(bindInfos) > 0 {
		sl_bindInfos := make([]_vkBindAccelerationStructureMemoryInfoNV, bindInfoCount)
		for i, v := range bindInfos {
			sl_bindInfos[i] = *(v.Vulkanize())
		}
		pBindInfos = unsafe.Pointer(&sl_bindInfos[0])
	}

	var rsys uintptr

	if vkBindAccelerationStructureMemoryNV.fnHandle == nil {
		vkBindAccelerationStructureMemoryNV.fnHandle = dlHandle.NewProc("vkBindAccelerationStructureMemoryNV")
	}
	rsys, _, _ = syscall.SyscallN(vkBindAccelerationStructureMemoryNV.fnHandle.Addr(), uintptr(device), uintptr(bindInfoCount), uintptr(unsafe.Pointer(pBindInfos)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBindAccelerationStructureMemoryNV = &vkCommand{"vkBindAccelerationStructureMemoryNV", 3, true, nil}

// BindBufferMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindBufferMemory.html
func BindBufferMemory(device Device, buffer Buffer, memory DeviceMemory, memoryOffset DeviceSize) (r error) {
	var rsys uintptr

	if vkBindBufferMemory.fnHandle == nil {
		vkBindBufferMemory.fnHandle = dlHandle.NewProc("vkBindBufferMemory")
	}
	rsys, _, _ = syscall.SyscallN(vkBindBufferMemory.fnHandle.Addr(), uintptr(device), uintptr(buffer), uintptr(memory), uintptr(memoryOffset))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBindBufferMemory = &vkCommand{"vkBindBufferMemory", 4, true, nil}

// BindBufferMemory2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindBufferMemory2.html
func BindBufferMemory2(device Device, bindInfos []BindBufferMemoryInfo) (r error) {
	bindInfoCount := len(bindInfos)
	// bindInfos is an input slice that requires translation to an internal type
	var pBindInfos unsafe.Pointer
	if len(bindInfos) > 0 {
		sl_bindInfos := make([]_vkBindBufferMemoryInfo, bindInfoCount)
		for i, v := range bindInfos {
			sl_bindInfos[i] = *(v.Vulkanize())
		}
		pBindInfos = unsafe.Pointer(&sl_bindInfos[0])
	}

	var rsys uintptr

	if vkBindBufferMemory2.fnHandle == nil {
		vkBindBufferMemory2.fnHandle = dlHandle.NewProc("vkBindBufferMemory2")
	}
	rsys, _, _ = syscall.SyscallN(vkBindBufferMemory2.fnHandle.Addr(), uintptr(device), uintptr(bindInfoCount), uintptr(unsafe.Pointer(pBindInfos)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBindBufferMemory2 = &vkCommand{"vkBindBufferMemory2", 3, true, nil}
var BindBufferMemory2KHR = BindBufferMemory2

// BindImageMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindImageMemory.html
func BindImageMemory(device Device, image Image, memory DeviceMemory, memoryOffset DeviceSize) (r error) {
	var rsys uintptr

	if vkBindImageMemory.fnHandle == nil {
		vkBindImageMemory.fnHandle = dlHandle.NewProc("vkBindImageMemory")
	}
	rsys, _, _ = syscall.SyscallN(vkBindImageMemory.fnHandle.Addr(), uintptr(device), uintptr(image), uintptr(memory), uintptr(memoryOffset))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBindImageMemory = &vkCommand{"vkBindImageMemory", 4, true, nil}

// BindImageMemory2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindImageMemory2.html
func BindImageMemory2(device Device, bindInfos []BindImageMemoryInfo) (r error) {
	bindInfoCount := len(bindInfos)
	// bindInfos is an input slice that requires translation to an internal type
	var pBindInfos unsafe.Pointer
	if len(bindInfos) > 0 {
		sl_bindInfos := make([]_vkBindImageMemoryInfo, bindInfoCount)
		for i, v := range bindInfos {
			sl_bindInfos[i] = *(v.Vulkanize())
		}
		pBindInfos = unsafe.Pointer(&sl_bindInfos[0])
	}

	var rsys uintptr

	if vkBindImageMemory2.fnHandle == nil {
		vkBindImageMemory2.fnHandle = dlHandle.NewProc("vkBindImageMemory2")
	}
	rsys, _, _ = syscall.SyscallN(vkBindImageMemory2.fnHandle.Addr(), uintptr(device), uintptr(bindInfoCount), uintptr(unsafe.Pointer(pBindInfos)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBindImageMemory2 = &vkCommand{"vkBindImageMemory2", 3, true, nil}
var BindImageMemory2KHR = BindImageMemory2

// BuildAccelerationStructuresKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBuildAccelerationStructuresKHR.html
func BuildAccelerationStructuresKHR(device Device, deferredOperation DeferredOperationKHR, infos []AccelerationStructureBuildGeometryInfoKHR, pBuildRangeInfos []*AccelerationStructureBuildRangeInfoKHR) (r error) {
	infoCount := len(infos)
	// infos is an input slice that requires translation to an internal type
	var pInfos unsafe.Pointer
	if len(infos) > 0 {
		sl_infos := make([]_vkAccelerationStructureBuildGeometryInfoKHR, infoCount)
		for i, v := range infos {
			sl_infos[i] = *(v.Vulkanize())
		}
		pInfos = unsafe.Pointer(&sl_infos[0])
	}

	// pBuildRangeInfos is an input slice of values that do not need translation used
	var ppBuildRangeInfos unsafe.Pointer
	if pBuildRangeInfos != nil {
		ppBuildRangeInfos = unsafe.Pointer(&pBuildRangeInfos[0])
	}

	var rsys uintptr

	if vkBuildAccelerationStructuresKHR.fnHandle == nil {
		vkBuildAccelerationStructuresKHR.fnHandle = dlHandle.NewProc("vkBuildAccelerationStructuresKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkBuildAccelerationStructuresKHR.fnHandle.Addr(), uintptr(device), uintptr(deferredOperation), uintptr(infoCount), uintptr(unsafe.Pointer(pInfos)), uintptr(unsafe.Pointer(ppBuildRangeInfos)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBuildAccelerationStructuresKHR = &vkCommand{"vkBuildAccelerationStructuresKHR", 5, true, nil}

// CmdBeginConditionalRenderingEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginConditionalRenderingEXT.html
func CmdBeginConditionalRenderingEXT(commandBuffer CommandBuffer, conditionalRenderingBegin *ConditionalRenderingBeginInfoEXT) {
	// Parameter is a singular input, requires translation - conditionalRenderingBegin
	var pConditionalRenderingBegin *_vkConditionalRenderingBeginInfoEXT
	if conditionalRenderingBegin != nil {
		pConditionalRenderingBegin = conditionalRenderingBegin.Vulkanize()
	}

	if vkCmdBeginConditionalRenderingEXT.fnHandle == nil {
		vkCmdBeginConditionalRenderingEXT.fnHandle = dlHandle.NewProc("vkCmdBeginConditionalRenderingEXT")
	}
	syscall.SyscallN(vkCmdBeginConditionalRenderingEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pConditionalRenderingBegin)))

}

var vkCmdBeginConditionalRenderingEXT = &vkCommand{"vkCmdBeginConditionalRenderingEXT", 2, true, nil}

// CmdBeginDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginDebugUtilsLabelEXT.html
func CmdBeginDebugUtilsLabelEXT(commandBuffer CommandBuffer, labelInfo *DebugUtilsLabelEXT) {
	// Parameter is a singular input, requires translation - labelInfo
	var pLabelInfo *_vkDebugUtilsLabelEXT
	if labelInfo != nil {
		pLabelInfo = labelInfo.Vulkanize()
	}

	if vkCmdBeginDebugUtilsLabelEXT.fnHandle == nil {
		vkCmdBeginDebugUtilsLabelEXT.fnHandle = dlHandle.NewProc("vkCmdBeginDebugUtilsLabelEXT")
	}
	syscall.SyscallN(vkCmdBeginDebugUtilsLabelEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pLabelInfo)))

}

var vkCmdBeginDebugUtilsLabelEXT = &vkCommand{"vkCmdBeginDebugUtilsLabelEXT", 2, true, nil}

// CmdBeginQuery: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginQuery.html
func CmdBeginQuery(commandBuffer CommandBuffer, queryPool QueryPool, query uint32, flags QueryControlFlags) {

	if vkCmdBeginQuery.fnHandle == nil {
		vkCmdBeginQuery.fnHandle = dlHandle.NewProc("vkCmdBeginQuery")
	}
	syscall.SyscallN(vkCmdBeginQuery.fnHandle.Addr(), uintptr(commandBuffer), uintptr(queryPool), uintptr(query), uintptr(flags))

}

var vkCmdBeginQuery = &vkCommand{"vkCmdBeginQuery", 4, true, nil}

// CmdBeginQueryIndexedEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginQueryIndexedEXT.html
func CmdBeginQueryIndexedEXT(commandBuffer CommandBuffer, queryPool QueryPool, query uint32, flags QueryControlFlags, index uint32) {

	if vkCmdBeginQueryIndexedEXT.fnHandle == nil {
		vkCmdBeginQueryIndexedEXT.fnHandle = dlHandle.NewProc("vkCmdBeginQueryIndexedEXT")
	}
	syscall.SyscallN(vkCmdBeginQueryIndexedEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(queryPool), uintptr(query), uintptr(flags), uintptr(index))

}

var vkCmdBeginQueryIndexedEXT = &vkCommand{"vkCmdBeginQueryIndexedEXT", 5, true, nil}

// CmdBeginRenderPass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html
func CmdBeginRenderPass(commandBuffer CommandBuffer, renderPassBegin *RenderPassBeginInfo, contents SubpassContents) {
	// Parameter is a singular input, requires translation - renderPassBegin
	var pRenderPassBegin *_vkRenderPassBeginInfo
	if renderPassBegin != nil {
		pRenderPassBegin = renderPassBegin.Vulkanize()
	}

	if vkCmdBeginRenderPass.fnHandle == nil {
		vkCmdBeginRenderPass.fnHandle = dlHandle.NewProc("vkCmdBeginRenderPass")
	}
	syscall.SyscallN(vkCmdBeginRenderPass.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pRenderPassBegin)), uintptr(contents))

}

var vkCmdBeginRenderPass = &vkCommand{"vkCmdBeginRenderPass", 3, true, nil}

// CmdBeginRenderPass2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass2.html
func CmdBeginRenderPass2(commandBuffer CommandBuffer, renderPassBegin *RenderPassBeginInfo, subpassBeginInfo *SubpassBeginInfo) {
	// Parameter is a singular input, requires translation - renderPassBegin
	var pRenderPassBegin *_vkRenderPassBeginInfo
	if renderPassBegin != nil {
		pRenderPassBegin = renderPassBegin.Vulkanize()
	}

	// Parameter is a singular input, requires translation - subpassBeginInfo
	var pSubpassBeginInfo *_vkSubpassBeginInfo
	if subpassBeginInfo != nil {
		pSubpassBeginInfo = subpassBeginInfo.Vulkanize()
	}

	if vkCmdBeginRenderPass2.fnHandle == nil {
		vkCmdBeginRenderPass2.fnHandle = dlHandle.NewProc("vkCmdBeginRenderPass2")
	}
	syscall.SyscallN(vkCmdBeginRenderPass2.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pRenderPassBegin)), uintptr(unsafe.Pointer(pSubpassBeginInfo)))

}

var vkCmdBeginRenderPass2 = &vkCommand{"vkCmdBeginRenderPass2", 3, true, nil}
var CmdBeginRenderPass2KHR = CmdBeginRenderPass2

// CmdBeginRenderingKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderingKHR.html
func CmdBeginRenderingKHR(commandBuffer CommandBuffer, renderingInfo *RenderingInfoKHR) {
	// Parameter is a singular input, requires translation - renderingInfo
	var pRenderingInfo *_vkRenderingInfoKHR
	if renderingInfo != nil {
		pRenderingInfo = renderingInfo.Vulkanize()
	}

	if vkCmdBeginRenderingKHR.fnHandle == nil {
		vkCmdBeginRenderingKHR.fnHandle = dlHandle.NewProc("vkCmdBeginRenderingKHR")
	}
	syscall.SyscallN(vkCmdBeginRenderingKHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pRenderingInfo)))

}

var vkCmdBeginRenderingKHR = &vkCommand{"vkCmdBeginRenderingKHR", 2, true, nil}

// CmdBeginTransformFeedbackEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginTransformFeedbackEXT.html
func CmdBeginTransformFeedbackEXT(commandBuffer CommandBuffer, firstCounterBuffer uint32, counterBuffers []Buffer, counterBufferOffsets []DeviceSize) {
	counterBufferCount := len(counterBuffers)
	// counterBuffers is an input slice of values that do not need translation used
	var pCounterBuffers unsafe.Pointer
	if counterBuffers != nil {
		pCounterBuffers = unsafe.Pointer(&counterBuffers[0])
	}

	// counterBufferOffsets is an input slice of values that do not need translation used
	var pCounterBufferOffsets unsafe.Pointer
	if counterBufferOffsets != nil {
		pCounterBufferOffsets = unsafe.Pointer(&counterBufferOffsets[0])
	}

	if vkCmdBeginTransformFeedbackEXT.fnHandle == nil {
		vkCmdBeginTransformFeedbackEXT.fnHandle = dlHandle.NewProc("vkCmdBeginTransformFeedbackEXT")
	}
	syscall.SyscallN(vkCmdBeginTransformFeedbackEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(firstCounterBuffer), uintptr(counterBufferCount), uintptr(unsafe.Pointer(pCounterBuffers)), uintptr(unsafe.Pointer(pCounterBufferOffsets)))

}

var vkCmdBeginTransformFeedbackEXT = &vkCommand{"vkCmdBeginTransformFeedbackEXT", 5, true, nil}

// CmdBindDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorSets.html
func CmdBindDescriptorSets(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, layout PipelineLayout, firstSet uint32, descriptorSets []DescriptorSet, dynamicOffsets []uint32) {
	descriptorSetCount := len(descriptorSets)
	// descriptorSets is an input slice of values that do not need translation used
	var pDescriptorSets unsafe.Pointer
	if descriptorSets != nil {
		pDescriptorSets = unsafe.Pointer(&descriptorSets[0])
	}

	dynamicOffsetCount := len(dynamicOffsets)
	// dynamicOffsets is an input slice of values that do not need translation used
	var pDynamicOffsets unsafe.Pointer
	if dynamicOffsets != nil {
		pDynamicOffsets = unsafe.Pointer(&dynamicOffsets[0])
	}

	if vkCmdBindDescriptorSets.fnHandle == nil {
		vkCmdBindDescriptorSets.fnHandle = dlHandle.NewProc("vkCmdBindDescriptorSets")
	}
	syscall.SyscallN(vkCmdBindDescriptorSets.fnHandle.Addr(), uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(layout), uintptr(firstSet), uintptr(descriptorSetCount), uintptr(unsafe.Pointer(pDescriptorSets)), uintptr(dynamicOffsetCount), uintptr(unsafe.Pointer(pDynamicOffsets)))

}

var vkCmdBindDescriptorSets = &vkCommand{"vkCmdBindDescriptorSets", 8, true, nil}

// CmdBindIndexBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindIndexBuffer.html
func CmdBindIndexBuffer(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, indexType IndexType) {

	if vkCmdBindIndexBuffer.fnHandle == nil {
		vkCmdBindIndexBuffer.fnHandle = dlHandle.NewProc("vkCmdBindIndexBuffer")
	}
	syscall.SyscallN(vkCmdBindIndexBuffer.fnHandle.Addr(), uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(indexType))

}

var vkCmdBindIndexBuffer = &vkCommand{"vkCmdBindIndexBuffer", 4, true, nil}

// CmdBindInvocationMaskHUAWEI: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindInvocationMaskHUAWEI.html
func CmdBindInvocationMaskHUAWEI(commandBuffer CommandBuffer, imageView ImageView, imageLayout ImageLayout) {

	if vkCmdBindInvocationMaskHUAWEI.fnHandle == nil {
		vkCmdBindInvocationMaskHUAWEI.fnHandle = dlHandle.NewProc("vkCmdBindInvocationMaskHUAWEI")
	}
	syscall.SyscallN(vkCmdBindInvocationMaskHUAWEI.fnHandle.Addr(), uintptr(commandBuffer), uintptr(imageView), uintptr(imageLayout))

}

var vkCmdBindInvocationMaskHUAWEI = &vkCommand{"vkCmdBindInvocationMaskHUAWEI", 3, true, nil}

// CmdBindPipeline: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindPipeline.html
func CmdBindPipeline(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, pipeline Pipeline) {

	if vkCmdBindPipeline.fnHandle == nil {
		vkCmdBindPipeline.fnHandle = dlHandle.NewProc("vkCmdBindPipeline")
	}
	syscall.SyscallN(vkCmdBindPipeline.fnHandle.Addr(), uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(pipeline))

}

var vkCmdBindPipeline = &vkCommand{"vkCmdBindPipeline", 3, true, nil}

// CmdBindPipelineShaderGroupNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindPipelineShaderGroupNV.html
func CmdBindPipelineShaderGroupNV(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, pipeline Pipeline, groupIndex uint32) {

	if vkCmdBindPipelineShaderGroupNV.fnHandle == nil {
		vkCmdBindPipelineShaderGroupNV.fnHandle = dlHandle.NewProc("vkCmdBindPipelineShaderGroupNV")
	}
	syscall.SyscallN(vkCmdBindPipelineShaderGroupNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(pipeline), uintptr(groupIndex))

}

var vkCmdBindPipelineShaderGroupNV = &vkCommand{"vkCmdBindPipelineShaderGroupNV", 4, true, nil}

// CmdBindShadingRateImageNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindShadingRateImageNV.html
func CmdBindShadingRateImageNV(commandBuffer CommandBuffer, imageView ImageView, imageLayout ImageLayout) {

	if vkCmdBindShadingRateImageNV.fnHandle == nil {
		vkCmdBindShadingRateImageNV.fnHandle = dlHandle.NewProc("vkCmdBindShadingRateImageNV")
	}
	syscall.SyscallN(vkCmdBindShadingRateImageNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(imageView), uintptr(imageLayout))

}

var vkCmdBindShadingRateImageNV = &vkCommand{"vkCmdBindShadingRateImageNV", 3, true, nil}

// CmdBindTransformFeedbackBuffersEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindTransformFeedbackBuffersEXT.html
func CmdBindTransformFeedbackBuffersEXT(commandBuffer CommandBuffer, firstBinding uint32, buffers []Buffer, offsets []DeviceSize, sizes []DeviceSize) {
	bindingCount := len(buffers)
	// buffers is an input slice of values that do not need translation used
	var pBuffers unsafe.Pointer
	if buffers != nil {
		pBuffers = unsafe.Pointer(&buffers[0])
	}

	// offsets is an input slice of values that do not need translation used
	var pOffsets unsafe.Pointer
	if offsets != nil {
		pOffsets = unsafe.Pointer(&offsets[0])
	}

	// sizes is an input slice of values that do not need translation used
	var pSizes unsafe.Pointer
	if sizes != nil {
		pSizes = unsafe.Pointer(&sizes[0])
	}

	if vkCmdBindTransformFeedbackBuffersEXT.fnHandle == nil {
		vkCmdBindTransformFeedbackBuffersEXT.fnHandle = dlHandle.NewProc("vkCmdBindTransformFeedbackBuffersEXT")
	}
	syscall.SyscallN(vkCmdBindTransformFeedbackBuffersEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(firstBinding), uintptr(bindingCount), uintptr(unsafe.Pointer(pBuffers)), uintptr(unsafe.Pointer(pOffsets)), uintptr(unsafe.Pointer(pSizes)))

}

var vkCmdBindTransformFeedbackBuffersEXT = &vkCommand{"vkCmdBindTransformFeedbackBuffersEXT", 6, true, nil}

// CmdBindVertexBuffers: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers.html
func CmdBindVertexBuffers(commandBuffer CommandBuffer, firstBinding uint32, buffers []Buffer, offsets []DeviceSize) {
	bindingCount := len(buffers)
	// buffers is an input slice of values that do not need translation used
	var pBuffers unsafe.Pointer
	if buffers != nil {
		pBuffers = unsafe.Pointer(&buffers[0])
	}

	// offsets is an input slice of values that do not need translation used
	var pOffsets unsafe.Pointer
	if offsets != nil {
		pOffsets = unsafe.Pointer(&offsets[0])
	}

	if vkCmdBindVertexBuffers.fnHandle == nil {
		vkCmdBindVertexBuffers.fnHandle = dlHandle.NewProc("vkCmdBindVertexBuffers")
	}
	syscall.SyscallN(vkCmdBindVertexBuffers.fnHandle.Addr(), uintptr(commandBuffer), uintptr(firstBinding), uintptr(bindingCount), uintptr(unsafe.Pointer(pBuffers)), uintptr(unsafe.Pointer(pOffsets)))

}

var vkCmdBindVertexBuffers = &vkCommand{"vkCmdBindVertexBuffers", 5, true, nil}

// CmdBindVertexBuffers2EXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers2EXT.html
func CmdBindVertexBuffers2EXT(commandBuffer CommandBuffer, firstBinding uint32, buffers []Buffer, offsets []DeviceSize, sizes []DeviceSize, strides []DeviceSize) {
	bindingCount := len(buffers)
	// buffers is an input slice of values that do not need translation used
	var pBuffers unsafe.Pointer
	if buffers != nil {
		pBuffers = unsafe.Pointer(&buffers[0])
	}

	// offsets is an input slice of values that do not need translation used
	var pOffsets unsafe.Pointer
	if offsets != nil {
		pOffsets = unsafe.Pointer(&offsets[0])
	}

	// sizes is an input slice of values that do not need translation used
	var pSizes unsafe.Pointer
	if sizes != nil {
		pSizes = unsafe.Pointer(&sizes[0])
	}

	// strides is an input slice of values that do not need translation used
	var pStrides unsafe.Pointer
	if strides != nil {
		pStrides = unsafe.Pointer(&strides[0])
	}

	if vkCmdBindVertexBuffers2EXT.fnHandle == nil {
		vkCmdBindVertexBuffers2EXT.fnHandle = dlHandle.NewProc("vkCmdBindVertexBuffers2EXT")
	}
	syscall.SyscallN(vkCmdBindVertexBuffers2EXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(firstBinding), uintptr(bindingCount), uintptr(unsafe.Pointer(pBuffers)), uintptr(unsafe.Pointer(pOffsets)), uintptr(unsafe.Pointer(pSizes)), uintptr(unsafe.Pointer(pStrides)))

}

var vkCmdBindVertexBuffers2EXT = &vkCommand{"vkCmdBindVertexBuffers2EXT", 7, true, nil}

// CmdBlitImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage.html
func CmdBlitImage(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageBlit, filter Filter) {
	regionCount := len(regions)
	// regions is an input slice that requires translation to an internal type
	var pRegions unsafe.Pointer
	if len(regions) > 0 {
		sl_regions := make([]_vkImageBlit, regionCount)
		for i, v := range regions {
			sl_regions[i] = *(v.Vulkanize())
		}
		pRegions = unsafe.Pointer(&sl_regions[0])
	}

	if vkCmdBlitImage.fnHandle == nil {
		vkCmdBlitImage.fnHandle = dlHandle.NewProc("vkCmdBlitImage")
	}
	syscall.SyscallN(vkCmdBlitImage.fnHandle.Addr(), uintptr(commandBuffer), uintptr(srcImage), uintptr(srcImageLayout), uintptr(dstImage), uintptr(dstImageLayout), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)), uintptr(filter))

}

var vkCmdBlitImage = &vkCommand{"vkCmdBlitImage", 8, true, nil}

// CmdBlitImage2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage2KHR.html
func CmdBlitImage2KHR(commandBuffer CommandBuffer, blitImageInfo *BlitImageInfo2KHR) {
	// Parameter is a singular input, requires translation - blitImageInfo
	var pBlitImageInfo *_vkBlitImageInfo2KHR
	if blitImageInfo != nil {
		pBlitImageInfo = blitImageInfo.Vulkanize()
	}

	if vkCmdBlitImage2KHR.fnHandle == nil {
		vkCmdBlitImage2KHR.fnHandle = dlHandle.NewProc("vkCmdBlitImage2KHR")
	}
	syscall.SyscallN(vkCmdBlitImage2KHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pBlitImageInfo)))

}

var vkCmdBlitImage2KHR = &vkCommand{"vkCmdBlitImage2KHR", 2, true, nil}

// CmdBuildAccelerationStructureNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBuildAccelerationStructureNV.html
func CmdBuildAccelerationStructureNV(commandBuffer CommandBuffer, info *AccelerationStructureInfoNV, instanceData Buffer, instanceOffset DeviceSize, update bool, dst AccelerationStructureNV, src AccelerationStructureNV, scratch Buffer, scratchOffset DeviceSize) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkAccelerationStructureInfoNV
	if info != nil {
		pInfo = info.Vulkanize()
	}

	update_Bool32 := translateInternal_Bool32(update)

	if vkCmdBuildAccelerationStructureNV.fnHandle == nil {
		vkCmdBuildAccelerationStructureNV.fnHandle = dlHandle.NewProc("vkCmdBuildAccelerationStructureNV")
	}
	syscall.SyscallN(vkCmdBuildAccelerationStructureNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)), uintptr(instanceData), uintptr(instanceOffset), uintptr(update_Bool32), uintptr(dst), uintptr(src), uintptr(scratch), uintptr(scratchOffset))

}

var vkCmdBuildAccelerationStructureNV = &vkCommand{"vkCmdBuildAccelerationStructureNV", 9, true, nil}

// CmdBuildAccelerationStructuresIndirectKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBuildAccelerationStructuresIndirectKHR.html
func CmdBuildAccelerationStructuresIndirectKHR(commandBuffer CommandBuffer, infos []AccelerationStructureBuildGeometryInfoKHR, indirectDeviceAddresses []DeviceAddress, indirectStrides []uint32, pMaxPrimitiveCounts []*uint32) {
	infoCount := len(infos)
	// infos is an input slice that requires translation to an internal type
	var pInfos unsafe.Pointer
	if len(infos) > 0 {
		sl_infos := make([]_vkAccelerationStructureBuildGeometryInfoKHR, infoCount)
		for i, v := range infos {
			sl_infos[i] = *(v.Vulkanize())
		}
		pInfos = unsafe.Pointer(&sl_infos[0])
	}

	// indirectDeviceAddresses is an input slice of values that do not need translation used
	var pIndirectDeviceAddresses unsafe.Pointer
	if indirectDeviceAddresses != nil {
		pIndirectDeviceAddresses = unsafe.Pointer(&indirectDeviceAddresses[0])
	}

	// indirectStrides is an input slice of values that do not need translation used
	var pIndirectStrides unsafe.Pointer
	if indirectStrides != nil {
		pIndirectStrides = unsafe.Pointer(&indirectStrides[0])
	}

	// pMaxPrimitiveCounts is an input slice of values that do not need translation used
	var ppMaxPrimitiveCounts unsafe.Pointer
	if pMaxPrimitiveCounts != nil {
		ppMaxPrimitiveCounts = unsafe.Pointer(&pMaxPrimitiveCounts[0])
	}

	if vkCmdBuildAccelerationStructuresIndirectKHR.fnHandle == nil {
		vkCmdBuildAccelerationStructuresIndirectKHR.fnHandle = dlHandle.NewProc("vkCmdBuildAccelerationStructuresIndirectKHR")
	}
	syscall.SyscallN(vkCmdBuildAccelerationStructuresIndirectKHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(infoCount), uintptr(unsafe.Pointer(pInfos)), uintptr(unsafe.Pointer(pIndirectDeviceAddresses)), uintptr(unsafe.Pointer(pIndirectStrides)), uintptr(unsafe.Pointer(ppMaxPrimitiveCounts)))

}

var vkCmdBuildAccelerationStructuresIndirectKHR = &vkCommand{"vkCmdBuildAccelerationStructuresIndirectKHR", 6, true, nil}

// CmdBuildAccelerationStructuresKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBuildAccelerationStructuresKHR.html
func CmdBuildAccelerationStructuresKHR(commandBuffer CommandBuffer, infos []AccelerationStructureBuildGeometryInfoKHR, pBuildRangeInfos []*AccelerationStructureBuildRangeInfoKHR) {
	infoCount := len(infos)
	// infos is an input slice that requires translation to an internal type
	var pInfos unsafe.Pointer
	if len(infos) > 0 {
		sl_infos := make([]_vkAccelerationStructureBuildGeometryInfoKHR, infoCount)
		for i, v := range infos {
			sl_infos[i] = *(v.Vulkanize())
		}
		pInfos = unsafe.Pointer(&sl_infos[0])
	}

	// pBuildRangeInfos is an input slice of values that do not need translation used
	var ppBuildRangeInfos unsafe.Pointer
	if pBuildRangeInfos != nil {
		ppBuildRangeInfos = unsafe.Pointer(&pBuildRangeInfos[0])
	}

	if vkCmdBuildAccelerationStructuresKHR.fnHandle == nil {
		vkCmdBuildAccelerationStructuresKHR.fnHandle = dlHandle.NewProc("vkCmdBuildAccelerationStructuresKHR")
	}
	syscall.SyscallN(vkCmdBuildAccelerationStructuresKHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(infoCount), uintptr(unsafe.Pointer(pInfos)), uintptr(unsafe.Pointer(ppBuildRangeInfos)))

}

var vkCmdBuildAccelerationStructuresKHR = &vkCommand{"vkCmdBuildAccelerationStructuresKHR", 4, true, nil}

// CmdClearAttachments: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdClearAttachments.html
func CmdClearAttachments(commandBuffer CommandBuffer, attachments []ClearAttachment, rects []ClearRect) {
	attachmentCount := len(attachments)
	// attachments is an input slice that requires translation to an internal type
	var pAttachments unsafe.Pointer
	if len(attachments) > 0 {
		sl_attachments := make([]_vkClearAttachment, attachmentCount)
		for i, v := range attachments {
			sl_attachments[i] = *(v.Vulkanize())
		}
		pAttachments = unsafe.Pointer(&sl_attachments[0])
	}

	rectCount := len(rects)
	// rects is an input slice that requires translation to an internal type
	var pRects unsafe.Pointer
	if len(rects) > 0 {
		sl_rects := make([]_vkClearRect, rectCount)
		for i, v := range rects {
			sl_rects[i] = *(v.Vulkanize())
		}
		pRects = unsafe.Pointer(&sl_rects[0])
	}

	if vkCmdClearAttachments.fnHandle == nil {
		vkCmdClearAttachments.fnHandle = dlHandle.NewProc("vkCmdClearAttachments")
	}
	syscall.SyscallN(vkCmdClearAttachments.fnHandle.Addr(), uintptr(commandBuffer), uintptr(attachmentCount), uintptr(unsafe.Pointer(pAttachments)), uintptr(rectCount), uintptr(unsafe.Pointer(pRects)))

}

var vkCmdClearAttachments = &vkCommand{"vkCmdClearAttachments", 5, true, nil}

// CmdClearColorImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdClearColorImage.html
func CmdClearColorImage(commandBuffer CommandBuffer, image Image, imageLayout ImageLayout, color *ClearColorValue, ranges []ImageSubresourceRange) {
	// Parameter is a singular input, requires translation - color
	var pColor *_vkClearColorValue
	if color != nil {
		pColor = color.Vulkanize()
	}

	rangeCount := len(ranges)
	// ranges is an input slice of values that do not need translation used
	var pRanges unsafe.Pointer
	if ranges != nil {
		pRanges = unsafe.Pointer(&ranges[0])
	}

	if vkCmdClearColorImage.fnHandle == nil {
		vkCmdClearColorImage.fnHandle = dlHandle.NewProc("vkCmdClearColorImage")
	}
	syscall.SyscallN(vkCmdClearColorImage.fnHandle.Addr(), uintptr(commandBuffer), uintptr(image), uintptr(imageLayout), uintptr(unsafe.Pointer(pColor)), uintptr(rangeCount), uintptr(unsafe.Pointer(pRanges)))

}

var vkCmdClearColorImage = &vkCommand{"vkCmdClearColorImage", 6, true, nil}

// CmdClearDepthStencilImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdClearDepthStencilImage.html
func CmdClearDepthStencilImage(commandBuffer CommandBuffer, image Image, imageLayout ImageLayout, depthStencil *ClearDepthStencilValue, ranges []ImageSubresourceRange) {
	// Parameter is a singular input, pass direct - depthStencil
	var pDepthStencil unsafe.Pointer
	if depthStencil != nil {
		pDepthStencil = unsafe.Pointer(depthStencil)
	}

	rangeCount := len(ranges)
	// ranges is an input slice of values that do not need translation used
	var pRanges unsafe.Pointer
	if ranges != nil {
		pRanges = unsafe.Pointer(&ranges[0])
	}

	if vkCmdClearDepthStencilImage.fnHandle == nil {
		vkCmdClearDepthStencilImage.fnHandle = dlHandle.NewProc("vkCmdClearDepthStencilImage")
	}
	syscall.SyscallN(vkCmdClearDepthStencilImage.fnHandle.Addr(), uintptr(commandBuffer), uintptr(image), uintptr(imageLayout), uintptr(unsafe.Pointer(pDepthStencil)), uintptr(rangeCount), uintptr(unsafe.Pointer(pRanges)))

}

var vkCmdClearDepthStencilImage = &vkCommand{"vkCmdClearDepthStencilImage", 6, true, nil}

// CmdCopyAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyAccelerationStructureKHR.html
func CmdCopyAccelerationStructureKHR(commandBuffer CommandBuffer, info *CopyAccelerationStructureInfoKHR) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyAccelerationStructureInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	if vkCmdCopyAccelerationStructureKHR.fnHandle == nil {
		vkCmdCopyAccelerationStructureKHR.fnHandle = dlHandle.NewProc("vkCmdCopyAccelerationStructureKHR")
	}
	syscall.SyscallN(vkCmdCopyAccelerationStructureKHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)))

}

var vkCmdCopyAccelerationStructureKHR = &vkCommand{"vkCmdCopyAccelerationStructureKHR", 2, true, nil}

// CmdCopyAccelerationStructureNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyAccelerationStructureNV.html
func CmdCopyAccelerationStructureNV(commandBuffer CommandBuffer, dst AccelerationStructureNV, src AccelerationStructureNV, mode CopyAccelerationStructureModeKHR) {

	if vkCmdCopyAccelerationStructureNV.fnHandle == nil {
		vkCmdCopyAccelerationStructureNV.fnHandle = dlHandle.NewProc("vkCmdCopyAccelerationStructureNV")
	}
	syscall.SyscallN(vkCmdCopyAccelerationStructureNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(dst), uintptr(src), uintptr(mode))

}

var vkCmdCopyAccelerationStructureNV = &vkCommand{"vkCmdCopyAccelerationStructureNV", 4, true, nil}

// CmdCopyAccelerationStructureToMemoryKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyAccelerationStructureToMemoryKHR.html
func CmdCopyAccelerationStructureToMemoryKHR(commandBuffer CommandBuffer, info *CopyAccelerationStructureToMemoryInfoKHR) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyAccelerationStructureToMemoryInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	if vkCmdCopyAccelerationStructureToMemoryKHR.fnHandle == nil {
		vkCmdCopyAccelerationStructureToMemoryKHR.fnHandle = dlHandle.NewProc("vkCmdCopyAccelerationStructureToMemoryKHR")
	}
	syscall.SyscallN(vkCmdCopyAccelerationStructureToMemoryKHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)))

}

var vkCmdCopyAccelerationStructureToMemoryKHR = &vkCommand{"vkCmdCopyAccelerationStructureToMemoryKHR", 2, true, nil}

// CmdCopyBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer.html
func CmdCopyBuffer(commandBuffer CommandBuffer, srcBuffer Buffer, dstBuffer Buffer, regions []BufferCopy) {
	regionCount := len(regions)
	// regions is an input slice of values that do not need translation used
	var pRegions unsafe.Pointer
	if regions != nil {
		pRegions = unsafe.Pointer(&regions[0])
	}

	if vkCmdCopyBuffer.fnHandle == nil {
		vkCmdCopyBuffer.fnHandle = dlHandle.NewProc("vkCmdCopyBuffer")
	}
	syscall.SyscallN(vkCmdCopyBuffer.fnHandle.Addr(), uintptr(commandBuffer), uintptr(srcBuffer), uintptr(dstBuffer), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)))

}

var vkCmdCopyBuffer = &vkCommand{"vkCmdCopyBuffer", 5, true, nil}

// CmdCopyBuffer2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer2KHR.html
func CmdCopyBuffer2KHR(commandBuffer CommandBuffer, copyBufferInfo *CopyBufferInfo2KHR) {
	// Parameter is a singular input, requires translation - copyBufferInfo
	var pCopyBufferInfo *_vkCopyBufferInfo2KHR
	if copyBufferInfo != nil {
		pCopyBufferInfo = copyBufferInfo.Vulkanize()
	}

	if vkCmdCopyBuffer2KHR.fnHandle == nil {
		vkCmdCopyBuffer2KHR.fnHandle = dlHandle.NewProc("vkCmdCopyBuffer2KHR")
	}
	syscall.SyscallN(vkCmdCopyBuffer2KHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pCopyBufferInfo)))

}

var vkCmdCopyBuffer2KHR = &vkCommand{"vkCmdCopyBuffer2KHR", 2, true, nil}

// CmdCopyBufferToImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage.html
func CmdCopyBufferToImage(commandBuffer CommandBuffer, srcBuffer Buffer, dstImage Image, dstImageLayout ImageLayout, regions []BufferImageCopy) {
	regionCount := len(regions)
	// regions is an input slice that requires translation to an internal type
	var pRegions unsafe.Pointer
	if len(regions) > 0 {
		sl_regions := make([]_vkBufferImageCopy, regionCount)
		for i, v := range regions {
			sl_regions[i] = *(v.Vulkanize())
		}
		pRegions = unsafe.Pointer(&sl_regions[0])
	}

	if vkCmdCopyBufferToImage.fnHandle == nil {
		vkCmdCopyBufferToImage.fnHandle = dlHandle.NewProc("vkCmdCopyBufferToImage")
	}
	syscall.SyscallN(vkCmdCopyBufferToImage.fnHandle.Addr(), uintptr(commandBuffer), uintptr(srcBuffer), uintptr(dstImage), uintptr(dstImageLayout), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)))

}

var vkCmdCopyBufferToImage = &vkCommand{"vkCmdCopyBufferToImage", 6, true, nil}

// CmdCopyBufferToImage2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage2KHR.html
func CmdCopyBufferToImage2KHR(commandBuffer CommandBuffer, copyBufferToImageInfo *CopyBufferToImageInfo2KHR) {
	// Parameter is a singular input, requires translation - copyBufferToImageInfo
	var pCopyBufferToImageInfo *_vkCopyBufferToImageInfo2KHR
	if copyBufferToImageInfo != nil {
		pCopyBufferToImageInfo = copyBufferToImageInfo.Vulkanize()
	}

	if vkCmdCopyBufferToImage2KHR.fnHandle == nil {
		vkCmdCopyBufferToImage2KHR.fnHandle = dlHandle.NewProc("vkCmdCopyBufferToImage2KHR")
	}
	syscall.SyscallN(vkCmdCopyBufferToImage2KHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pCopyBufferToImageInfo)))

}

var vkCmdCopyBufferToImage2KHR = &vkCommand{"vkCmdCopyBufferToImage2KHR", 2, true, nil}

// CmdCopyImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage.html
func CmdCopyImage(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageCopy) {
	regionCount := len(regions)
	// regions is an input slice that requires translation to an internal type
	var pRegions unsafe.Pointer
	if len(regions) > 0 {
		sl_regions := make([]_vkImageCopy, regionCount)
		for i, v := range regions {
			sl_regions[i] = *(v.Vulkanize())
		}
		pRegions = unsafe.Pointer(&sl_regions[0])
	}

	if vkCmdCopyImage.fnHandle == nil {
		vkCmdCopyImage.fnHandle = dlHandle.NewProc("vkCmdCopyImage")
	}
	syscall.SyscallN(vkCmdCopyImage.fnHandle.Addr(), uintptr(commandBuffer), uintptr(srcImage), uintptr(srcImageLayout), uintptr(dstImage), uintptr(dstImageLayout), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)))

}

var vkCmdCopyImage = &vkCommand{"vkCmdCopyImage", 7, true, nil}

// CmdCopyImage2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage2KHR.html
func CmdCopyImage2KHR(commandBuffer CommandBuffer, copyImageInfo *CopyImageInfo2KHR) {
	// Parameter is a singular input, requires translation - copyImageInfo
	var pCopyImageInfo *_vkCopyImageInfo2KHR
	if copyImageInfo != nil {
		pCopyImageInfo = copyImageInfo.Vulkanize()
	}

	if vkCmdCopyImage2KHR.fnHandle == nil {
		vkCmdCopyImage2KHR.fnHandle = dlHandle.NewProc("vkCmdCopyImage2KHR")
	}
	syscall.SyscallN(vkCmdCopyImage2KHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pCopyImageInfo)))

}

var vkCmdCopyImage2KHR = &vkCommand{"vkCmdCopyImage2KHR", 2, true, nil}

// CmdCopyImageToBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer.html
func CmdCopyImageToBuffer(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstBuffer Buffer, regions []BufferImageCopy) {
	regionCount := len(regions)
	// regions is an input slice that requires translation to an internal type
	var pRegions unsafe.Pointer
	if len(regions) > 0 {
		sl_regions := make([]_vkBufferImageCopy, regionCount)
		for i, v := range regions {
			sl_regions[i] = *(v.Vulkanize())
		}
		pRegions = unsafe.Pointer(&sl_regions[0])
	}

	if vkCmdCopyImageToBuffer.fnHandle == nil {
		vkCmdCopyImageToBuffer.fnHandle = dlHandle.NewProc("vkCmdCopyImageToBuffer")
	}
	syscall.SyscallN(vkCmdCopyImageToBuffer.fnHandle.Addr(), uintptr(commandBuffer), uintptr(srcImage), uintptr(srcImageLayout), uintptr(dstBuffer), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)))

}

var vkCmdCopyImageToBuffer = &vkCommand{"vkCmdCopyImageToBuffer", 6, true, nil}

// CmdCopyImageToBuffer2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer2KHR.html
func CmdCopyImageToBuffer2KHR(commandBuffer CommandBuffer, copyImageToBufferInfo *CopyImageToBufferInfo2KHR) {
	// Parameter is a singular input, requires translation - copyImageToBufferInfo
	var pCopyImageToBufferInfo *_vkCopyImageToBufferInfo2KHR
	if copyImageToBufferInfo != nil {
		pCopyImageToBufferInfo = copyImageToBufferInfo.Vulkanize()
	}

	if vkCmdCopyImageToBuffer2KHR.fnHandle == nil {
		vkCmdCopyImageToBuffer2KHR.fnHandle = dlHandle.NewProc("vkCmdCopyImageToBuffer2KHR")
	}
	syscall.SyscallN(vkCmdCopyImageToBuffer2KHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pCopyImageToBufferInfo)))

}

var vkCmdCopyImageToBuffer2KHR = &vkCommand{"vkCmdCopyImageToBuffer2KHR", 2, true, nil}

// CmdCopyMemoryToAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryToAccelerationStructureKHR.html
func CmdCopyMemoryToAccelerationStructureKHR(commandBuffer CommandBuffer, info *CopyMemoryToAccelerationStructureInfoKHR) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMemoryToAccelerationStructureInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	if vkCmdCopyMemoryToAccelerationStructureKHR.fnHandle == nil {
		vkCmdCopyMemoryToAccelerationStructureKHR.fnHandle = dlHandle.NewProc("vkCmdCopyMemoryToAccelerationStructureKHR")
	}
	syscall.SyscallN(vkCmdCopyMemoryToAccelerationStructureKHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)))

}

var vkCmdCopyMemoryToAccelerationStructureKHR = &vkCommand{"vkCmdCopyMemoryToAccelerationStructureKHR", 2, true, nil}

// CmdCopyQueryPoolResults: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyQueryPoolResults.html
func CmdCopyQueryPoolResults(commandBuffer CommandBuffer, queryPool QueryPool, firstQuery uint32, queryCount uint32, dstBuffer Buffer, dstOffset DeviceSize, stride DeviceSize, flags QueryResultFlags) {

	if vkCmdCopyQueryPoolResults.fnHandle == nil {
		vkCmdCopyQueryPoolResults.fnHandle = dlHandle.NewProc("vkCmdCopyQueryPoolResults")
	}
	syscall.SyscallN(vkCmdCopyQueryPoolResults.fnHandle.Addr(), uintptr(commandBuffer), uintptr(queryPool), uintptr(firstQuery), uintptr(queryCount), uintptr(dstBuffer), uintptr(dstOffset), uintptr(stride), uintptr(flags))

}

var vkCmdCopyQueryPoolResults = &vkCommand{"vkCmdCopyQueryPoolResults", 8, true, nil}

// CmdCuLaunchKernelNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCuLaunchKernelNVX.html
func CmdCuLaunchKernelNVX(commandBuffer CommandBuffer, launchInfo *CuLaunchInfoNVX) {
	// Parameter is a singular input, requires translation - launchInfo
	var pLaunchInfo *_vkCuLaunchInfoNVX
	if launchInfo != nil {
		pLaunchInfo = launchInfo.Vulkanize()
	}

	if vkCmdCuLaunchKernelNVX.fnHandle == nil {
		vkCmdCuLaunchKernelNVX.fnHandle = dlHandle.NewProc("vkCmdCuLaunchKernelNVX")
	}
	syscall.SyscallN(vkCmdCuLaunchKernelNVX.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pLaunchInfo)))

}

var vkCmdCuLaunchKernelNVX = &vkCommand{"vkCmdCuLaunchKernelNVX", 2, true, nil}

// CmdDebugMarkerBeginEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDebugMarkerBeginEXT.html
func CmdDebugMarkerBeginEXT(commandBuffer CommandBuffer, markerInfo *DebugMarkerMarkerInfoEXT) {
	// Parameter is a singular input, requires translation - markerInfo
	var pMarkerInfo *_vkDebugMarkerMarkerInfoEXT
	if markerInfo != nil {
		pMarkerInfo = markerInfo.Vulkanize()
	}

	if vkCmdDebugMarkerBeginEXT.fnHandle == nil {
		vkCmdDebugMarkerBeginEXT.fnHandle = dlHandle.NewProc("vkCmdDebugMarkerBeginEXT")
	}
	syscall.SyscallN(vkCmdDebugMarkerBeginEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pMarkerInfo)))

}

var vkCmdDebugMarkerBeginEXT = &vkCommand{"vkCmdDebugMarkerBeginEXT", 2, true, nil}

// CmdDebugMarkerEndEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDebugMarkerEndEXT.html
func CmdDebugMarkerEndEXT(commandBuffer CommandBuffer) {

	if vkCmdDebugMarkerEndEXT.fnHandle == nil {
		vkCmdDebugMarkerEndEXT.fnHandle = dlHandle.NewProc("vkCmdDebugMarkerEndEXT")
	}
	syscall.SyscallN(vkCmdDebugMarkerEndEXT.fnHandle.Addr(), uintptr(commandBuffer))

}

var vkCmdDebugMarkerEndEXT = &vkCommand{"vkCmdDebugMarkerEndEXT", 1, true, nil}

// CmdDebugMarkerInsertEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDebugMarkerInsertEXT.html
func CmdDebugMarkerInsertEXT(commandBuffer CommandBuffer, markerInfo *DebugMarkerMarkerInfoEXT) {
	// Parameter is a singular input, requires translation - markerInfo
	var pMarkerInfo *_vkDebugMarkerMarkerInfoEXT
	if markerInfo != nil {
		pMarkerInfo = markerInfo.Vulkanize()
	}

	if vkCmdDebugMarkerInsertEXT.fnHandle == nil {
		vkCmdDebugMarkerInsertEXT.fnHandle = dlHandle.NewProc("vkCmdDebugMarkerInsertEXT")
	}
	syscall.SyscallN(vkCmdDebugMarkerInsertEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pMarkerInfo)))

}

var vkCmdDebugMarkerInsertEXT = &vkCommand{"vkCmdDebugMarkerInsertEXT", 2, true, nil}

// CmdDispatch: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatch.html
func CmdDispatch(commandBuffer CommandBuffer, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {

	if vkCmdDispatch.fnHandle == nil {
		vkCmdDispatch.fnHandle = dlHandle.NewProc("vkCmdDispatch")
	}
	syscall.SyscallN(vkCmdDispatch.fnHandle.Addr(), uintptr(commandBuffer), uintptr(groupCountX), uintptr(groupCountY), uintptr(groupCountZ))

}

var vkCmdDispatch = &vkCommand{"vkCmdDispatch", 4, true, nil}

// CmdDispatchBase: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchBase.html
func CmdDispatchBase(commandBuffer CommandBuffer, baseGroupX uint32, baseGroupY uint32, baseGroupZ uint32, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {

	if vkCmdDispatchBase.fnHandle == nil {
		vkCmdDispatchBase.fnHandle = dlHandle.NewProc("vkCmdDispatchBase")
	}
	syscall.SyscallN(vkCmdDispatchBase.fnHandle.Addr(), uintptr(commandBuffer), uintptr(baseGroupX), uintptr(baseGroupY), uintptr(baseGroupZ), uintptr(groupCountX), uintptr(groupCountY), uintptr(groupCountZ))

}

var vkCmdDispatchBase = &vkCommand{"vkCmdDispatchBase", 7, true, nil}
var CmdDispatchBaseKHR = CmdDispatchBase

// CmdDispatchIndirect: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchIndirect.html
func CmdDispatchIndirect(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize) {

	if vkCmdDispatchIndirect.fnHandle == nil {
		vkCmdDispatchIndirect.fnHandle = dlHandle.NewProc("vkCmdDispatchIndirect")
	}
	syscall.SyscallN(vkCmdDispatchIndirect.fnHandle.Addr(), uintptr(commandBuffer), uintptr(buffer), uintptr(offset))

}

var vkCmdDispatchIndirect = &vkCommand{"vkCmdDispatchIndirect", 3, true, nil}

// CmdDraw: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDraw.html
func CmdDraw(commandBuffer CommandBuffer, vertexCount uint32, instanceCount uint32, firstVertex uint32, firstInstance uint32) {

	if vkCmdDraw.fnHandle == nil {
		vkCmdDraw.fnHandle = dlHandle.NewProc("vkCmdDraw")
	}
	syscall.SyscallN(vkCmdDraw.fnHandle.Addr(), uintptr(commandBuffer), uintptr(vertexCount), uintptr(instanceCount), uintptr(firstVertex), uintptr(firstInstance))

}

var vkCmdDraw = &vkCommand{"vkCmdDraw", 5, true, nil}

// CmdDrawIndexed: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexed.html
func CmdDrawIndexed(commandBuffer CommandBuffer, indexCount uint32, instanceCount uint32, firstIndex uint32, vertexOffset int32, firstInstance uint32) {

	if vkCmdDrawIndexed.fnHandle == nil {
		vkCmdDrawIndexed.fnHandle = dlHandle.NewProc("vkCmdDrawIndexed")
	}
	syscall.SyscallN(vkCmdDrawIndexed.fnHandle.Addr(), uintptr(commandBuffer), uintptr(indexCount), uintptr(instanceCount), uintptr(firstIndex), uintptr(vertexOffset), uintptr(firstInstance))

}

var vkCmdDrawIndexed = &vkCommand{"vkCmdDrawIndexed", 6, true, nil}

// CmdDrawIndexedIndirect: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexedIndirect.html
func CmdDrawIndexedIndirect(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {

	if vkCmdDrawIndexedIndirect.fnHandle == nil {
		vkCmdDrawIndexedIndirect.fnHandle = dlHandle.NewProc("vkCmdDrawIndexedIndirect")
	}
	syscall.SyscallN(vkCmdDrawIndexedIndirect.fnHandle.Addr(), uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(drawCount), uintptr(stride))

}

var vkCmdDrawIndexedIndirect = &vkCommand{"vkCmdDrawIndexedIndirect", 5, true, nil}

// CmdDrawIndexedIndirectCount: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexedIndirectCount.html
func CmdDrawIndexedIndirectCount(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {

	if vkCmdDrawIndexedIndirectCount.fnHandle == nil {
		vkCmdDrawIndexedIndirectCount.fnHandle = dlHandle.NewProc("vkCmdDrawIndexedIndirectCount")
	}
	syscall.SyscallN(vkCmdDrawIndexedIndirectCount.fnHandle.Addr(), uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(countBuffer), uintptr(countBufferOffset), uintptr(maxDrawCount), uintptr(stride))

}

var vkCmdDrawIndexedIndirectCount = &vkCommand{"vkCmdDrawIndexedIndirectCount", 7, true, nil}
var CmdDrawIndexedIndirectCountAMD = CmdDrawIndexedIndirectCount

var CmdDrawIndexedIndirectCountKHR = CmdDrawIndexedIndirectCount

// CmdDrawIndirect: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirect.html
func CmdDrawIndirect(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {

	if vkCmdDrawIndirect.fnHandle == nil {
		vkCmdDrawIndirect.fnHandle = dlHandle.NewProc("vkCmdDrawIndirect")
	}
	syscall.SyscallN(vkCmdDrawIndirect.fnHandle.Addr(), uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(drawCount), uintptr(stride))

}

var vkCmdDrawIndirect = &vkCommand{"vkCmdDrawIndirect", 5, true, nil}

// CmdDrawIndirectByteCountEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirectByteCountEXT.html
func CmdDrawIndirectByteCountEXT(commandBuffer CommandBuffer, instanceCount uint32, firstInstance uint32, counterBuffer Buffer, counterBufferOffset DeviceSize, counterOffset uint32, vertexStride uint32) {

	if vkCmdDrawIndirectByteCountEXT.fnHandle == nil {
		vkCmdDrawIndirectByteCountEXT.fnHandle = dlHandle.NewProc("vkCmdDrawIndirectByteCountEXT")
	}
	syscall.SyscallN(vkCmdDrawIndirectByteCountEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(instanceCount), uintptr(firstInstance), uintptr(counterBuffer), uintptr(counterBufferOffset), uintptr(counterOffset), uintptr(vertexStride))

}

var vkCmdDrawIndirectByteCountEXT = &vkCommand{"vkCmdDrawIndirectByteCountEXT", 7, true, nil}

// CmdDrawIndirectCount: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirectCount.html
func CmdDrawIndirectCount(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {

	if vkCmdDrawIndirectCount.fnHandle == nil {
		vkCmdDrawIndirectCount.fnHandle = dlHandle.NewProc("vkCmdDrawIndirectCount")
	}
	syscall.SyscallN(vkCmdDrawIndirectCount.fnHandle.Addr(), uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(countBuffer), uintptr(countBufferOffset), uintptr(maxDrawCount), uintptr(stride))

}

var vkCmdDrawIndirectCount = &vkCommand{"vkCmdDrawIndirectCount", 7, true, nil}
var CmdDrawIndirectCountAMD = CmdDrawIndirectCount

var CmdDrawIndirectCountKHR = CmdDrawIndirectCount

// CmdDrawMeshTasksIndirectCountNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectCountNV.html
func CmdDrawMeshTasksIndirectCountNV(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {

	if vkCmdDrawMeshTasksIndirectCountNV.fnHandle == nil {
		vkCmdDrawMeshTasksIndirectCountNV.fnHandle = dlHandle.NewProc("vkCmdDrawMeshTasksIndirectCountNV")
	}
	syscall.SyscallN(vkCmdDrawMeshTasksIndirectCountNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(countBuffer), uintptr(countBufferOffset), uintptr(maxDrawCount), uintptr(stride))

}

var vkCmdDrawMeshTasksIndirectCountNV = &vkCommand{"vkCmdDrawMeshTasksIndirectCountNV", 7, true, nil}

// CmdDrawMeshTasksIndirectNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectNV.html
func CmdDrawMeshTasksIndirectNV(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {

	if vkCmdDrawMeshTasksIndirectNV.fnHandle == nil {
		vkCmdDrawMeshTasksIndirectNV.fnHandle = dlHandle.NewProc("vkCmdDrawMeshTasksIndirectNV")
	}
	syscall.SyscallN(vkCmdDrawMeshTasksIndirectNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(drawCount), uintptr(stride))

}

var vkCmdDrawMeshTasksIndirectNV = &vkCommand{"vkCmdDrawMeshTasksIndirectNV", 5, true, nil}

// CmdDrawMeshTasksNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksNV.html
func CmdDrawMeshTasksNV(commandBuffer CommandBuffer, taskCount uint32, firstTask uint32) {

	if vkCmdDrawMeshTasksNV.fnHandle == nil {
		vkCmdDrawMeshTasksNV.fnHandle = dlHandle.NewProc("vkCmdDrawMeshTasksNV")
	}
	syscall.SyscallN(vkCmdDrawMeshTasksNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(taskCount), uintptr(firstTask))

}

var vkCmdDrawMeshTasksNV = &vkCommand{"vkCmdDrawMeshTasksNV", 3, true, nil}

// CmdDrawMultiEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMultiEXT.html
func CmdDrawMultiEXT(commandBuffer CommandBuffer, vertexInfo []MultiDrawInfoEXT, instanceCount uint32, firstInstance uint32, stride uint32) {
	drawCount := len(vertexInfo)
	// vertexInfo is an input slice of values that do not need translation used
	var pVertexInfo unsafe.Pointer
	if vertexInfo != nil {
		pVertexInfo = unsafe.Pointer(&vertexInfo[0])
	}

	if vkCmdDrawMultiEXT.fnHandle == nil {
		vkCmdDrawMultiEXT.fnHandle = dlHandle.NewProc("vkCmdDrawMultiEXT")
	}
	syscall.SyscallN(vkCmdDrawMultiEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(drawCount), uintptr(unsafe.Pointer(pVertexInfo)), uintptr(instanceCount), uintptr(firstInstance), uintptr(stride))

}

var vkCmdDrawMultiEXT = &vkCommand{"vkCmdDrawMultiEXT", 6, true, nil}

// CmdDrawMultiIndexedEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMultiIndexedEXT.html
func CmdDrawMultiIndexedEXT(commandBuffer CommandBuffer, indexInfo []MultiDrawIndexedInfoEXT, instanceCount uint32, firstInstance uint32, stride uint32, vertexOffset *int32) {
	drawCount := len(indexInfo)
	// indexInfo is an input slice of values that do not need translation used
	var pIndexInfo unsafe.Pointer
	if indexInfo != nil {
		pIndexInfo = unsafe.Pointer(&indexInfo[0])
	}

	// Parameter is a singular input, pass direct - vertexOffset
	var pVertexOffset unsafe.Pointer
	if vertexOffset != nil {
		pVertexOffset = unsafe.Pointer(vertexOffset)
	}

	if vkCmdDrawMultiIndexedEXT.fnHandle == nil {
		vkCmdDrawMultiIndexedEXT.fnHandle = dlHandle.NewProc("vkCmdDrawMultiIndexedEXT")
	}
	syscall.SyscallN(vkCmdDrawMultiIndexedEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(drawCount), uintptr(unsafe.Pointer(pIndexInfo)), uintptr(instanceCount), uintptr(firstInstance), uintptr(stride), uintptr(unsafe.Pointer(pVertexOffset)))

}

var vkCmdDrawMultiIndexedEXT = &vkCommand{"vkCmdDrawMultiIndexedEXT", 7, true, nil}

// CmdEndConditionalRenderingEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndConditionalRenderingEXT.html
func CmdEndConditionalRenderingEXT(commandBuffer CommandBuffer) {

	if vkCmdEndConditionalRenderingEXT.fnHandle == nil {
		vkCmdEndConditionalRenderingEXT.fnHandle = dlHandle.NewProc("vkCmdEndConditionalRenderingEXT")
	}
	syscall.SyscallN(vkCmdEndConditionalRenderingEXT.fnHandle.Addr(), uintptr(commandBuffer))

}

var vkCmdEndConditionalRenderingEXT = &vkCommand{"vkCmdEndConditionalRenderingEXT", 1, true, nil}

// CmdEndDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndDebugUtilsLabelEXT.html
func CmdEndDebugUtilsLabelEXT(commandBuffer CommandBuffer) {

	if vkCmdEndDebugUtilsLabelEXT.fnHandle == nil {
		vkCmdEndDebugUtilsLabelEXT.fnHandle = dlHandle.NewProc("vkCmdEndDebugUtilsLabelEXT")
	}
	syscall.SyscallN(vkCmdEndDebugUtilsLabelEXT.fnHandle.Addr(), uintptr(commandBuffer))

}

var vkCmdEndDebugUtilsLabelEXT = &vkCommand{"vkCmdEndDebugUtilsLabelEXT", 1, true, nil}

// CmdEndQuery: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndQuery.html
func CmdEndQuery(commandBuffer CommandBuffer, queryPool QueryPool, query uint32) {

	if vkCmdEndQuery.fnHandle == nil {
		vkCmdEndQuery.fnHandle = dlHandle.NewProc("vkCmdEndQuery")
	}
	syscall.SyscallN(vkCmdEndQuery.fnHandle.Addr(), uintptr(commandBuffer), uintptr(queryPool), uintptr(query))

}

var vkCmdEndQuery = &vkCommand{"vkCmdEndQuery", 3, true, nil}

// CmdEndQueryIndexedEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndQueryIndexedEXT.html
func CmdEndQueryIndexedEXT(commandBuffer CommandBuffer, queryPool QueryPool, query uint32, index uint32) {

	if vkCmdEndQueryIndexedEXT.fnHandle == nil {
		vkCmdEndQueryIndexedEXT.fnHandle = dlHandle.NewProc("vkCmdEndQueryIndexedEXT")
	}
	syscall.SyscallN(vkCmdEndQueryIndexedEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(queryPool), uintptr(query), uintptr(index))

}

var vkCmdEndQueryIndexedEXT = &vkCommand{"vkCmdEndQueryIndexedEXT", 4, true, nil}

// CmdEndRenderPass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderPass.html
func CmdEndRenderPass(commandBuffer CommandBuffer) {

	if vkCmdEndRenderPass.fnHandle == nil {
		vkCmdEndRenderPass.fnHandle = dlHandle.NewProc("vkCmdEndRenderPass")
	}
	syscall.SyscallN(vkCmdEndRenderPass.fnHandle.Addr(), uintptr(commandBuffer))

}

var vkCmdEndRenderPass = &vkCommand{"vkCmdEndRenderPass", 1, true, nil}

// CmdEndRenderPass2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderPass2.html
func CmdEndRenderPass2(commandBuffer CommandBuffer, subpassEndInfo *SubpassEndInfo) {
	// Parameter is a singular input, requires translation - subpassEndInfo
	var pSubpassEndInfo *_vkSubpassEndInfo
	if subpassEndInfo != nil {
		pSubpassEndInfo = subpassEndInfo.Vulkanize()
	}

	if vkCmdEndRenderPass2.fnHandle == nil {
		vkCmdEndRenderPass2.fnHandle = dlHandle.NewProc("vkCmdEndRenderPass2")
	}
	syscall.SyscallN(vkCmdEndRenderPass2.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pSubpassEndInfo)))

}

var vkCmdEndRenderPass2 = &vkCommand{"vkCmdEndRenderPass2", 2, true, nil}
var CmdEndRenderPass2KHR = CmdEndRenderPass2

// CmdEndRenderingKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderingKHR.html
func CmdEndRenderingKHR(commandBuffer CommandBuffer) {

	if vkCmdEndRenderingKHR.fnHandle == nil {
		vkCmdEndRenderingKHR.fnHandle = dlHandle.NewProc("vkCmdEndRenderingKHR")
	}
	syscall.SyscallN(vkCmdEndRenderingKHR.fnHandle.Addr(), uintptr(commandBuffer))

}

var vkCmdEndRenderingKHR = &vkCommand{"vkCmdEndRenderingKHR", 1, true, nil}

// CmdEndTransformFeedbackEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndTransformFeedbackEXT.html
func CmdEndTransformFeedbackEXT(commandBuffer CommandBuffer, firstCounterBuffer uint32, counterBuffers []Buffer, counterBufferOffsets []DeviceSize) {
	counterBufferCount := len(counterBuffers)
	// counterBuffers is an input slice of values that do not need translation used
	var pCounterBuffers unsafe.Pointer
	if counterBuffers != nil {
		pCounterBuffers = unsafe.Pointer(&counterBuffers[0])
	}

	// counterBufferOffsets is an input slice of values that do not need translation used
	var pCounterBufferOffsets unsafe.Pointer
	if counterBufferOffsets != nil {
		pCounterBufferOffsets = unsafe.Pointer(&counterBufferOffsets[0])
	}

	if vkCmdEndTransformFeedbackEXT.fnHandle == nil {
		vkCmdEndTransformFeedbackEXT.fnHandle = dlHandle.NewProc("vkCmdEndTransformFeedbackEXT")
	}
	syscall.SyscallN(vkCmdEndTransformFeedbackEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(firstCounterBuffer), uintptr(counterBufferCount), uintptr(unsafe.Pointer(pCounterBuffers)), uintptr(unsafe.Pointer(pCounterBufferOffsets)))

}

var vkCmdEndTransformFeedbackEXT = &vkCommand{"vkCmdEndTransformFeedbackEXT", 5, true, nil}

// CmdExecuteCommands: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdExecuteCommands.html
func CmdExecuteCommands(commandBuffer CommandBuffer, commandBuffers []CommandBuffer) {
	commandBufferCount := len(commandBuffers)
	// commandBuffers is an input slice of values that do not need translation used
	var pCommandBuffers unsafe.Pointer
	if commandBuffers != nil {
		pCommandBuffers = unsafe.Pointer(&commandBuffers[0])
	}

	if vkCmdExecuteCommands.fnHandle == nil {
		vkCmdExecuteCommands.fnHandle = dlHandle.NewProc("vkCmdExecuteCommands")
	}
	syscall.SyscallN(vkCmdExecuteCommands.fnHandle.Addr(), uintptr(commandBuffer), uintptr(commandBufferCount), uintptr(unsafe.Pointer(pCommandBuffers)))

}

var vkCmdExecuteCommands = &vkCommand{"vkCmdExecuteCommands", 3, true, nil}

// CmdExecuteGeneratedCommandsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdExecuteGeneratedCommandsNV.html
func CmdExecuteGeneratedCommandsNV(commandBuffer CommandBuffer, isPreprocessed bool, generatedCommandsInfo *GeneratedCommandsInfoNV) {
	isPreprocessed_Bool32 := translateInternal_Bool32(isPreprocessed)
	// Parameter is a singular input, requires translation - generatedCommandsInfo
	var pGeneratedCommandsInfo *_vkGeneratedCommandsInfoNV
	if generatedCommandsInfo != nil {
		pGeneratedCommandsInfo = generatedCommandsInfo.Vulkanize()
	}

	if vkCmdExecuteGeneratedCommandsNV.fnHandle == nil {
		vkCmdExecuteGeneratedCommandsNV.fnHandle = dlHandle.NewProc("vkCmdExecuteGeneratedCommandsNV")
	}
	syscall.SyscallN(vkCmdExecuteGeneratedCommandsNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(isPreprocessed_Bool32), uintptr(unsafe.Pointer(pGeneratedCommandsInfo)))

}

var vkCmdExecuteGeneratedCommandsNV = &vkCommand{"vkCmdExecuteGeneratedCommandsNV", 3, true, nil}

// CmdFillBuffer: transfer support is only available when VK_KHR_maintenance1 is enabled, as documented in valid usage language in the specification
// See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdFillBuffer.html
func CmdFillBuffer(commandBuffer CommandBuffer, dstBuffer Buffer, dstOffset DeviceSize, size DeviceSize, data uint32) {

	if vkCmdFillBuffer.fnHandle == nil {
		vkCmdFillBuffer.fnHandle = dlHandle.NewProc("vkCmdFillBuffer")
	}
	syscall.SyscallN(vkCmdFillBuffer.fnHandle.Addr(), uintptr(commandBuffer), uintptr(dstBuffer), uintptr(dstOffset), uintptr(size), uintptr(data))

}

var vkCmdFillBuffer = &vkCommand{"vkCmdFillBuffer", 5, true, nil}

// CmdInsertDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdInsertDebugUtilsLabelEXT.html
func CmdInsertDebugUtilsLabelEXT(commandBuffer CommandBuffer, labelInfo *DebugUtilsLabelEXT) {
	// Parameter is a singular input, requires translation - labelInfo
	var pLabelInfo *_vkDebugUtilsLabelEXT
	if labelInfo != nil {
		pLabelInfo = labelInfo.Vulkanize()
	}

	if vkCmdInsertDebugUtilsLabelEXT.fnHandle == nil {
		vkCmdInsertDebugUtilsLabelEXT.fnHandle = dlHandle.NewProc("vkCmdInsertDebugUtilsLabelEXT")
	}
	syscall.SyscallN(vkCmdInsertDebugUtilsLabelEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pLabelInfo)))

}

var vkCmdInsertDebugUtilsLabelEXT = &vkCommand{"vkCmdInsertDebugUtilsLabelEXT", 2, true, nil}

// CmdNextSubpass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdNextSubpass.html
func CmdNextSubpass(commandBuffer CommandBuffer, contents SubpassContents) {

	if vkCmdNextSubpass.fnHandle == nil {
		vkCmdNextSubpass.fnHandle = dlHandle.NewProc("vkCmdNextSubpass")
	}
	syscall.SyscallN(vkCmdNextSubpass.fnHandle.Addr(), uintptr(commandBuffer), uintptr(contents))

}

var vkCmdNextSubpass = &vkCommand{"vkCmdNextSubpass", 2, true, nil}

// CmdNextSubpass2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdNextSubpass2.html
func CmdNextSubpass2(commandBuffer CommandBuffer, subpassBeginInfo *SubpassBeginInfo, subpassEndInfo *SubpassEndInfo) {
	// Parameter is a singular input, requires translation - subpassBeginInfo
	var pSubpassBeginInfo *_vkSubpassBeginInfo
	if subpassBeginInfo != nil {
		pSubpassBeginInfo = subpassBeginInfo.Vulkanize()
	}

	// Parameter is a singular input, requires translation - subpassEndInfo
	var pSubpassEndInfo *_vkSubpassEndInfo
	if subpassEndInfo != nil {
		pSubpassEndInfo = subpassEndInfo.Vulkanize()
	}

	if vkCmdNextSubpass2.fnHandle == nil {
		vkCmdNextSubpass2.fnHandle = dlHandle.NewProc("vkCmdNextSubpass2")
	}
	syscall.SyscallN(vkCmdNextSubpass2.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pSubpassBeginInfo)), uintptr(unsafe.Pointer(pSubpassEndInfo)))

}

var vkCmdNextSubpass2 = &vkCommand{"vkCmdNextSubpass2", 3, true, nil}
var CmdNextSubpass2KHR = CmdNextSubpass2

// CmdPipelineBarrier: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier.html
func CmdPipelineBarrier(commandBuffer CommandBuffer, srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, dependencyFlags DependencyFlags, memoryBarriers []MemoryBarrier, bufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarriers []ImageMemoryBarrier) {
	memoryBarrierCount := len(memoryBarriers)
	// memoryBarriers is an input slice that requires translation to an internal type
	var pMemoryBarriers unsafe.Pointer
	if len(memoryBarriers) > 0 {
		sl_memoryBarriers := make([]_vkMemoryBarrier, memoryBarrierCount)
		for i, v := range memoryBarriers {
			sl_memoryBarriers[i] = *(v.Vulkanize())
		}
		pMemoryBarriers = unsafe.Pointer(&sl_memoryBarriers[0])
	}

	bufferMemoryBarrierCount := len(bufferMemoryBarriers)
	// bufferMemoryBarriers is an input slice that requires translation to an internal type
	var pBufferMemoryBarriers unsafe.Pointer
	if len(bufferMemoryBarriers) > 0 {
		sl_bufferMemoryBarriers := make([]_vkBufferMemoryBarrier, bufferMemoryBarrierCount)
		for i, v := range bufferMemoryBarriers {
			sl_bufferMemoryBarriers[i] = *(v.Vulkanize())
		}
		pBufferMemoryBarriers = unsafe.Pointer(&sl_bufferMemoryBarriers[0])
	}

	imageMemoryBarrierCount := len(imageMemoryBarriers)
	// imageMemoryBarriers is an input slice that requires translation to an internal type
	var pImageMemoryBarriers unsafe.Pointer
	if len(imageMemoryBarriers) > 0 {
		sl_imageMemoryBarriers := make([]_vkImageMemoryBarrier, imageMemoryBarrierCount)
		for i, v := range imageMemoryBarriers {
			sl_imageMemoryBarriers[i] = *(v.Vulkanize())
		}
		pImageMemoryBarriers = unsafe.Pointer(&sl_imageMemoryBarriers[0])
	}

	if vkCmdPipelineBarrier.fnHandle == nil {
		vkCmdPipelineBarrier.fnHandle = dlHandle.NewProc("vkCmdPipelineBarrier")
	}
	syscall.SyscallN(vkCmdPipelineBarrier.fnHandle.Addr(), uintptr(commandBuffer), uintptr(srcStageMask), uintptr(dstStageMask), uintptr(dependencyFlags), uintptr(memoryBarrierCount), uintptr(unsafe.Pointer(pMemoryBarriers)), uintptr(bufferMemoryBarrierCount), uintptr(unsafe.Pointer(pBufferMemoryBarriers)), uintptr(imageMemoryBarrierCount), uintptr(unsafe.Pointer(pImageMemoryBarriers)))

}

var vkCmdPipelineBarrier = &vkCommand{"vkCmdPipelineBarrier", 10, true, nil}

// CmdPipelineBarrier2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier2KHR.html
func CmdPipelineBarrier2KHR(commandBuffer CommandBuffer, dependencyInfo *DependencyInfoKHR) {
	// Parameter is a singular input, requires translation - dependencyInfo
	var pDependencyInfo *_vkDependencyInfoKHR
	if dependencyInfo != nil {
		pDependencyInfo = dependencyInfo.Vulkanize()
	}

	if vkCmdPipelineBarrier2KHR.fnHandle == nil {
		vkCmdPipelineBarrier2KHR.fnHandle = dlHandle.NewProc("vkCmdPipelineBarrier2KHR")
	}
	syscall.SyscallN(vkCmdPipelineBarrier2KHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pDependencyInfo)))

}

var vkCmdPipelineBarrier2KHR = &vkCommand{"vkCmdPipelineBarrier2KHR", 2, true, nil}

// CmdPreprocessGeneratedCommandsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPreprocessGeneratedCommandsNV.html
func CmdPreprocessGeneratedCommandsNV(commandBuffer CommandBuffer, generatedCommandsInfo *GeneratedCommandsInfoNV) {
	// Parameter is a singular input, requires translation - generatedCommandsInfo
	var pGeneratedCommandsInfo *_vkGeneratedCommandsInfoNV
	if generatedCommandsInfo != nil {
		pGeneratedCommandsInfo = generatedCommandsInfo.Vulkanize()
	}

	if vkCmdPreprocessGeneratedCommandsNV.fnHandle == nil {
		vkCmdPreprocessGeneratedCommandsNV.fnHandle = dlHandle.NewProc("vkCmdPreprocessGeneratedCommandsNV")
	}
	syscall.SyscallN(vkCmdPreprocessGeneratedCommandsNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pGeneratedCommandsInfo)))

}

var vkCmdPreprocessGeneratedCommandsNV = &vkCommand{"vkCmdPreprocessGeneratedCommandsNV", 2, true, nil}

// CmdPushConstants: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushConstants.html
func CmdPushConstants(commandBuffer CommandBuffer, layout PipelineLayout, stageFlags ShaderStageFlags, offset uint32, values []byte) {
	size := len(values)
	// values is an input slice of values that do not need translation used
	var pValues unsafe.Pointer
	if values != nil {
		pValues = unsafe.Pointer(&values[0])
	}

	if vkCmdPushConstants.fnHandle == nil {
		vkCmdPushConstants.fnHandle = dlHandle.NewProc("vkCmdPushConstants")
	}
	syscall.SyscallN(vkCmdPushConstants.fnHandle.Addr(), uintptr(commandBuffer), uintptr(layout), uintptr(stageFlags), uintptr(offset), uintptr(size), uintptr(unsafe.Pointer(pValues)))

}

var vkCmdPushConstants = &vkCommand{"vkCmdPushConstants", 6, true, nil}

// CmdPushDescriptorSetKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSetKHR.html
func CmdPushDescriptorSetKHR(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, layout PipelineLayout, set uint32, descriptorWrites []WriteDescriptorSet) {
	descriptorWriteCount := len(descriptorWrites)
	// descriptorWrites is an input slice that requires translation to an internal type
	var pDescriptorWrites unsafe.Pointer
	if len(descriptorWrites) > 0 {
		sl_descriptorWrites := make([]_vkWriteDescriptorSet, descriptorWriteCount)
		for i, v := range descriptorWrites {
			sl_descriptorWrites[i] = *(v.Vulkanize())
		}
		pDescriptorWrites = unsafe.Pointer(&sl_descriptorWrites[0])
	}

	if vkCmdPushDescriptorSetKHR.fnHandle == nil {
		vkCmdPushDescriptorSetKHR.fnHandle = dlHandle.NewProc("vkCmdPushDescriptorSetKHR")
	}
	syscall.SyscallN(vkCmdPushDescriptorSetKHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(layout), uintptr(set), uintptr(descriptorWriteCount), uintptr(unsafe.Pointer(pDescriptorWrites)))

}

var vkCmdPushDescriptorSetKHR = &vkCommand{"vkCmdPushDescriptorSetKHR", 6, true, nil}

// CmdPushDescriptorSetWithTemplateKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSetWithTemplateKHR.html
func CmdPushDescriptorSetWithTemplateKHR(commandBuffer CommandBuffer, descriptorUpdateTemplate DescriptorUpdateTemplate, layout PipelineLayout, set uint32, data *byte) {
	// Parameter is a singular input, pass direct - data
	var pData unsafe.Pointer
	if data != nil {
		pData = unsafe.Pointer(data)
	}

	if vkCmdPushDescriptorSetWithTemplateKHR.fnHandle == nil {
		vkCmdPushDescriptorSetWithTemplateKHR.fnHandle = dlHandle.NewProc("vkCmdPushDescriptorSetWithTemplateKHR")
	}
	syscall.SyscallN(vkCmdPushDescriptorSetWithTemplateKHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(descriptorUpdateTemplate), uintptr(layout), uintptr(set), uintptr(unsafe.Pointer(pData)))

}

var vkCmdPushDescriptorSetWithTemplateKHR = &vkCommand{"vkCmdPushDescriptorSetWithTemplateKHR", 5, true, nil}

// CmdResetEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent.html
func CmdResetEvent(commandBuffer CommandBuffer, event Event, stageMask PipelineStageFlags) {

	if vkCmdResetEvent.fnHandle == nil {
		vkCmdResetEvent.fnHandle = dlHandle.NewProc("vkCmdResetEvent")
	}
	syscall.SyscallN(vkCmdResetEvent.fnHandle.Addr(), uintptr(commandBuffer), uintptr(event), uintptr(stageMask))

}

var vkCmdResetEvent = &vkCommand{"vkCmdResetEvent", 3, true, nil}

// CmdResetEvent2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent2KHR.html
func CmdResetEvent2KHR(commandBuffer CommandBuffer, event Event, stageMask PipelineStageFlags2KHR) {

	if vkCmdResetEvent2KHR.fnHandle == nil {
		vkCmdResetEvent2KHR.fnHandle = dlHandle.NewProc("vkCmdResetEvent2KHR")
	}
	syscall.SyscallN(vkCmdResetEvent2KHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(event), uintptr(stageMask))

}

var vkCmdResetEvent2KHR = &vkCommand{"vkCmdResetEvent2KHR", 3, true, nil}

// CmdResetQueryPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetQueryPool.html
func CmdResetQueryPool(commandBuffer CommandBuffer, queryPool QueryPool, firstQuery uint32, queryCount uint32) {

	if vkCmdResetQueryPool.fnHandle == nil {
		vkCmdResetQueryPool.fnHandle = dlHandle.NewProc("vkCmdResetQueryPool")
	}
	syscall.SyscallN(vkCmdResetQueryPool.fnHandle.Addr(), uintptr(commandBuffer), uintptr(queryPool), uintptr(firstQuery), uintptr(queryCount))

}

var vkCmdResetQueryPool = &vkCommand{"vkCmdResetQueryPool", 4, true, nil}

// CmdResolveImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage.html
func CmdResolveImage(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageResolve) {
	regionCount := len(regions)
	// regions is an input slice that requires translation to an internal type
	var pRegions unsafe.Pointer
	if len(regions) > 0 {
		sl_regions := make([]_vkImageResolve, regionCount)
		for i, v := range regions {
			sl_regions[i] = *(v.Vulkanize())
		}
		pRegions = unsafe.Pointer(&sl_regions[0])
	}

	if vkCmdResolveImage.fnHandle == nil {
		vkCmdResolveImage.fnHandle = dlHandle.NewProc("vkCmdResolveImage")
	}
	syscall.SyscallN(vkCmdResolveImage.fnHandle.Addr(), uintptr(commandBuffer), uintptr(srcImage), uintptr(srcImageLayout), uintptr(dstImage), uintptr(dstImageLayout), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)))

}

var vkCmdResolveImage = &vkCommand{"vkCmdResolveImage", 7, true, nil}

// CmdResolveImage2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage2KHR.html
func CmdResolveImage2KHR(commandBuffer CommandBuffer, resolveImageInfo *ResolveImageInfo2KHR) {
	// Parameter is a singular input, requires translation - resolveImageInfo
	var pResolveImageInfo *_vkResolveImageInfo2KHR
	if resolveImageInfo != nil {
		pResolveImageInfo = resolveImageInfo.Vulkanize()
	}

	if vkCmdResolveImage2KHR.fnHandle == nil {
		vkCmdResolveImage2KHR.fnHandle = dlHandle.NewProc("vkCmdResolveImage2KHR")
	}
	syscall.SyscallN(vkCmdResolveImage2KHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pResolveImageInfo)))

}

var vkCmdResolveImage2KHR = &vkCommand{"vkCmdResolveImage2KHR", 2, true, nil}

// CmdSetBlendConstants: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetBlendConstants.html
func CmdSetBlendConstants(commandBuffer CommandBuffer, blendConstants float32) {

	if vkCmdSetBlendConstants.fnHandle == nil {
		vkCmdSetBlendConstants.fnHandle = dlHandle.NewProc("vkCmdSetBlendConstants")
	}
	syscall.SyscallN(vkCmdSetBlendConstants.fnHandle.Addr(), uintptr(commandBuffer), uintptr(blendConstants))

}

var vkCmdSetBlendConstants = &vkCommand{"vkCmdSetBlendConstants", 2, true, nil}

// CmdSetCheckpointNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCheckpointNV.html
func CmdSetCheckpointNV(commandBuffer CommandBuffer, checkpointMarker *byte) {
	// Parameter is a singular input, pass direct - checkpointMarker
	var pCheckpointMarker unsafe.Pointer
	if checkpointMarker != nil {
		pCheckpointMarker = unsafe.Pointer(checkpointMarker)
	}

	if vkCmdSetCheckpointNV.fnHandle == nil {
		vkCmdSetCheckpointNV.fnHandle = dlHandle.NewProc("vkCmdSetCheckpointNV")
	}
	syscall.SyscallN(vkCmdSetCheckpointNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pCheckpointMarker)))

}

var vkCmdSetCheckpointNV = &vkCommand{"vkCmdSetCheckpointNV", 2, true, nil}

// CmdSetCoarseSampleOrderNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoarseSampleOrderNV.html
func CmdSetCoarseSampleOrderNV(commandBuffer CommandBuffer, sampleOrderType CoarseSampleOrderTypeNV, customSampleOrders []CoarseSampleOrderCustomNV) {
	customSampleOrderCount := len(customSampleOrders)
	// customSampleOrders is an input slice that requires translation to an internal type
	var pCustomSampleOrders unsafe.Pointer
	if len(customSampleOrders) > 0 {
		sl_customSampleOrders := make([]_vkCoarseSampleOrderCustomNV, customSampleOrderCount)
		for i, v := range customSampleOrders {
			sl_customSampleOrders[i] = *(v.Vulkanize())
		}
		pCustomSampleOrders = unsafe.Pointer(&sl_customSampleOrders[0])
	}

	if vkCmdSetCoarseSampleOrderNV.fnHandle == nil {
		vkCmdSetCoarseSampleOrderNV.fnHandle = dlHandle.NewProc("vkCmdSetCoarseSampleOrderNV")
	}
	syscall.SyscallN(vkCmdSetCoarseSampleOrderNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(sampleOrderType), uintptr(customSampleOrderCount), uintptr(unsafe.Pointer(pCustomSampleOrders)))

}

var vkCmdSetCoarseSampleOrderNV = &vkCommand{"vkCmdSetCoarseSampleOrderNV", 4, true, nil}

// CmdSetColorWriteEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorWriteEnableEXT.html
func CmdSetColorWriteEnableEXT(commandBuffer CommandBuffer, colorWriteEnables []bool) {
	attachmentCount := len(colorWriteEnables)
	// colorWriteEnables is an input slice that requires translation to an internal type
	var pColorWriteEnables unsafe.Pointer
	if len(colorWriteEnables) > 0 {
		sl_colorWriteEnables := make([]Bool32, attachmentCount)
		for i, v := range colorWriteEnables {
			sl_colorWriteEnables[i] = translateInternal_Bool32(v)
		}
		pColorWriteEnables = unsafe.Pointer(&sl_colorWriteEnables[0])
	}

	if vkCmdSetColorWriteEnableEXT.fnHandle == nil {
		vkCmdSetColorWriteEnableEXT.fnHandle = dlHandle.NewProc("vkCmdSetColorWriteEnableEXT")
	}
	syscall.SyscallN(vkCmdSetColorWriteEnableEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(attachmentCount), uintptr(unsafe.Pointer(pColorWriteEnables)))

}

var vkCmdSetColorWriteEnableEXT = &vkCommand{"vkCmdSetColorWriteEnableEXT", 3, true, nil}

// CmdSetCullModeEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCullModeEXT.html
func CmdSetCullModeEXT(commandBuffer CommandBuffer, cullMode CullModeFlags) {

	if vkCmdSetCullModeEXT.fnHandle == nil {
		vkCmdSetCullModeEXT.fnHandle = dlHandle.NewProc("vkCmdSetCullModeEXT")
	}
	syscall.SyscallN(vkCmdSetCullModeEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(cullMode))

}

var vkCmdSetCullModeEXT = &vkCommand{"vkCmdSetCullModeEXT", 2, true, nil}

// CmdSetDepthBias: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBias.html
func CmdSetDepthBias(commandBuffer CommandBuffer, depthBiasConstantFactor float32, depthBiasClamp float32, depthBiasSlopeFactor float32) {

	if vkCmdSetDepthBias.fnHandle == nil {
		vkCmdSetDepthBias.fnHandle = dlHandle.NewProc("vkCmdSetDepthBias")
	}
	syscall.SyscallN(vkCmdSetDepthBias.fnHandle.Addr(), uintptr(commandBuffer), uintptr(depthBiasConstantFactor), uintptr(depthBiasClamp), uintptr(depthBiasSlopeFactor))

}

var vkCmdSetDepthBias = &vkCommand{"vkCmdSetDepthBias", 4, true, nil}

// CmdSetDepthBiasEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBiasEnableEXT.html
func CmdSetDepthBiasEnableEXT(commandBuffer CommandBuffer, depthBiasEnable bool) {
	depthBiasEnable_Bool32 := translateInternal_Bool32(depthBiasEnable)

	if vkCmdSetDepthBiasEnableEXT.fnHandle == nil {
		vkCmdSetDepthBiasEnableEXT.fnHandle = dlHandle.NewProc("vkCmdSetDepthBiasEnableEXT")
	}
	syscall.SyscallN(vkCmdSetDepthBiasEnableEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(depthBiasEnable_Bool32))

}

var vkCmdSetDepthBiasEnableEXT = &vkCommand{"vkCmdSetDepthBiasEnableEXT", 2, true, nil}

// CmdSetDepthBounds: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBounds.html
func CmdSetDepthBounds(commandBuffer CommandBuffer, minDepthBounds float32, maxDepthBounds float32) {

	if vkCmdSetDepthBounds.fnHandle == nil {
		vkCmdSetDepthBounds.fnHandle = dlHandle.NewProc("vkCmdSetDepthBounds")
	}
	syscall.SyscallN(vkCmdSetDepthBounds.fnHandle.Addr(), uintptr(commandBuffer), uintptr(minDepthBounds), uintptr(maxDepthBounds))

}

var vkCmdSetDepthBounds = &vkCommand{"vkCmdSetDepthBounds", 3, true, nil}

// CmdSetDepthBoundsTestEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBoundsTestEnableEXT.html
func CmdSetDepthBoundsTestEnableEXT(commandBuffer CommandBuffer, depthBoundsTestEnable bool) {
	depthBoundsTestEnable_Bool32 := translateInternal_Bool32(depthBoundsTestEnable)

	if vkCmdSetDepthBoundsTestEnableEXT.fnHandle == nil {
		vkCmdSetDepthBoundsTestEnableEXT.fnHandle = dlHandle.NewProc("vkCmdSetDepthBoundsTestEnableEXT")
	}
	syscall.SyscallN(vkCmdSetDepthBoundsTestEnableEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(depthBoundsTestEnable_Bool32))

}

var vkCmdSetDepthBoundsTestEnableEXT = &vkCommand{"vkCmdSetDepthBoundsTestEnableEXT", 2, true, nil}

// CmdSetDepthCompareOpEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthCompareOpEXT.html
func CmdSetDepthCompareOpEXT(commandBuffer CommandBuffer, depthCompareOp CompareOp) {

	if vkCmdSetDepthCompareOpEXT.fnHandle == nil {
		vkCmdSetDepthCompareOpEXT.fnHandle = dlHandle.NewProc("vkCmdSetDepthCompareOpEXT")
	}
	syscall.SyscallN(vkCmdSetDepthCompareOpEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(depthCompareOp))

}

var vkCmdSetDepthCompareOpEXT = &vkCommand{"vkCmdSetDepthCompareOpEXT", 2, true, nil}

// CmdSetDepthTestEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthTestEnableEXT.html
func CmdSetDepthTestEnableEXT(commandBuffer CommandBuffer, depthTestEnable bool) {
	depthTestEnable_Bool32 := translateInternal_Bool32(depthTestEnable)

	if vkCmdSetDepthTestEnableEXT.fnHandle == nil {
		vkCmdSetDepthTestEnableEXT.fnHandle = dlHandle.NewProc("vkCmdSetDepthTestEnableEXT")
	}
	syscall.SyscallN(vkCmdSetDepthTestEnableEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(depthTestEnable_Bool32))

}

var vkCmdSetDepthTestEnableEXT = &vkCommand{"vkCmdSetDepthTestEnableEXT", 2, true, nil}

// CmdSetDepthWriteEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthWriteEnableEXT.html
func CmdSetDepthWriteEnableEXT(commandBuffer CommandBuffer, depthWriteEnable bool) {
	depthWriteEnable_Bool32 := translateInternal_Bool32(depthWriteEnable)

	if vkCmdSetDepthWriteEnableEXT.fnHandle == nil {
		vkCmdSetDepthWriteEnableEXT.fnHandle = dlHandle.NewProc("vkCmdSetDepthWriteEnableEXT")
	}
	syscall.SyscallN(vkCmdSetDepthWriteEnableEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(depthWriteEnable_Bool32))

}

var vkCmdSetDepthWriteEnableEXT = &vkCommand{"vkCmdSetDepthWriteEnableEXT", 2, true, nil}

// CmdSetDeviceMask: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDeviceMask.html
func CmdSetDeviceMask(commandBuffer CommandBuffer, deviceMask uint32) {

	if vkCmdSetDeviceMask.fnHandle == nil {
		vkCmdSetDeviceMask.fnHandle = dlHandle.NewProc("vkCmdSetDeviceMask")
	}
	syscall.SyscallN(vkCmdSetDeviceMask.fnHandle.Addr(), uintptr(commandBuffer), uintptr(deviceMask))

}

var vkCmdSetDeviceMask = &vkCommand{"vkCmdSetDeviceMask", 2, true, nil}
var CmdSetDeviceMaskKHR = CmdSetDeviceMask

// CmdSetDiscardRectangleEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDiscardRectangleEXT.html
func CmdSetDiscardRectangleEXT(commandBuffer CommandBuffer, firstDiscardRectangle uint32, discardRectangles []Rect2D) {
	discardRectangleCount := len(discardRectangles)
	// discardRectangles is an input slice that requires translation to an internal type
	var pDiscardRectangles unsafe.Pointer
	if len(discardRectangles) > 0 {
		sl_discardRectangles := make([]_vkRect2D, discardRectangleCount)
		for i, v := range discardRectangles {
			sl_discardRectangles[i] = *(v.Vulkanize())
		}
		pDiscardRectangles = unsafe.Pointer(&sl_discardRectangles[0])
	}

	if vkCmdSetDiscardRectangleEXT.fnHandle == nil {
		vkCmdSetDiscardRectangleEXT.fnHandle = dlHandle.NewProc("vkCmdSetDiscardRectangleEXT")
	}
	syscall.SyscallN(vkCmdSetDiscardRectangleEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(firstDiscardRectangle), uintptr(discardRectangleCount), uintptr(unsafe.Pointer(pDiscardRectangles)))

}

var vkCmdSetDiscardRectangleEXT = &vkCommand{"vkCmdSetDiscardRectangleEXT", 4, true, nil}

// CmdSetEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent.html
func CmdSetEvent(commandBuffer CommandBuffer, event Event, stageMask PipelineStageFlags) {

	if vkCmdSetEvent.fnHandle == nil {
		vkCmdSetEvent.fnHandle = dlHandle.NewProc("vkCmdSetEvent")
	}
	syscall.SyscallN(vkCmdSetEvent.fnHandle.Addr(), uintptr(commandBuffer), uintptr(event), uintptr(stageMask))

}

var vkCmdSetEvent = &vkCommand{"vkCmdSetEvent", 3, true, nil}

// CmdSetEvent2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent2KHR.html
func CmdSetEvent2KHR(commandBuffer CommandBuffer, event Event, dependencyInfo *DependencyInfoKHR) {
	// Parameter is a singular input, requires translation - dependencyInfo
	var pDependencyInfo *_vkDependencyInfoKHR
	if dependencyInfo != nil {
		pDependencyInfo = dependencyInfo.Vulkanize()
	}

	if vkCmdSetEvent2KHR.fnHandle == nil {
		vkCmdSetEvent2KHR.fnHandle = dlHandle.NewProc("vkCmdSetEvent2KHR")
	}
	syscall.SyscallN(vkCmdSetEvent2KHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(event), uintptr(unsafe.Pointer(pDependencyInfo)))

}

var vkCmdSetEvent2KHR = &vkCommand{"vkCmdSetEvent2KHR", 3, true, nil}

// CmdSetExclusiveScissorNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetExclusiveScissorNV.html
func CmdSetExclusiveScissorNV(commandBuffer CommandBuffer, firstExclusiveScissor uint32, exclusiveScissors []Rect2D) {
	exclusiveScissorCount := len(exclusiveScissors)
	// exclusiveScissors is an input slice that requires translation to an internal type
	var pExclusiveScissors unsafe.Pointer
	if len(exclusiveScissors) > 0 {
		sl_exclusiveScissors := make([]_vkRect2D, exclusiveScissorCount)
		for i, v := range exclusiveScissors {
			sl_exclusiveScissors[i] = *(v.Vulkanize())
		}
		pExclusiveScissors = unsafe.Pointer(&sl_exclusiveScissors[0])
	}

	if vkCmdSetExclusiveScissorNV.fnHandle == nil {
		vkCmdSetExclusiveScissorNV.fnHandle = dlHandle.NewProc("vkCmdSetExclusiveScissorNV")
	}
	syscall.SyscallN(vkCmdSetExclusiveScissorNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(firstExclusiveScissor), uintptr(exclusiveScissorCount), uintptr(unsafe.Pointer(pExclusiveScissors)))

}

var vkCmdSetExclusiveScissorNV = &vkCommand{"vkCmdSetExclusiveScissorNV", 4, true, nil}

// CmdSetFragmentShadingRateEnumNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFragmentShadingRateEnumNV.html
func CmdSetFragmentShadingRateEnumNV(commandBuffer CommandBuffer, shadingRate FragmentShadingRateNV, combinerOps FragmentShadingRateCombinerOpKHR) {

	if vkCmdSetFragmentShadingRateEnumNV.fnHandle == nil {
		vkCmdSetFragmentShadingRateEnumNV.fnHandle = dlHandle.NewProc("vkCmdSetFragmentShadingRateEnumNV")
	}
	syscall.SyscallN(vkCmdSetFragmentShadingRateEnumNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(shadingRate), uintptr(combinerOps))

}

var vkCmdSetFragmentShadingRateEnumNV = &vkCommand{"vkCmdSetFragmentShadingRateEnumNV", 3, true, nil}

// CmdSetFragmentShadingRateKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFragmentShadingRateKHR.html
func CmdSetFragmentShadingRateKHR(commandBuffer CommandBuffer, fragmentSize *Extent2D, combinerOps FragmentShadingRateCombinerOpKHR) {
	// Parameter is a singular input, pass direct - fragmentSize
	var pFragmentSize unsafe.Pointer
	if fragmentSize != nil {
		pFragmentSize = unsafe.Pointer(fragmentSize)
	}

	if vkCmdSetFragmentShadingRateKHR.fnHandle == nil {
		vkCmdSetFragmentShadingRateKHR.fnHandle = dlHandle.NewProc("vkCmdSetFragmentShadingRateKHR")
	}
	syscall.SyscallN(vkCmdSetFragmentShadingRateKHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pFragmentSize)), uintptr(combinerOps))

}

var vkCmdSetFragmentShadingRateKHR = &vkCommand{"vkCmdSetFragmentShadingRateKHR", 3, true, nil}

// CmdSetFrontFaceEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFrontFaceEXT.html
func CmdSetFrontFaceEXT(commandBuffer CommandBuffer, frontFace FrontFace) {

	if vkCmdSetFrontFaceEXT.fnHandle == nil {
		vkCmdSetFrontFaceEXT.fnHandle = dlHandle.NewProc("vkCmdSetFrontFaceEXT")
	}
	syscall.SyscallN(vkCmdSetFrontFaceEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(frontFace))

}

var vkCmdSetFrontFaceEXT = &vkCommand{"vkCmdSetFrontFaceEXT", 2, true, nil}

// CmdSetLineStippleEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineStippleEXT.html
func CmdSetLineStippleEXT(commandBuffer CommandBuffer, lineStippleFactor uint32, lineStipplePattern uint16) {

	if vkCmdSetLineStippleEXT.fnHandle == nil {
		vkCmdSetLineStippleEXT.fnHandle = dlHandle.NewProc("vkCmdSetLineStippleEXT")
	}
	syscall.SyscallN(vkCmdSetLineStippleEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(lineStippleFactor), uintptr(lineStipplePattern))

}

var vkCmdSetLineStippleEXT = &vkCommand{"vkCmdSetLineStippleEXT", 3, true, nil}

// CmdSetLineWidth: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineWidth.html
func CmdSetLineWidth(commandBuffer CommandBuffer, lineWidth float32) {

	if vkCmdSetLineWidth.fnHandle == nil {
		vkCmdSetLineWidth.fnHandle = dlHandle.NewProc("vkCmdSetLineWidth")
	}
	syscall.SyscallN(vkCmdSetLineWidth.fnHandle.Addr(), uintptr(commandBuffer), uintptr(lineWidth))

}

var vkCmdSetLineWidth = &vkCommand{"vkCmdSetLineWidth", 2, true, nil}

// CmdSetLogicOpEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLogicOpEXT.html
func CmdSetLogicOpEXT(commandBuffer CommandBuffer, logicOp LogicOp) {

	if vkCmdSetLogicOpEXT.fnHandle == nil {
		vkCmdSetLogicOpEXT.fnHandle = dlHandle.NewProc("vkCmdSetLogicOpEXT")
	}
	syscall.SyscallN(vkCmdSetLogicOpEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(logicOp))

}

var vkCmdSetLogicOpEXT = &vkCommand{"vkCmdSetLogicOpEXT", 2, true, nil}

// CmdSetPatchControlPointsEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPatchControlPointsEXT.html
func CmdSetPatchControlPointsEXT(commandBuffer CommandBuffer, patchControlPoints uint32) {

	if vkCmdSetPatchControlPointsEXT.fnHandle == nil {
		vkCmdSetPatchControlPointsEXT.fnHandle = dlHandle.NewProc("vkCmdSetPatchControlPointsEXT")
	}
	syscall.SyscallN(vkCmdSetPatchControlPointsEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(patchControlPoints))

}

var vkCmdSetPatchControlPointsEXT = &vkCommand{"vkCmdSetPatchControlPointsEXT", 2, true, nil}

// CmdSetPerformanceMarkerINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPerformanceMarkerINTEL.html
func CmdSetPerformanceMarkerINTEL(commandBuffer CommandBuffer, markerInfo *PerformanceMarkerInfoINTEL) (r error) {
	// Parameter is a singular input, requires translation - markerInfo
	var pMarkerInfo *_vkPerformanceMarkerInfoINTEL
	if markerInfo != nil {
		pMarkerInfo = markerInfo.Vulkanize()
	}

	var rsys uintptr

	if vkCmdSetPerformanceMarkerINTEL.fnHandle == nil {
		vkCmdSetPerformanceMarkerINTEL.fnHandle = dlHandle.NewProc("vkCmdSetPerformanceMarkerINTEL")
	}
	rsys, _, _ = syscall.SyscallN(vkCmdSetPerformanceMarkerINTEL.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pMarkerInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCmdSetPerformanceMarkerINTEL = &vkCommand{"vkCmdSetPerformanceMarkerINTEL", 2, true, nil}

// CmdSetPerformanceOverrideINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPerformanceOverrideINTEL.html
func CmdSetPerformanceOverrideINTEL(commandBuffer CommandBuffer, overrideInfo *PerformanceOverrideInfoINTEL) (r error) {
	// Parameter is a singular input, requires translation - overrideInfo
	var pOverrideInfo *_vkPerformanceOverrideInfoINTEL
	if overrideInfo != nil {
		pOverrideInfo = overrideInfo.Vulkanize()
	}

	var rsys uintptr

	if vkCmdSetPerformanceOverrideINTEL.fnHandle == nil {
		vkCmdSetPerformanceOverrideINTEL.fnHandle = dlHandle.NewProc("vkCmdSetPerformanceOverrideINTEL")
	}
	rsys, _, _ = syscall.SyscallN(vkCmdSetPerformanceOverrideINTEL.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pOverrideInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCmdSetPerformanceOverrideINTEL = &vkCommand{"vkCmdSetPerformanceOverrideINTEL", 2, true, nil}

// CmdSetPerformanceStreamMarkerINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPerformanceStreamMarkerINTEL.html
func CmdSetPerformanceStreamMarkerINTEL(commandBuffer CommandBuffer, markerInfo *PerformanceStreamMarkerInfoINTEL) (r error) {
	// Parameter is a singular input, requires translation - markerInfo
	var pMarkerInfo *_vkPerformanceStreamMarkerInfoINTEL
	if markerInfo != nil {
		pMarkerInfo = markerInfo.Vulkanize()
	}

	var rsys uintptr

	if vkCmdSetPerformanceStreamMarkerINTEL.fnHandle == nil {
		vkCmdSetPerformanceStreamMarkerINTEL.fnHandle = dlHandle.NewProc("vkCmdSetPerformanceStreamMarkerINTEL")
	}
	rsys, _, _ = syscall.SyscallN(vkCmdSetPerformanceStreamMarkerINTEL.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pMarkerInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCmdSetPerformanceStreamMarkerINTEL = &vkCommand{"vkCmdSetPerformanceStreamMarkerINTEL", 2, true, nil}

// CmdSetPrimitiveRestartEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveRestartEnableEXT.html
func CmdSetPrimitiveRestartEnableEXT(commandBuffer CommandBuffer, primitiveRestartEnable bool) {
	primitiveRestartEnable_Bool32 := translateInternal_Bool32(primitiveRestartEnable)

	if vkCmdSetPrimitiveRestartEnableEXT.fnHandle == nil {
		vkCmdSetPrimitiveRestartEnableEXT.fnHandle = dlHandle.NewProc("vkCmdSetPrimitiveRestartEnableEXT")
	}
	syscall.SyscallN(vkCmdSetPrimitiveRestartEnableEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(primitiveRestartEnable_Bool32))

}

var vkCmdSetPrimitiveRestartEnableEXT = &vkCommand{"vkCmdSetPrimitiveRestartEnableEXT", 2, true, nil}

// CmdSetPrimitiveTopologyEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveTopologyEXT.html
func CmdSetPrimitiveTopologyEXT(commandBuffer CommandBuffer, primitiveTopology PrimitiveTopology) {

	if vkCmdSetPrimitiveTopologyEXT.fnHandle == nil {
		vkCmdSetPrimitiveTopologyEXT.fnHandle = dlHandle.NewProc("vkCmdSetPrimitiveTopologyEXT")
	}
	syscall.SyscallN(vkCmdSetPrimitiveTopologyEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(primitiveTopology))

}

var vkCmdSetPrimitiveTopologyEXT = &vkCommand{"vkCmdSetPrimitiveTopologyEXT", 2, true, nil}

// CmdSetRasterizerDiscardEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizerDiscardEnableEXT.html
func CmdSetRasterizerDiscardEnableEXT(commandBuffer CommandBuffer, rasterizerDiscardEnable bool) {
	rasterizerDiscardEnable_Bool32 := translateInternal_Bool32(rasterizerDiscardEnable)

	if vkCmdSetRasterizerDiscardEnableEXT.fnHandle == nil {
		vkCmdSetRasterizerDiscardEnableEXT.fnHandle = dlHandle.NewProc("vkCmdSetRasterizerDiscardEnableEXT")
	}
	syscall.SyscallN(vkCmdSetRasterizerDiscardEnableEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(rasterizerDiscardEnable_Bool32))

}

var vkCmdSetRasterizerDiscardEnableEXT = &vkCommand{"vkCmdSetRasterizerDiscardEnableEXT", 2, true, nil}

// CmdSetRayTracingPipelineStackSizeKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRayTracingPipelineStackSizeKHR.html
func CmdSetRayTracingPipelineStackSizeKHR(commandBuffer CommandBuffer, pipelineStackSize uint32) {

	if vkCmdSetRayTracingPipelineStackSizeKHR.fnHandle == nil {
		vkCmdSetRayTracingPipelineStackSizeKHR.fnHandle = dlHandle.NewProc("vkCmdSetRayTracingPipelineStackSizeKHR")
	}
	syscall.SyscallN(vkCmdSetRayTracingPipelineStackSizeKHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(pipelineStackSize))

}

var vkCmdSetRayTracingPipelineStackSizeKHR = &vkCommand{"vkCmdSetRayTracingPipelineStackSizeKHR", 2, true, nil}

// CmdSetSampleLocationsEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetSampleLocationsEXT.html
func CmdSetSampleLocationsEXT(commandBuffer CommandBuffer, sampleLocationsInfo *SampleLocationsInfoEXT) {
	// Parameter is a singular input, requires translation - sampleLocationsInfo
	var pSampleLocationsInfo *_vkSampleLocationsInfoEXT
	if sampleLocationsInfo != nil {
		pSampleLocationsInfo = sampleLocationsInfo.Vulkanize()
	}

	if vkCmdSetSampleLocationsEXT.fnHandle == nil {
		vkCmdSetSampleLocationsEXT.fnHandle = dlHandle.NewProc("vkCmdSetSampleLocationsEXT")
	}
	syscall.SyscallN(vkCmdSetSampleLocationsEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pSampleLocationsInfo)))

}

var vkCmdSetSampleLocationsEXT = &vkCommand{"vkCmdSetSampleLocationsEXT", 2, true, nil}

// CmdSetScissor: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissor.html
func CmdSetScissor(commandBuffer CommandBuffer, firstScissor uint32, scissors []Rect2D) {
	scissorCount := len(scissors)
	// scissors is an input slice that requires translation to an internal type
	var pScissors unsafe.Pointer
	if len(scissors) > 0 {
		sl_scissors := make([]_vkRect2D, scissorCount)
		for i, v := range scissors {
			sl_scissors[i] = *(v.Vulkanize())
		}
		pScissors = unsafe.Pointer(&sl_scissors[0])
	}

	if vkCmdSetScissor.fnHandle == nil {
		vkCmdSetScissor.fnHandle = dlHandle.NewProc("vkCmdSetScissor")
	}
	syscall.SyscallN(vkCmdSetScissor.fnHandle.Addr(), uintptr(commandBuffer), uintptr(firstScissor), uintptr(scissorCount), uintptr(unsafe.Pointer(pScissors)))

}

var vkCmdSetScissor = &vkCommand{"vkCmdSetScissor", 4, true, nil}

// CmdSetScissorWithCountEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissorWithCountEXT.html
func CmdSetScissorWithCountEXT(commandBuffer CommandBuffer, scissors []Rect2D) {
	scissorCount := len(scissors)
	// scissors is an input slice that requires translation to an internal type
	var pScissors unsafe.Pointer
	if len(scissors) > 0 {
		sl_scissors := make([]_vkRect2D, scissorCount)
		for i, v := range scissors {
			sl_scissors[i] = *(v.Vulkanize())
		}
		pScissors = unsafe.Pointer(&sl_scissors[0])
	}

	if vkCmdSetScissorWithCountEXT.fnHandle == nil {
		vkCmdSetScissorWithCountEXT.fnHandle = dlHandle.NewProc("vkCmdSetScissorWithCountEXT")
	}
	syscall.SyscallN(vkCmdSetScissorWithCountEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(scissorCount), uintptr(unsafe.Pointer(pScissors)))

}

var vkCmdSetScissorWithCountEXT = &vkCommand{"vkCmdSetScissorWithCountEXT", 3, true, nil}

// CmdSetStencilCompareMask: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilCompareMask.html
func CmdSetStencilCompareMask(commandBuffer CommandBuffer, faceMask StencilFaceFlags, compareMask uint32) {

	if vkCmdSetStencilCompareMask.fnHandle == nil {
		vkCmdSetStencilCompareMask.fnHandle = dlHandle.NewProc("vkCmdSetStencilCompareMask")
	}
	syscall.SyscallN(vkCmdSetStencilCompareMask.fnHandle.Addr(), uintptr(commandBuffer), uintptr(faceMask), uintptr(compareMask))

}

var vkCmdSetStencilCompareMask = &vkCommand{"vkCmdSetStencilCompareMask", 3, true, nil}

// CmdSetStencilOpEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilOpEXT.html
func CmdSetStencilOpEXT(commandBuffer CommandBuffer, faceMask StencilFaceFlags, failOp StencilOp, passOp StencilOp, depthFailOp StencilOp, compareOp CompareOp) {

	if vkCmdSetStencilOpEXT.fnHandle == nil {
		vkCmdSetStencilOpEXT.fnHandle = dlHandle.NewProc("vkCmdSetStencilOpEXT")
	}
	syscall.SyscallN(vkCmdSetStencilOpEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(faceMask), uintptr(failOp), uintptr(passOp), uintptr(depthFailOp), uintptr(compareOp))

}

var vkCmdSetStencilOpEXT = &vkCommand{"vkCmdSetStencilOpEXT", 6, true, nil}

// CmdSetStencilReference: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilReference.html
func CmdSetStencilReference(commandBuffer CommandBuffer, faceMask StencilFaceFlags, reference uint32) {

	if vkCmdSetStencilReference.fnHandle == nil {
		vkCmdSetStencilReference.fnHandle = dlHandle.NewProc("vkCmdSetStencilReference")
	}
	syscall.SyscallN(vkCmdSetStencilReference.fnHandle.Addr(), uintptr(commandBuffer), uintptr(faceMask), uintptr(reference))

}

var vkCmdSetStencilReference = &vkCommand{"vkCmdSetStencilReference", 3, true, nil}

// CmdSetStencilTestEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilTestEnableEXT.html
func CmdSetStencilTestEnableEXT(commandBuffer CommandBuffer, stencilTestEnable bool) {
	stencilTestEnable_Bool32 := translateInternal_Bool32(stencilTestEnable)

	if vkCmdSetStencilTestEnableEXT.fnHandle == nil {
		vkCmdSetStencilTestEnableEXT.fnHandle = dlHandle.NewProc("vkCmdSetStencilTestEnableEXT")
	}
	syscall.SyscallN(vkCmdSetStencilTestEnableEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(stencilTestEnable_Bool32))

}

var vkCmdSetStencilTestEnableEXT = &vkCommand{"vkCmdSetStencilTestEnableEXT", 2, true, nil}

// CmdSetStencilWriteMask: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilWriteMask.html
func CmdSetStencilWriteMask(commandBuffer CommandBuffer, faceMask StencilFaceFlags, writeMask uint32) {

	if vkCmdSetStencilWriteMask.fnHandle == nil {
		vkCmdSetStencilWriteMask.fnHandle = dlHandle.NewProc("vkCmdSetStencilWriteMask")
	}
	syscall.SyscallN(vkCmdSetStencilWriteMask.fnHandle.Addr(), uintptr(commandBuffer), uintptr(faceMask), uintptr(writeMask))

}

var vkCmdSetStencilWriteMask = &vkCommand{"vkCmdSetStencilWriteMask", 3, true, nil}

// CmdSetVertexInputEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetVertexInputEXT.html
func CmdSetVertexInputEXT(commandBuffer CommandBuffer, vertexBindingDescriptions []VertexInputBindingDescription2EXT, vertexAttributeDescriptions []VertexInputAttributeDescription2EXT) {
	vertexBindingDescriptionCount := len(vertexBindingDescriptions)
	// vertexBindingDescriptions is an input slice that requires translation to an internal type
	var pVertexBindingDescriptions unsafe.Pointer
	if len(vertexBindingDescriptions) > 0 {
		sl_vertexBindingDescriptions := make([]_vkVertexInputBindingDescription2EXT, vertexBindingDescriptionCount)
		for i, v := range vertexBindingDescriptions {
			sl_vertexBindingDescriptions[i] = *(v.Vulkanize())
		}
		pVertexBindingDescriptions = unsafe.Pointer(&sl_vertexBindingDescriptions[0])
	}

	vertexAttributeDescriptionCount := len(vertexAttributeDescriptions)
	// vertexAttributeDescriptions is an input slice that requires translation to an internal type
	var pVertexAttributeDescriptions unsafe.Pointer
	if len(vertexAttributeDescriptions) > 0 {
		sl_vertexAttributeDescriptions := make([]_vkVertexInputAttributeDescription2EXT, vertexAttributeDescriptionCount)
		for i, v := range vertexAttributeDescriptions {
			sl_vertexAttributeDescriptions[i] = *(v.Vulkanize())
		}
		pVertexAttributeDescriptions = unsafe.Pointer(&sl_vertexAttributeDescriptions[0])
	}

	if vkCmdSetVertexInputEXT.fnHandle == nil {
		vkCmdSetVertexInputEXT.fnHandle = dlHandle.NewProc("vkCmdSetVertexInputEXT")
	}
	syscall.SyscallN(vkCmdSetVertexInputEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(vertexBindingDescriptionCount), uintptr(unsafe.Pointer(pVertexBindingDescriptions)), uintptr(vertexAttributeDescriptionCount), uintptr(unsafe.Pointer(pVertexAttributeDescriptions)))

}

var vkCmdSetVertexInputEXT = &vkCommand{"vkCmdSetVertexInputEXT", 5, true, nil}

// CmdSetViewport: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewport.html
func CmdSetViewport(commandBuffer CommandBuffer, firstViewport uint32, viewports []Viewport) {
	viewportCount := len(viewports)
	// viewports is an input slice of values that do not need translation used
	var pViewports unsafe.Pointer
	if viewports != nil {
		pViewports = unsafe.Pointer(&viewports[0])
	}

	if vkCmdSetViewport.fnHandle == nil {
		vkCmdSetViewport.fnHandle = dlHandle.NewProc("vkCmdSetViewport")
	}
	syscall.SyscallN(vkCmdSetViewport.fnHandle.Addr(), uintptr(commandBuffer), uintptr(firstViewport), uintptr(viewportCount), uintptr(unsafe.Pointer(pViewports)))

}

var vkCmdSetViewport = &vkCommand{"vkCmdSetViewport", 4, true, nil}

// CmdSetViewportShadingRatePaletteNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportShadingRatePaletteNV.html
func CmdSetViewportShadingRatePaletteNV(commandBuffer CommandBuffer, firstViewport uint32, shadingRatePalettes []ShadingRatePaletteNV) {
	viewportCount := len(shadingRatePalettes)
	// shadingRatePalettes is an input slice that requires translation to an internal type
	var pShadingRatePalettes unsafe.Pointer
	if len(shadingRatePalettes) > 0 {
		sl_shadingRatePalettes := make([]_vkShadingRatePaletteNV, viewportCount)
		for i, v := range shadingRatePalettes {
			sl_shadingRatePalettes[i] = *(v.Vulkanize())
		}
		pShadingRatePalettes = unsafe.Pointer(&sl_shadingRatePalettes[0])
	}

	if vkCmdSetViewportShadingRatePaletteNV.fnHandle == nil {
		vkCmdSetViewportShadingRatePaletteNV.fnHandle = dlHandle.NewProc("vkCmdSetViewportShadingRatePaletteNV")
	}
	syscall.SyscallN(vkCmdSetViewportShadingRatePaletteNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(firstViewport), uintptr(viewportCount), uintptr(unsafe.Pointer(pShadingRatePalettes)))

}

var vkCmdSetViewportShadingRatePaletteNV = &vkCommand{"vkCmdSetViewportShadingRatePaletteNV", 4, true, nil}

// CmdSetViewportWScalingNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWScalingNV.html
func CmdSetViewportWScalingNV(commandBuffer CommandBuffer, firstViewport uint32, viewportWScalings []ViewportWScalingNV) {
	viewportCount := len(viewportWScalings)
	// viewportWScalings is an input slice of values that do not need translation used
	var pViewportWScalings unsafe.Pointer
	if viewportWScalings != nil {
		pViewportWScalings = unsafe.Pointer(&viewportWScalings[0])
	}

	if vkCmdSetViewportWScalingNV.fnHandle == nil {
		vkCmdSetViewportWScalingNV.fnHandle = dlHandle.NewProc("vkCmdSetViewportWScalingNV")
	}
	syscall.SyscallN(vkCmdSetViewportWScalingNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(firstViewport), uintptr(viewportCount), uintptr(unsafe.Pointer(pViewportWScalings)))

}

var vkCmdSetViewportWScalingNV = &vkCommand{"vkCmdSetViewportWScalingNV", 4, true, nil}

// CmdSetViewportWithCountEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWithCountEXT.html
func CmdSetViewportWithCountEXT(commandBuffer CommandBuffer, viewports []Viewport) {
	viewportCount := len(viewports)
	// viewports is an input slice of values that do not need translation used
	var pViewports unsafe.Pointer
	if viewports != nil {
		pViewports = unsafe.Pointer(&viewports[0])
	}

	if vkCmdSetViewportWithCountEXT.fnHandle == nil {
		vkCmdSetViewportWithCountEXT.fnHandle = dlHandle.NewProc("vkCmdSetViewportWithCountEXT")
	}
	syscall.SyscallN(vkCmdSetViewportWithCountEXT.fnHandle.Addr(), uintptr(commandBuffer), uintptr(viewportCount), uintptr(unsafe.Pointer(pViewports)))

}

var vkCmdSetViewportWithCountEXT = &vkCommand{"vkCmdSetViewportWithCountEXT", 3, true, nil}

// CmdSubpassShadingHUAWEI: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSubpassShadingHUAWEI.html
func CmdSubpassShadingHUAWEI(commandBuffer CommandBuffer) {

	if vkCmdSubpassShadingHUAWEI.fnHandle == nil {
		vkCmdSubpassShadingHUAWEI.fnHandle = dlHandle.NewProc("vkCmdSubpassShadingHUAWEI")
	}
	syscall.SyscallN(vkCmdSubpassShadingHUAWEI.fnHandle.Addr(), uintptr(commandBuffer))

}

var vkCmdSubpassShadingHUAWEI = &vkCommand{"vkCmdSubpassShadingHUAWEI", 1, true, nil}

// CmdTraceRaysIndirectKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysIndirectKHR.html
func CmdTraceRaysIndirectKHR(commandBuffer CommandBuffer, raygenShaderBindingTable *StridedDeviceAddressRegionKHR, missShaderBindingTable *StridedDeviceAddressRegionKHR, hitShaderBindingTable *StridedDeviceAddressRegionKHR, callableShaderBindingTable *StridedDeviceAddressRegionKHR, indirectDeviceAddress DeviceAddress) {
	// Parameter is a singular input, pass direct - raygenShaderBindingTable
	var pRaygenShaderBindingTable unsafe.Pointer
	if raygenShaderBindingTable != nil {
		pRaygenShaderBindingTable = unsafe.Pointer(raygenShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - missShaderBindingTable
	var pMissShaderBindingTable unsafe.Pointer
	if missShaderBindingTable != nil {
		pMissShaderBindingTable = unsafe.Pointer(missShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - hitShaderBindingTable
	var pHitShaderBindingTable unsafe.Pointer
	if hitShaderBindingTable != nil {
		pHitShaderBindingTable = unsafe.Pointer(hitShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - callableShaderBindingTable
	var pCallableShaderBindingTable unsafe.Pointer
	if callableShaderBindingTable != nil {
		pCallableShaderBindingTable = unsafe.Pointer(callableShaderBindingTable)
	}

	if vkCmdTraceRaysIndirectKHR.fnHandle == nil {
		vkCmdTraceRaysIndirectKHR.fnHandle = dlHandle.NewProc("vkCmdTraceRaysIndirectKHR")
	}
	syscall.SyscallN(vkCmdTraceRaysIndirectKHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pRaygenShaderBindingTable)), uintptr(unsafe.Pointer(pMissShaderBindingTable)), uintptr(unsafe.Pointer(pHitShaderBindingTable)), uintptr(unsafe.Pointer(pCallableShaderBindingTable)), uintptr(indirectDeviceAddress))

}

var vkCmdTraceRaysIndirectKHR = &vkCommand{"vkCmdTraceRaysIndirectKHR", 6, true, nil}

// CmdTraceRaysKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysKHR.html
func CmdTraceRaysKHR(commandBuffer CommandBuffer, raygenShaderBindingTable *StridedDeviceAddressRegionKHR, missShaderBindingTable *StridedDeviceAddressRegionKHR, hitShaderBindingTable *StridedDeviceAddressRegionKHR, callableShaderBindingTable *StridedDeviceAddressRegionKHR, width uint32, height uint32, depth uint32) {
	// Parameter is a singular input, pass direct - raygenShaderBindingTable
	var pRaygenShaderBindingTable unsafe.Pointer
	if raygenShaderBindingTable != nil {
		pRaygenShaderBindingTable = unsafe.Pointer(raygenShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - missShaderBindingTable
	var pMissShaderBindingTable unsafe.Pointer
	if missShaderBindingTable != nil {
		pMissShaderBindingTable = unsafe.Pointer(missShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - hitShaderBindingTable
	var pHitShaderBindingTable unsafe.Pointer
	if hitShaderBindingTable != nil {
		pHitShaderBindingTable = unsafe.Pointer(hitShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - callableShaderBindingTable
	var pCallableShaderBindingTable unsafe.Pointer
	if callableShaderBindingTable != nil {
		pCallableShaderBindingTable = unsafe.Pointer(callableShaderBindingTable)
	}

	if vkCmdTraceRaysKHR.fnHandle == nil {
		vkCmdTraceRaysKHR.fnHandle = dlHandle.NewProc("vkCmdTraceRaysKHR")
	}
	syscall.SyscallN(vkCmdTraceRaysKHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(unsafe.Pointer(pRaygenShaderBindingTable)), uintptr(unsafe.Pointer(pMissShaderBindingTable)), uintptr(unsafe.Pointer(pHitShaderBindingTable)), uintptr(unsafe.Pointer(pCallableShaderBindingTable)), uintptr(width), uintptr(height), uintptr(depth))

}

var vkCmdTraceRaysKHR = &vkCommand{"vkCmdTraceRaysKHR", 8, true, nil}

// CmdTraceRaysNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysNV.html
func CmdTraceRaysNV(commandBuffer CommandBuffer, raygenShaderBindingTableBuffer Buffer, raygenShaderBindingOffset DeviceSize, missShaderBindingTableBuffer Buffer, missShaderBindingOffset DeviceSize, missShaderBindingStride DeviceSize, hitShaderBindingTableBuffer Buffer, hitShaderBindingOffset DeviceSize, hitShaderBindingStride DeviceSize, callableShaderBindingTableBuffer Buffer, callableShaderBindingOffset DeviceSize, callableShaderBindingStride DeviceSize, width uint32, height uint32, depth uint32) {

	if vkCmdTraceRaysNV.fnHandle == nil {
		vkCmdTraceRaysNV.fnHandle = dlHandle.NewProc("vkCmdTraceRaysNV")
	}
	syscall.SyscallN(vkCmdTraceRaysNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(raygenShaderBindingTableBuffer), uintptr(raygenShaderBindingOffset), uintptr(missShaderBindingTableBuffer), uintptr(missShaderBindingOffset), uintptr(missShaderBindingStride), uintptr(hitShaderBindingTableBuffer), uintptr(hitShaderBindingOffset), uintptr(hitShaderBindingStride), uintptr(callableShaderBindingTableBuffer), uintptr(callableShaderBindingOffset), uintptr(callableShaderBindingStride), uintptr(width), uintptr(height), uintptr(depth))

}

var vkCmdTraceRaysNV = &vkCommand{"vkCmdTraceRaysNV", 15, true, nil}

// CmdUpdateBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdUpdateBuffer.html
func CmdUpdateBuffer(commandBuffer CommandBuffer, dstBuffer Buffer, dstOffset DeviceSize, data []byte) {
	dataSize := len(data)
	// data is an input slice of values that do not need translation used
	var pData unsafe.Pointer
	if data != nil {
		pData = unsafe.Pointer(&data[0])
	}

	if vkCmdUpdateBuffer.fnHandle == nil {
		vkCmdUpdateBuffer.fnHandle = dlHandle.NewProc("vkCmdUpdateBuffer")
	}
	syscall.SyscallN(vkCmdUpdateBuffer.fnHandle.Addr(), uintptr(commandBuffer), uintptr(dstBuffer), uintptr(dstOffset), uintptr(dataSize), uintptr(unsafe.Pointer(pData)))

}

var vkCmdUpdateBuffer = &vkCommand{"vkCmdUpdateBuffer", 5, true, nil}

// CmdWaitEvents: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents.html
func CmdWaitEvents(commandBuffer CommandBuffer, events []Event, srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, memoryBarriers []MemoryBarrier, bufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarriers []ImageMemoryBarrier) {
	eventCount := len(events)
	// events is an input slice of values that do not need translation used
	var pEvents unsafe.Pointer
	if events != nil {
		pEvents = unsafe.Pointer(&events[0])
	}

	memoryBarrierCount := len(memoryBarriers)
	// memoryBarriers is an input slice that requires translation to an internal type
	var pMemoryBarriers unsafe.Pointer
	if len(memoryBarriers) > 0 {
		sl_memoryBarriers := make([]_vkMemoryBarrier, memoryBarrierCount)
		for i, v := range memoryBarriers {
			sl_memoryBarriers[i] = *(v.Vulkanize())
		}
		pMemoryBarriers = unsafe.Pointer(&sl_memoryBarriers[0])
	}

	bufferMemoryBarrierCount := len(bufferMemoryBarriers)
	// bufferMemoryBarriers is an input slice that requires translation to an internal type
	var pBufferMemoryBarriers unsafe.Pointer
	if len(bufferMemoryBarriers) > 0 {
		sl_bufferMemoryBarriers := make([]_vkBufferMemoryBarrier, bufferMemoryBarrierCount)
		for i, v := range bufferMemoryBarriers {
			sl_bufferMemoryBarriers[i] = *(v.Vulkanize())
		}
		pBufferMemoryBarriers = unsafe.Pointer(&sl_bufferMemoryBarriers[0])
	}

	imageMemoryBarrierCount := len(imageMemoryBarriers)
	// imageMemoryBarriers is an input slice that requires translation to an internal type
	var pImageMemoryBarriers unsafe.Pointer
	if len(imageMemoryBarriers) > 0 {
		sl_imageMemoryBarriers := make([]_vkImageMemoryBarrier, imageMemoryBarrierCount)
		for i, v := range imageMemoryBarriers {
			sl_imageMemoryBarriers[i] = *(v.Vulkanize())
		}
		pImageMemoryBarriers = unsafe.Pointer(&sl_imageMemoryBarriers[0])
	}

	if vkCmdWaitEvents.fnHandle == nil {
		vkCmdWaitEvents.fnHandle = dlHandle.NewProc("vkCmdWaitEvents")
	}
	syscall.SyscallN(vkCmdWaitEvents.fnHandle.Addr(), uintptr(commandBuffer), uintptr(eventCount), uintptr(unsafe.Pointer(pEvents)), uintptr(srcStageMask), uintptr(dstStageMask), uintptr(memoryBarrierCount), uintptr(unsafe.Pointer(pMemoryBarriers)), uintptr(bufferMemoryBarrierCount), uintptr(unsafe.Pointer(pBufferMemoryBarriers)), uintptr(imageMemoryBarrierCount), uintptr(unsafe.Pointer(pImageMemoryBarriers)))

}

var vkCmdWaitEvents = &vkCommand{"vkCmdWaitEvents", 11, true, nil}

// CmdWaitEvents2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents2KHR.html
func CmdWaitEvents2KHR(commandBuffer CommandBuffer, events []Event, dependencyInfos []DependencyInfoKHR) {
	eventCount := len(events)
	// events is an input slice of values that do not need translation used
	var pEvents unsafe.Pointer
	if events != nil {
		pEvents = unsafe.Pointer(&events[0])
	}

	// dependencyInfos is an input slice that requires translation to an internal type
	var pDependencyInfos unsafe.Pointer
	if len(dependencyInfos) > 0 {
		sl_dependencyInfos := make([]_vkDependencyInfoKHR, eventCount)
		for i, v := range dependencyInfos {
			sl_dependencyInfos[i] = *(v.Vulkanize())
		}
		pDependencyInfos = unsafe.Pointer(&sl_dependencyInfos[0])
	}

	if vkCmdWaitEvents2KHR.fnHandle == nil {
		vkCmdWaitEvents2KHR.fnHandle = dlHandle.NewProc("vkCmdWaitEvents2KHR")
	}
	syscall.SyscallN(vkCmdWaitEvents2KHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(eventCount), uintptr(unsafe.Pointer(pEvents)), uintptr(unsafe.Pointer(pDependencyInfos)))

}

var vkCmdWaitEvents2KHR = &vkCommand{"vkCmdWaitEvents2KHR", 4, true, nil}

// CmdWriteAccelerationStructuresPropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteAccelerationStructuresPropertiesKHR.html
func CmdWriteAccelerationStructuresPropertiesKHR(commandBuffer CommandBuffer, accelerationStructures []AccelerationStructureKHR, queryType QueryType, queryPool QueryPool, firstQuery uint32) {
	accelerationStructureCount := len(accelerationStructures)
	// accelerationStructures is an input slice of values that do not need translation used
	var pAccelerationStructures unsafe.Pointer
	if accelerationStructures != nil {
		pAccelerationStructures = unsafe.Pointer(&accelerationStructures[0])
	}

	if vkCmdWriteAccelerationStructuresPropertiesKHR.fnHandle == nil {
		vkCmdWriteAccelerationStructuresPropertiesKHR.fnHandle = dlHandle.NewProc("vkCmdWriteAccelerationStructuresPropertiesKHR")
	}
	syscall.SyscallN(vkCmdWriteAccelerationStructuresPropertiesKHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(accelerationStructureCount), uintptr(unsafe.Pointer(pAccelerationStructures)), uintptr(queryType), uintptr(queryPool), uintptr(firstQuery))

}

var vkCmdWriteAccelerationStructuresPropertiesKHR = &vkCommand{"vkCmdWriteAccelerationStructuresPropertiesKHR", 6, true, nil}

// CmdWriteAccelerationStructuresPropertiesNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteAccelerationStructuresPropertiesNV.html
func CmdWriteAccelerationStructuresPropertiesNV(commandBuffer CommandBuffer, accelerationStructures []AccelerationStructureNV, queryType QueryType, queryPool QueryPool, firstQuery uint32) {
	accelerationStructureCount := len(accelerationStructures)
	// accelerationStructures is an input slice of values that do not need translation used
	var pAccelerationStructures unsafe.Pointer
	if accelerationStructures != nil {
		pAccelerationStructures = unsafe.Pointer(&accelerationStructures[0])
	}

	if vkCmdWriteAccelerationStructuresPropertiesNV.fnHandle == nil {
		vkCmdWriteAccelerationStructuresPropertiesNV.fnHandle = dlHandle.NewProc("vkCmdWriteAccelerationStructuresPropertiesNV")
	}
	syscall.SyscallN(vkCmdWriteAccelerationStructuresPropertiesNV.fnHandle.Addr(), uintptr(commandBuffer), uintptr(accelerationStructureCount), uintptr(unsafe.Pointer(pAccelerationStructures)), uintptr(queryType), uintptr(queryPool), uintptr(firstQuery))

}

var vkCmdWriteAccelerationStructuresPropertiesNV = &vkCommand{"vkCmdWriteAccelerationStructuresPropertiesNV", 6, true, nil}

// CmdWriteBufferMarker2AMD: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteBufferMarker2AMD.html
func CmdWriteBufferMarker2AMD(commandBuffer CommandBuffer, stage PipelineStageFlags2KHR, dstBuffer Buffer, dstOffset DeviceSize, marker uint32) {

	if vkCmdWriteBufferMarker2AMD.fnHandle == nil {
		vkCmdWriteBufferMarker2AMD.fnHandle = dlHandle.NewProc("vkCmdWriteBufferMarker2AMD")
	}
	syscall.SyscallN(vkCmdWriteBufferMarker2AMD.fnHandle.Addr(), uintptr(commandBuffer), uintptr(stage), uintptr(dstBuffer), uintptr(dstOffset), uintptr(marker))

}

var vkCmdWriteBufferMarker2AMD = &vkCommand{"vkCmdWriteBufferMarker2AMD", 5, true, nil}

// CmdWriteBufferMarkerAMD: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteBufferMarkerAMD.html
func CmdWriteBufferMarkerAMD(commandBuffer CommandBuffer, pipelineStage PipelineStageFlagBits, dstBuffer Buffer, dstOffset DeviceSize, marker uint32) {

	if vkCmdWriteBufferMarkerAMD.fnHandle == nil {
		vkCmdWriteBufferMarkerAMD.fnHandle = dlHandle.NewProc("vkCmdWriteBufferMarkerAMD")
	}
	syscall.SyscallN(vkCmdWriteBufferMarkerAMD.fnHandle.Addr(), uintptr(commandBuffer), uintptr(pipelineStage), uintptr(dstBuffer), uintptr(dstOffset), uintptr(marker))

}

var vkCmdWriteBufferMarkerAMD = &vkCommand{"vkCmdWriteBufferMarkerAMD", 5, true, nil}

// CmdWriteTimestamp: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp.html
func CmdWriteTimestamp(commandBuffer CommandBuffer, pipelineStage PipelineStageFlagBits, queryPool QueryPool, query uint32) {

	if vkCmdWriteTimestamp.fnHandle == nil {
		vkCmdWriteTimestamp.fnHandle = dlHandle.NewProc("vkCmdWriteTimestamp")
	}
	syscall.SyscallN(vkCmdWriteTimestamp.fnHandle.Addr(), uintptr(commandBuffer), uintptr(pipelineStage), uintptr(queryPool), uintptr(query))

}

var vkCmdWriteTimestamp = &vkCommand{"vkCmdWriteTimestamp", 4, true, nil}

// CmdWriteTimestamp2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp2KHR.html
func CmdWriteTimestamp2KHR(commandBuffer CommandBuffer, stage PipelineStageFlags2KHR, queryPool QueryPool, query uint32) {

	if vkCmdWriteTimestamp2KHR.fnHandle == nil {
		vkCmdWriteTimestamp2KHR.fnHandle = dlHandle.NewProc("vkCmdWriteTimestamp2KHR")
	}
	syscall.SyscallN(vkCmdWriteTimestamp2KHR.fnHandle.Addr(), uintptr(commandBuffer), uintptr(stage), uintptr(queryPool), uintptr(query))

}

var vkCmdWriteTimestamp2KHR = &vkCommand{"vkCmdWriteTimestamp2KHR", 4, true, nil}

// CompileDeferredNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCompileDeferredNV.html
func CompileDeferredNV(device Device, pipeline Pipeline, shader uint32) (r error) {
	var rsys uintptr

	if vkCompileDeferredNV.fnHandle == nil {
		vkCompileDeferredNV.fnHandle = dlHandle.NewProc("vkCompileDeferredNV")
	}
	rsys, _, _ = syscall.SyscallN(vkCompileDeferredNV.fnHandle.Addr(), uintptr(device), uintptr(pipeline), uintptr(shader))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCompileDeferredNV = &vkCommand{"vkCompileDeferredNV", 3, true, nil}

// CopyAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyAccelerationStructureKHR.html
func CopyAccelerationStructureKHR(device Device, deferredOperation DeferredOperationKHR, info *CopyAccelerationStructureInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyAccelerationStructureInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	var rsys uintptr

	if vkCopyAccelerationStructureKHR.fnHandle == nil {
		vkCopyAccelerationStructureKHR.fnHandle = dlHandle.NewProc("vkCopyAccelerationStructureKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkCopyAccelerationStructureKHR.fnHandle.Addr(), uintptr(device), uintptr(deferredOperation), uintptr(unsafe.Pointer(pInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCopyAccelerationStructureKHR = &vkCommand{"vkCopyAccelerationStructureKHR", 3, true, nil}

// CopyAccelerationStructureToMemoryKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyAccelerationStructureToMemoryKHR.html
func CopyAccelerationStructureToMemoryKHR(device Device, deferredOperation DeferredOperationKHR, info *CopyAccelerationStructureToMemoryInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyAccelerationStructureToMemoryInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	var rsys uintptr

	if vkCopyAccelerationStructureToMemoryKHR.fnHandle == nil {
		vkCopyAccelerationStructureToMemoryKHR.fnHandle = dlHandle.NewProc("vkCopyAccelerationStructureToMemoryKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkCopyAccelerationStructureToMemoryKHR.fnHandle.Addr(), uintptr(device), uintptr(deferredOperation), uintptr(unsafe.Pointer(pInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCopyAccelerationStructureToMemoryKHR = &vkCommand{"vkCopyAccelerationStructureToMemoryKHR", 3, true, nil}

// CopyMemoryToAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyMemoryToAccelerationStructureKHR.html
func CopyMemoryToAccelerationStructureKHR(device Device, deferredOperation DeferredOperationKHR, info *CopyMemoryToAccelerationStructureInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMemoryToAccelerationStructureInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	var rsys uintptr

	if vkCopyMemoryToAccelerationStructureKHR.fnHandle == nil {
		vkCopyMemoryToAccelerationStructureKHR.fnHandle = dlHandle.NewProc("vkCopyMemoryToAccelerationStructureKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkCopyMemoryToAccelerationStructureKHR.fnHandle.Addr(), uintptr(device), uintptr(deferredOperation), uintptr(unsafe.Pointer(pInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCopyMemoryToAccelerationStructureKHR = &vkCommand{"vkCopyMemoryToAccelerationStructureKHR", 3, true, nil}

// CreateAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateAccelerationStructureKHR.html
func CreateAccelerationStructureKHR(device Device, createInfo *AccelerationStructureCreateInfoKHR, allocator *AllocationCallbacks) (accelerationStructure AccelerationStructureKHR, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkAccelerationStructureCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// accelerationStructure is a binding-allocated single return value and will be populated by Vulkan
	ptr_pAccelerationStructure := &accelerationStructure

	var rsys uintptr

	if vkCreateAccelerationStructureKHR.fnHandle == nil {
		vkCreateAccelerationStructureKHR.fnHandle = dlHandle.NewProc("vkCreateAccelerationStructureKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateAccelerationStructureKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pAccelerationStructure)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateAccelerationStructureKHR = &vkCommand{"vkCreateAccelerationStructureKHR", 4, true, nil}

// CreateAccelerationStructureNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateAccelerationStructureNV.html
func CreateAccelerationStructureNV(device Device, createInfo *AccelerationStructureCreateInfoNV, allocator *AllocationCallbacks) (accelerationStructure AccelerationStructureNV, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkAccelerationStructureCreateInfoNV
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// accelerationStructure is a binding-allocated single return value and will be populated by Vulkan
	ptr_pAccelerationStructure := &accelerationStructure

	var rsys uintptr

	if vkCreateAccelerationStructureNV.fnHandle == nil {
		vkCreateAccelerationStructureNV.fnHandle = dlHandle.NewProc("vkCreateAccelerationStructureNV")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateAccelerationStructureNV.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pAccelerationStructure)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateAccelerationStructureNV = &vkCommand{"vkCreateAccelerationStructureNV", 4, true, nil}

// CreateBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateBuffer.html
func CreateBuffer(device Device, createInfo *BufferCreateInfo, allocator *AllocationCallbacks) (buffer Buffer, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkBufferCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// buffer is a binding-allocated single return value and will be populated by Vulkan
	ptr_pBuffer := &buffer

	var rsys uintptr

	if vkCreateBuffer.fnHandle == nil {
		vkCreateBuffer.fnHandle = dlHandle.NewProc("vkCreateBuffer")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateBuffer.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pBuffer)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateBuffer = &vkCommand{"vkCreateBuffer", 4, true, nil}

// CreateBufferView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateBufferView.html
func CreateBufferView(device Device, createInfo *BufferViewCreateInfo, allocator *AllocationCallbacks) (view BufferView, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkBufferViewCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// view is a binding-allocated single return value and will be populated by Vulkan
	ptr_pView := &view

	var rsys uintptr

	if vkCreateBufferView.fnHandle == nil {
		vkCreateBufferView.fnHandle = dlHandle.NewProc("vkCreateBufferView")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateBufferView.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pView)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateBufferView = &vkCommand{"vkCreateBufferView", 4, true, nil}

// CreateCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCommandPool.html
func CreateCommandPool(device Device, createInfo *CommandPoolCreateInfo, allocator *AllocationCallbacks) (commandPool CommandPool, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkCommandPoolCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// commandPool is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCommandPool := &commandPool

	var rsys uintptr

	if vkCreateCommandPool.fnHandle == nil {
		vkCreateCommandPool.fnHandle = dlHandle.NewProc("vkCreateCommandPool")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateCommandPool.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pCommandPool)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateCommandPool = &vkCommand{"vkCreateCommandPool", 4, true, nil}

// CreateComputePipelines: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateComputePipelines.html
func CreateComputePipelines(device Device, pipelineCache PipelineCache, createInfos []ComputePipelineCreateInfo, allocator *AllocationCallbacks) (pipelines []Pipeline, r error) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	var pCreateInfos unsafe.Pointer
	if len(createInfos) > 0 {
		sl_createInfos := make([]_vkComputePipelineCreateInfo, createInfoCount)
		for i, v := range createInfos {
			sl_createInfos[i] = *(v.Vulkanize())
		}
		pCreateInfos = unsafe.Pointer(&sl_createInfos[0])
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelines is an output array that will be allocated by the binding, len is from createInfoCount
	pipelines = make([]Pipeline, createInfoCount)
	pPipelines := unsafe.Pointer(&pipelines[0])

	var rsys uintptr

	if vkCreateComputePipelines.fnHandle == nil {
		vkCreateComputePipelines.fnHandle = dlHandle.NewProc("vkCreateComputePipelines")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateComputePipelines.fnHandle.Addr(), uintptr(device), uintptr(pipelineCache), uintptr(createInfoCount), uintptr(unsafe.Pointer(pCreateInfos)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(pPipelines)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateComputePipelines = &vkCommand{"vkCreateComputePipelines", 6, true, nil}

// CreateCuFunctionNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCuFunctionNVX.html
func CreateCuFunctionNVX(device Device, createInfo *CuFunctionCreateInfoNVX, allocator *AllocationCallbacks) (function CuFunctionNVX, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkCuFunctionCreateInfoNVX
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// function is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFunction := &function

	var rsys uintptr

	if vkCreateCuFunctionNVX.fnHandle == nil {
		vkCreateCuFunctionNVX.fnHandle = dlHandle.NewProc("vkCreateCuFunctionNVX")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateCuFunctionNVX.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pFunction)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateCuFunctionNVX = &vkCommand{"vkCreateCuFunctionNVX", 4, true, nil}

// CreateCuModuleNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCuModuleNVX.html
func CreateCuModuleNVX(device Device, createInfo *CuModuleCreateInfoNVX, allocator *AllocationCallbacks) (module CuModuleNVX, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkCuModuleCreateInfoNVX
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// module is a binding-allocated single return value and will be populated by Vulkan
	ptr_pModule := &module

	var rsys uintptr

	if vkCreateCuModuleNVX.fnHandle == nil {
		vkCreateCuModuleNVX.fnHandle = dlHandle.NewProc("vkCreateCuModuleNVX")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateCuModuleNVX.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pModule)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateCuModuleNVX = &vkCommand{"vkCreateCuModuleNVX", 4, true, nil}

// CreateDebugReportCallbackEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDebugReportCallbackEXT.html
func CreateDebugReportCallbackEXT(instance Instance, createInfo *DebugReportCallbackCreateInfoEXT, allocator *AllocationCallbacks) (callback DebugReportCallbackEXT, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDebugReportCallbackCreateInfoEXT
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// callback is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCallback := &callback

	var rsys uintptr

	if vkCreateDebugReportCallbackEXT.fnHandle == nil {
		vkCreateDebugReportCallbackEXT.fnHandle = dlHandle.NewProc("vkCreateDebugReportCallbackEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateDebugReportCallbackEXT.fnHandle.Addr(), uintptr(instance), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pCallback)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDebugReportCallbackEXT = &vkCommand{"vkCreateDebugReportCallbackEXT", 4, true, nil}

// CreateDebugUtilsMessengerEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html
func CreateDebugUtilsMessengerEXT(instance Instance, createInfo *DebugUtilsMessengerCreateInfoEXT, allocator *AllocationCallbacks) (messenger DebugUtilsMessengerEXT, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDebugUtilsMessengerCreateInfoEXT
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// messenger is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMessenger := &messenger

	var rsys uintptr

	if vkCreateDebugUtilsMessengerEXT.fnHandle == nil {
		vkCreateDebugUtilsMessengerEXT.fnHandle = dlHandle.NewProc("vkCreateDebugUtilsMessengerEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateDebugUtilsMessengerEXT.fnHandle.Addr(), uintptr(instance), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pMessenger)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDebugUtilsMessengerEXT = &vkCommand{"vkCreateDebugUtilsMessengerEXT", 4, true, nil}

// CreateDeferredOperationKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDeferredOperationKHR.html
func CreateDeferredOperationKHR(device Device, allocator *AllocationCallbacks) (deferredOperation DeferredOperationKHR, r error) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// deferredOperation is a binding-allocated single return value and will be populated by Vulkan
	ptr_pDeferredOperation := &deferredOperation

	var rsys uintptr

	if vkCreateDeferredOperationKHR.fnHandle == nil {
		vkCreateDeferredOperationKHR.fnHandle = dlHandle.NewProc("vkCreateDeferredOperationKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateDeferredOperationKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pDeferredOperation)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDeferredOperationKHR = &vkCommand{"vkCreateDeferredOperationKHR", 3, true, nil}

// CreateDescriptorPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorPool.html
func CreateDescriptorPool(device Device, createInfo *DescriptorPoolCreateInfo, allocator *AllocationCallbacks) (descriptorPool DescriptorPool, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDescriptorPoolCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// descriptorPool is a binding-allocated single return value and will be populated by Vulkan
	ptr_pDescriptorPool := &descriptorPool

	var rsys uintptr

	if vkCreateDescriptorPool.fnHandle == nil {
		vkCreateDescriptorPool.fnHandle = dlHandle.NewProc("vkCreateDescriptorPool")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateDescriptorPool.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pDescriptorPool)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDescriptorPool = &vkCommand{"vkCreateDescriptorPool", 4, true, nil}

// CreateDescriptorSetLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorSetLayout.html
func CreateDescriptorSetLayout(device Device, createInfo *DescriptorSetLayoutCreateInfo, allocator *AllocationCallbacks) (setLayout DescriptorSetLayout, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDescriptorSetLayoutCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// setLayout is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSetLayout := &setLayout

	var rsys uintptr

	if vkCreateDescriptorSetLayout.fnHandle == nil {
		vkCreateDescriptorSetLayout.fnHandle = dlHandle.NewProc("vkCreateDescriptorSetLayout")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateDescriptorSetLayout.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSetLayout)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDescriptorSetLayout = &vkCommand{"vkCreateDescriptorSetLayout", 4, true, nil}

// CreateDescriptorUpdateTemplate: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorUpdateTemplate.html
func CreateDescriptorUpdateTemplate(device Device, createInfo *DescriptorUpdateTemplateCreateInfo, allocator *AllocationCallbacks) (descriptorUpdateTemplate DescriptorUpdateTemplate, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDescriptorUpdateTemplateCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// descriptorUpdateTemplate is a binding-allocated single return value and will be populated by Vulkan
	ptr_pDescriptorUpdateTemplate := &descriptorUpdateTemplate

	var rsys uintptr

	if vkCreateDescriptorUpdateTemplate.fnHandle == nil {
		vkCreateDescriptorUpdateTemplate.fnHandle = dlHandle.NewProc("vkCreateDescriptorUpdateTemplate")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateDescriptorUpdateTemplate.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pDescriptorUpdateTemplate)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDescriptorUpdateTemplate = &vkCommand{"vkCreateDescriptorUpdateTemplate", 4, true, nil}
var CreateDescriptorUpdateTemplateKHR = CreateDescriptorUpdateTemplate

// CreateDevice: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDevice.html
func CreateDevice(physicalDevice PhysicalDevice, createInfo *DeviceCreateInfo, allocator *AllocationCallbacks) (device Device, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDeviceCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// device is a binding-allocated single return value and will be populated by Vulkan
	ptr_pDevice := &device

	var rsys uintptr

	if vkCreateDevice.fnHandle == nil {
		vkCreateDevice.fnHandle = dlHandle.NewProc("vkCreateDevice")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateDevice.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pDevice)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDevice = &vkCommand{"vkCreateDevice", 4, true, nil}

// CreateDisplayModeKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDisplayModeKHR.html
func CreateDisplayModeKHR(physicalDevice PhysicalDevice, display DisplayKHR, createInfo *DisplayModeCreateInfoKHR, allocator *AllocationCallbacks) (mode DisplayModeKHR, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDisplayModeCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// mode is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMode := &mode

	var rsys uintptr

	if vkCreateDisplayModeKHR.fnHandle == nil {
		vkCreateDisplayModeKHR.fnHandle = dlHandle.NewProc("vkCreateDisplayModeKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateDisplayModeKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(display), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pMode)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDisplayModeKHR = &vkCommand{"vkCreateDisplayModeKHR", 5, true, nil}

// CreateDisplayPlaneSurfaceKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDisplayPlaneSurfaceKHR.html
func CreateDisplayPlaneSurfaceKHR(instance Instance, createInfo *DisplaySurfaceCreateInfoKHR, allocator *AllocationCallbacks) (surface SurfaceKHR, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDisplaySurfaceCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// surface is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSurface := &surface

	var rsys uintptr

	if vkCreateDisplayPlaneSurfaceKHR.fnHandle == nil {
		vkCreateDisplayPlaneSurfaceKHR.fnHandle = dlHandle.NewProc("vkCreateDisplayPlaneSurfaceKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateDisplayPlaneSurfaceKHR.fnHandle.Addr(), uintptr(instance), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSurface)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDisplayPlaneSurfaceKHR = &vkCommand{"vkCreateDisplayPlaneSurfaceKHR", 4, true, nil}

// CreateEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateEvent.html
func CreateEvent(device Device, createInfo *EventCreateInfo, allocator *AllocationCallbacks) (event Event, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkEventCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// event is a binding-allocated single return value and will be populated by Vulkan
	ptr_pEvent := &event

	var rsys uintptr

	if vkCreateEvent.fnHandle == nil {
		vkCreateEvent.fnHandle = dlHandle.NewProc("vkCreateEvent")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateEvent.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pEvent)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateEvent = &vkCommand{"vkCreateEvent", 4, true, nil}

// CreateFence: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateFence.html
func CreateFence(device Device, createInfo *FenceCreateInfo, allocator *AllocationCallbacks) (fence Fence, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkFenceCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// fence is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFence := &fence

	var rsys uintptr

	if vkCreateFence.fnHandle == nil {
		vkCreateFence.fnHandle = dlHandle.NewProc("vkCreateFence")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateFence.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pFence)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateFence = &vkCommand{"vkCreateFence", 4, true, nil}

// CreateFramebuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateFramebuffer.html
func CreateFramebuffer(device Device, createInfo *FramebufferCreateInfo, allocator *AllocationCallbacks) (framebuffer Framebuffer, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkFramebufferCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// framebuffer is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFramebuffer := &framebuffer

	var rsys uintptr

	if vkCreateFramebuffer.fnHandle == nil {
		vkCreateFramebuffer.fnHandle = dlHandle.NewProc("vkCreateFramebuffer")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateFramebuffer.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pFramebuffer)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateFramebuffer = &vkCommand{"vkCreateFramebuffer", 4, true, nil}

// CreateGraphicsPipelines: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateGraphicsPipelines.html
func CreateGraphicsPipelines(device Device, pipelineCache PipelineCache, createInfos []GraphicsPipelineCreateInfo, allocator *AllocationCallbacks) (pipelines []Pipeline, r error) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	var pCreateInfos unsafe.Pointer
	if len(createInfos) > 0 {
		sl_createInfos := make([]_vkGraphicsPipelineCreateInfo, createInfoCount)
		for i, v := range createInfos {
			sl_createInfos[i] = *(v.Vulkanize())
		}
		pCreateInfos = unsafe.Pointer(&sl_createInfos[0])
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelines is an output array that will be allocated by the binding, len is from createInfoCount
	pipelines = make([]Pipeline, createInfoCount)
	pPipelines := unsafe.Pointer(&pipelines[0])

	var rsys uintptr

	if vkCreateGraphicsPipelines.fnHandle == nil {
		vkCreateGraphicsPipelines.fnHandle = dlHandle.NewProc("vkCreateGraphicsPipelines")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateGraphicsPipelines.fnHandle.Addr(), uintptr(device), uintptr(pipelineCache), uintptr(createInfoCount), uintptr(unsafe.Pointer(pCreateInfos)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(pPipelines)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateGraphicsPipelines = &vkCommand{"vkCreateGraphicsPipelines", 6, true, nil}

// CreateHeadlessSurfaceEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateHeadlessSurfaceEXT.html
func CreateHeadlessSurfaceEXT(instance Instance, createInfo *HeadlessSurfaceCreateInfoEXT, allocator *AllocationCallbacks) (surface SurfaceKHR, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkHeadlessSurfaceCreateInfoEXT
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// surface is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSurface := &surface

	var rsys uintptr

	if vkCreateHeadlessSurfaceEXT.fnHandle == nil {
		vkCreateHeadlessSurfaceEXT.fnHandle = dlHandle.NewProc("vkCreateHeadlessSurfaceEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateHeadlessSurfaceEXT.fnHandle.Addr(), uintptr(instance), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSurface)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateHeadlessSurfaceEXT = &vkCommand{"vkCreateHeadlessSurfaceEXT", 4, true, nil}

// CreateImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateImage.html
func CreateImage(device Device, createInfo *ImageCreateInfo, allocator *AllocationCallbacks) (image Image, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkImageCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// image is a binding-allocated single return value and will be populated by Vulkan
	ptr_pImage := &image

	var rsys uintptr

	if vkCreateImage.fnHandle == nil {
		vkCreateImage.fnHandle = dlHandle.NewProc("vkCreateImage")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateImage.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pImage)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateImage = &vkCommand{"vkCreateImage", 4, true, nil}

// CreateImageView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateImageView.html
func CreateImageView(device Device, createInfo *ImageViewCreateInfo, allocator *AllocationCallbacks) (view ImageView, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkImageViewCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// view is a binding-allocated single return value and will be populated by Vulkan
	ptr_pView := &view

	var rsys uintptr

	if vkCreateImageView.fnHandle == nil {
		vkCreateImageView.fnHandle = dlHandle.NewProc("vkCreateImageView")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateImageView.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pView)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateImageView = &vkCommand{"vkCreateImageView", 4, true, nil}

// CreateIndirectCommandsLayoutNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateIndirectCommandsLayoutNV.html
func CreateIndirectCommandsLayoutNV(device Device, createInfo *IndirectCommandsLayoutCreateInfoNV, allocator *AllocationCallbacks) (indirectCommandsLayout IndirectCommandsLayoutNV, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkIndirectCommandsLayoutCreateInfoNV
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// indirectCommandsLayout is a binding-allocated single return value and will be populated by Vulkan
	ptr_pIndirectCommandsLayout := &indirectCommandsLayout

	var rsys uintptr

	if vkCreateIndirectCommandsLayoutNV.fnHandle == nil {
		vkCreateIndirectCommandsLayoutNV.fnHandle = dlHandle.NewProc("vkCreateIndirectCommandsLayoutNV")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateIndirectCommandsLayoutNV.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pIndirectCommandsLayout)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateIndirectCommandsLayoutNV = &vkCommand{"vkCreateIndirectCommandsLayoutNV", 4, true, nil}

// CreateInstance: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html
func CreateInstance(createInfo *InstanceCreateInfo, allocator *AllocationCallbacks) (instance Instance, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkInstanceCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// instance is a binding-allocated single return value and will be populated by Vulkan
	ptr_pInstance := &instance

	var rsys uintptr

	if vkCreateInstance.fnHandle == nil {
		vkCreateInstance.fnHandle = dlHandle.NewProc("vkCreateInstance")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateInstance.fnHandle.Addr(), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pInstance)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateInstance = &vkCommand{"vkCreateInstance", 3, true, nil}

// CreatePipelineCache: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineCache.html
func CreatePipelineCache(device Device, createInfo *PipelineCacheCreateInfo, allocator *AllocationCallbacks) (pipelineCache PipelineCache, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkPipelineCacheCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelineCache is a binding-allocated single return value and will be populated by Vulkan
	ptr_pPipelineCache := &pipelineCache

	var rsys uintptr

	if vkCreatePipelineCache.fnHandle == nil {
		vkCreatePipelineCache.fnHandle = dlHandle.NewProc("vkCreatePipelineCache")
	}
	rsys, _, _ = syscall.SyscallN(vkCreatePipelineCache.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pPipelineCache)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreatePipelineCache = &vkCommand{"vkCreatePipelineCache", 4, true, nil}

// CreatePipelineLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineLayout.html
func CreatePipelineLayout(device Device, createInfo *PipelineLayoutCreateInfo, allocator *AllocationCallbacks) (pipelineLayout PipelineLayout, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkPipelineLayoutCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelineLayout is a binding-allocated single return value and will be populated by Vulkan
	ptr_pPipelineLayout := &pipelineLayout

	var rsys uintptr

	if vkCreatePipelineLayout.fnHandle == nil {
		vkCreatePipelineLayout.fnHandle = dlHandle.NewProc("vkCreatePipelineLayout")
	}
	rsys, _, _ = syscall.SyscallN(vkCreatePipelineLayout.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pPipelineLayout)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreatePipelineLayout = &vkCommand{"vkCreatePipelineLayout", 4, true, nil}

// CreatePrivateDataSlotEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePrivateDataSlotEXT.html
func CreatePrivateDataSlotEXT(device Device, createInfo *PrivateDataSlotCreateInfoEXT, allocator *AllocationCallbacks) (privateDataSlot PrivateDataSlotEXT, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkPrivateDataSlotCreateInfoEXT
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// privateDataSlot is a binding-allocated single return value and will be populated by Vulkan
	ptr_pPrivateDataSlot := &privateDataSlot

	var rsys uintptr

	if vkCreatePrivateDataSlotEXT.fnHandle == nil {
		vkCreatePrivateDataSlotEXT.fnHandle = dlHandle.NewProc("vkCreatePrivateDataSlotEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkCreatePrivateDataSlotEXT.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pPrivateDataSlot)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreatePrivateDataSlotEXT = &vkCommand{"vkCreatePrivateDataSlotEXT", 4, true, nil}

// CreateQueryPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateQueryPool.html
func CreateQueryPool(device Device, createInfo *QueryPoolCreateInfo, allocator *AllocationCallbacks) (queryPool QueryPool, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkQueryPoolCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// queryPool is a binding-allocated single return value and will be populated by Vulkan
	ptr_pQueryPool := &queryPool

	var rsys uintptr

	if vkCreateQueryPool.fnHandle == nil {
		vkCreateQueryPool.fnHandle = dlHandle.NewProc("vkCreateQueryPool")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateQueryPool.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pQueryPool)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateQueryPool = &vkCommand{"vkCreateQueryPool", 4, true, nil}

// CreateRayTracingPipelinesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRayTracingPipelinesKHR.html
func CreateRayTracingPipelinesKHR(device Device, deferredOperation DeferredOperationKHR, pipelineCache PipelineCache, createInfos []RayTracingPipelineCreateInfoKHR, allocator *AllocationCallbacks) (pipelines []Pipeline, r error) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	var pCreateInfos unsafe.Pointer
	if len(createInfos) > 0 {
		sl_createInfos := make([]_vkRayTracingPipelineCreateInfoKHR, createInfoCount)
		for i, v := range createInfos {
			sl_createInfos[i] = *(v.Vulkanize())
		}
		pCreateInfos = unsafe.Pointer(&sl_createInfos[0])
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelines is an output array that will be allocated by the binding, len is from createInfoCount
	pipelines = make([]Pipeline, createInfoCount)
	pPipelines := unsafe.Pointer(&pipelines[0])

	var rsys uintptr

	if vkCreateRayTracingPipelinesKHR.fnHandle == nil {
		vkCreateRayTracingPipelinesKHR.fnHandle = dlHandle.NewProc("vkCreateRayTracingPipelinesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateRayTracingPipelinesKHR.fnHandle.Addr(), uintptr(device), uintptr(deferredOperation), uintptr(pipelineCache), uintptr(createInfoCount), uintptr(unsafe.Pointer(pCreateInfos)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(pPipelines)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateRayTracingPipelinesKHR = &vkCommand{"vkCreateRayTracingPipelinesKHR", 7, true, nil}

// CreateRayTracingPipelinesNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRayTracingPipelinesNV.html
func CreateRayTracingPipelinesNV(device Device, pipelineCache PipelineCache, createInfos []RayTracingPipelineCreateInfoNV, allocator *AllocationCallbacks) (pipelines []Pipeline, r error) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	var pCreateInfos unsafe.Pointer
	if len(createInfos) > 0 {
		sl_createInfos := make([]_vkRayTracingPipelineCreateInfoNV, createInfoCount)
		for i, v := range createInfos {
			sl_createInfos[i] = *(v.Vulkanize())
		}
		pCreateInfos = unsafe.Pointer(&sl_createInfos[0])
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelines is an output array that will be allocated by the binding, len is from createInfoCount
	pipelines = make([]Pipeline, createInfoCount)
	pPipelines := unsafe.Pointer(&pipelines[0])

	var rsys uintptr

	if vkCreateRayTracingPipelinesNV.fnHandle == nil {
		vkCreateRayTracingPipelinesNV.fnHandle = dlHandle.NewProc("vkCreateRayTracingPipelinesNV")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateRayTracingPipelinesNV.fnHandle.Addr(), uintptr(device), uintptr(pipelineCache), uintptr(createInfoCount), uintptr(unsafe.Pointer(pCreateInfos)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(pPipelines)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateRayTracingPipelinesNV = &vkCommand{"vkCreateRayTracingPipelinesNV", 6, true, nil}

// CreateRenderPass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRenderPass.html
func CreateRenderPass(device Device, createInfo *RenderPassCreateInfo, allocator *AllocationCallbacks) (renderPass RenderPass, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkRenderPassCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// renderPass is a binding-allocated single return value and will be populated by Vulkan
	ptr_pRenderPass := &renderPass

	var rsys uintptr

	if vkCreateRenderPass.fnHandle == nil {
		vkCreateRenderPass.fnHandle = dlHandle.NewProc("vkCreateRenderPass")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateRenderPass.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pRenderPass)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateRenderPass = &vkCommand{"vkCreateRenderPass", 4, true, nil}

// CreateRenderPass2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRenderPass2.html
func CreateRenderPass2(device Device, createInfo *RenderPassCreateInfo2, allocator *AllocationCallbacks) (renderPass RenderPass, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkRenderPassCreateInfo2
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// renderPass is a binding-allocated single return value and will be populated by Vulkan
	ptr_pRenderPass := &renderPass

	var rsys uintptr

	if vkCreateRenderPass2.fnHandle == nil {
		vkCreateRenderPass2.fnHandle = dlHandle.NewProc("vkCreateRenderPass2")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateRenderPass2.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pRenderPass)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateRenderPass2 = &vkCommand{"vkCreateRenderPass2", 4, true, nil}
var CreateRenderPass2KHR = CreateRenderPass2

// CreateSampler: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSampler.html
func CreateSampler(device Device, createInfo *SamplerCreateInfo, allocator *AllocationCallbacks) (sampler Sampler, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkSamplerCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// sampler is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSampler := &sampler

	var rsys uintptr

	if vkCreateSampler.fnHandle == nil {
		vkCreateSampler.fnHandle = dlHandle.NewProc("vkCreateSampler")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateSampler.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSampler)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateSampler = &vkCommand{"vkCreateSampler", 4, true, nil}

// CreateSamplerYcbcrConversion: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSamplerYcbcrConversion.html
func CreateSamplerYcbcrConversion(device Device, createInfo *SamplerYcbcrConversionCreateInfo, allocator *AllocationCallbacks) (ycbcrConversion SamplerYcbcrConversion, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkSamplerYcbcrConversionCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// ycbcrConversion is a binding-allocated single return value and will be populated by Vulkan
	ptr_pYcbcrConversion := &ycbcrConversion

	var rsys uintptr

	if vkCreateSamplerYcbcrConversion.fnHandle == nil {
		vkCreateSamplerYcbcrConversion.fnHandle = dlHandle.NewProc("vkCreateSamplerYcbcrConversion")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateSamplerYcbcrConversion.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pYcbcrConversion)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateSamplerYcbcrConversion = &vkCommand{"vkCreateSamplerYcbcrConversion", 4, true, nil}
var CreateSamplerYcbcrConversionKHR = CreateSamplerYcbcrConversion

// CreateSemaphore: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSemaphore.html
func CreateSemaphore(device Device, createInfo *SemaphoreCreateInfo, allocator *AllocationCallbacks) (semaphore Semaphore, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkSemaphoreCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// semaphore is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSemaphore := &semaphore

	var rsys uintptr

	if vkCreateSemaphore.fnHandle == nil {
		vkCreateSemaphore.fnHandle = dlHandle.NewProc("vkCreateSemaphore")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateSemaphore.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSemaphore)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateSemaphore = &vkCommand{"vkCreateSemaphore", 4, true, nil}

// CreateShaderModule: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateShaderModule.html
func CreateShaderModule(device Device, createInfo *ShaderModuleCreateInfo, allocator *AllocationCallbacks) (shaderModule ShaderModule, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkShaderModuleCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// shaderModule is a binding-allocated single return value and will be populated by Vulkan
	ptr_pShaderModule := &shaderModule

	var rsys uintptr

	if vkCreateShaderModule.fnHandle == nil {
		vkCreateShaderModule.fnHandle = dlHandle.NewProc("vkCreateShaderModule")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateShaderModule.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pShaderModule)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateShaderModule = &vkCommand{"vkCreateShaderModule", 4, true, nil}

// CreateSharedSwapchainsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSharedSwapchainsKHR.html
func CreateSharedSwapchainsKHR(device Device, createInfos []SwapchainCreateInfoKHR, allocator *AllocationCallbacks) (swapchains []SwapchainKHR, r error) {
	swapchainCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	var pCreateInfos unsafe.Pointer
	if len(createInfos) > 0 {
		sl_createInfos := make([]_vkSwapchainCreateInfoKHR, swapchainCount)
		for i, v := range createInfos {
			sl_createInfos[i] = *(v.Vulkanize())
		}
		pCreateInfos = unsafe.Pointer(&sl_createInfos[0])
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// swapchains is an output array that will be allocated by the binding, len is from swapchainCount
	swapchains = make([]SwapchainKHR, swapchainCount)
	pSwapchains := unsafe.Pointer(&swapchains[0])

	var rsys uintptr

	if vkCreateSharedSwapchainsKHR.fnHandle == nil {
		vkCreateSharedSwapchainsKHR.fnHandle = dlHandle.NewProc("vkCreateSharedSwapchainsKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateSharedSwapchainsKHR.fnHandle.Addr(), uintptr(device), uintptr(swapchainCount), uintptr(unsafe.Pointer(pCreateInfos)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(pSwapchains)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateSharedSwapchainsKHR = &vkCommand{"vkCreateSharedSwapchainsKHR", 5, true, nil}

// CreateSwapchainKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSwapchainKHR.html
func CreateSwapchainKHR(device Device, createInfo *SwapchainCreateInfoKHR, allocator *AllocationCallbacks) (swapchain SwapchainKHR, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkSwapchainCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// swapchain is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSwapchain := &swapchain

	var rsys uintptr

	if vkCreateSwapchainKHR.fnHandle == nil {
		vkCreateSwapchainKHR.fnHandle = dlHandle.NewProc("vkCreateSwapchainKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateSwapchainKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSwapchain)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateSwapchainKHR = &vkCommand{"vkCreateSwapchainKHR", 4, true, nil}

// CreateValidationCacheEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateValidationCacheEXT.html
func CreateValidationCacheEXT(device Device, createInfo *ValidationCacheCreateInfoEXT, allocator *AllocationCallbacks) (validationCache ValidationCacheEXT, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkValidationCacheCreateInfoEXT
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// validationCache is a binding-allocated single return value and will be populated by Vulkan
	ptr_pValidationCache := &validationCache

	var rsys uintptr

	if vkCreateValidationCacheEXT.fnHandle == nil {
		vkCreateValidationCacheEXT.fnHandle = dlHandle.NewProc("vkCreateValidationCacheEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateValidationCacheEXT.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pValidationCache)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateValidationCacheEXT = &vkCommand{"vkCreateValidationCacheEXT", 4, true, nil}

// DebugMarkerSetObjectNameEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDebugMarkerSetObjectNameEXT.html
func DebugMarkerSetObjectNameEXT(device Device, nameInfo *DebugMarkerObjectNameInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - nameInfo
	var pNameInfo *_vkDebugMarkerObjectNameInfoEXT
	if nameInfo != nil {
		pNameInfo = nameInfo.Vulkanize()
	}

	var rsys uintptr

	if vkDebugMarkerSetObjectNameEXT.fnHandle == nil {
		vkDebugMarkerSetObjectNameEXT.fnHandle = dlHandle.NewProc("vkDebugMarkerSetObjectNameEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkDebugMarkerSetObjectNameEXT.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pNameInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkDebugMarkerSetObjectNameEXT = &vkCommand{"vkDebugMarkerSetObjectNameEXT", 2, true, nil}

// DebugMarkerSetObjectTagEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDebugMarkerSetObjectTagEXT.html
func DebugMarkerSetObjectTagEXT(device Device, tagInfo *DebugMarkerObjectTagInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - tagInfo
	var pTagInfo *_vkDebugMarkerObjectTagInfoEXT
	if tagInfo != nil {
		pTagInfo = tagInfo.Vulkanize()
	}

	var rsys uintptr

	if vkDebugMarkerSetObjectTagEXT.fnHandle == nil {
		vkDebugMarkerSetObjectTagEXT.fnHandle = dlHandle.NewProc("vkDebugMarkerSetObjectTagEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkDebugMarkerSetObjectTagEXT.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pTagInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkDebugMarkerSetObjectTagEXT = &vkCommand{"vkDebugMarkerSetObjectTagEXT", 2, true, nil}

// DebugReportMessageEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDebugReportMessageEXT.html
func DebugReportMessageEXT(instance Instance, flags DebugReportFlagsEXT, objectType DebugReportObjectTypeEXT, object uint64, location uintptr, messageCode int32, layerPrefix string, message string) {
	// Parameter is a singular input, requires translation - layerPrefix
	var pLayerPrefix *byte
	if layerPrefix != "" {
		pLayerPrefix = sys_stringToBytePointer(layerPrefix)
	}

	// Parameter is a singular input, requires translation - message
	var pMessage *byte
	if message != "" {
		pMessage = sys_stringToBytePointer(message)
	}

	if vkDebugReportMessageEXT.fnHandle == nil {
		vkDebugReportMessageEXT.fnHandle = dlHandle.NewProc("vkDebugReportMessageEXT")
	}
	syscall.SyscallN(vkDebugReportMessageEXT.fnHandle.Addr(), uintptr(instance), uintptr(flags), uintptr(objectType), uintptr(object), uintptr(location), uintptr(messageCode), uintptr(unsafe.Pointer(pLayerPrefix)), uintptr(unsafe.Pointer(pMessage)))

}

var vkDebugReportMessageEXT = &vkCommand{"vkDebugReportMessageEXT", 8, true, nil}

// DeferredOperationJoinKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDeferredOperationJoinKHR.html
func DeferredOperationJoinKHR(device Device, operation DeferredOperationKHR) (r error) {
	var rsys uintptr

	if vkDeferredOperationJoinKHR.fnHandle == nil {
		vkDeferredOperationJoinKHR.fnHandle = dlHandle.NewProc("vkDeferredOperationJoinKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkDeferredOperationJoinKHR.fnHandle.Addr(), uintptr(device), uintptr(operation))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkDeferredOperationJoinKHR = &vkCommand{"vkDeferredOperationJoinKHR", 2, true, nil}

// DestroyAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyAccelerationStructureKHR.html
func DestroyAccelerationStructureKHR(device Device, accelerationStructure AccelerationStructureKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyAccelerationStructureKHR.fnHandle == nil {
		vkDestroyAccelerationStructureKHR.fnHandle = dlHandle.NewProc("vkDestroyAccelerationStructureKHR")
	}
	syscall.SyscallN(vkDestroyAccelerationStructureKHR.fnHandle.Addr(), uintptr(device), uintptr(accelerationStructure), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyAccelerationStructureKHR = &vkCommand{"vkDestroyAccelerationStructureKHR", 3, true, nil}

// DestroyAccelerationStructureNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyAccelerationStructureNV.html
func DestroyAccelerationStructureNV(device Device, accelerationStructure AccelerationStructureNV, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyAccelerationStructureNV.fnHandle == nil {
		vkDestroyAccelerationStructureNV.fnHandle = dlHandle.NewProc("vkDestroyAccelerationStructureNV")
	}
	syscall.SyscallN(vkDestroyAccelerationStructureNV.fnHandle.Addr(), uintptr(device), uintptr(accelerationStructure), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyAccelerationStructureNV = &vkCommand{"vkDestroyAccelerationStructureNV", 3, true, nil}

// DestroyBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyBuffer.html
func DestroyBuffer(device Device, buffer Buffer, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyBuffer.fnHandle == nil {
		vkDestroyBuffer.fnHandle = dlHandle.NewProc("vkDestroyBuffer")
	}
	syscall.SyscallN(vkDestroyBuffer.fnHandle.Addr(), uintptr(device), uintptr(buffer), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyBuffer = &vkCommand{"vkDestroyBuffer", 3, true, nil}

// DestroyBufferView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyBufferView.html
func DestroyBufferView(device Device, bufferView BufferView, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyBufferView.fnHandle == nil {
		vkDestroyBufferView.fnHandle = dlHandle.NewProc("vkDestroyBufferView")
	}
	syscall.SyscallN(vkDestroyBufferView.fnHandle.Addr(), uintptr(device), uintptr(bufferView), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyBufferView = &vkCommand{"vkDestroyBufferView", 3, true, nil}

// DestroyCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCommandPool.html
func DestroyCommandPool(device Device, commandPool CommandPool, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyCommandPool.fnHandle == nil {
		vkDestroyCommandPool.fnHandle = dlHandle.NewProc("vkDestroyCommandPool")
	}
	syscall.SyscallN(vkDestroyCommandPool.fnHandle.Addr(), uintptr(device), uintptr(commandPool), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyCommandPool = &vkCommand{"vkDestroyCommandPool", 3, true, nil}

// DestroyCuFunctionNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCuFunctionNVX.html
func DestroyCuFunctionNVX(device Device, function CuFunctionNVX, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyCuFunctionNVX.fnHandle == nil {
		vkDestroyCuFunctionNVX.fnHandle = dlHandle.NewProc("vkDestroyCuFunctionNVX")
	}
	syscall.SyscallN(vkDestroyCuFunctionNVX.fnHandle.Addr(), uintptr(device), uintptr(function), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyCuFunctionNVX = &vkCommand{"vkDestroyCuFunctionNVX", 3, true, nil}

// DestroyCuModuleNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCuModuleNVX.html
func DestroyCuModuleNVX(device Device, module CuModuleNVX, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyCuModuleNVX.fnHandle == nil {
		vkDestroyCuModuleNVX.fnHandle = dlHandle.NewProc("vkDestroyCuModuleNVX")
	}
	syscall.SyscallN(vkDestroyCuModuleNVX.fnHandle.Addr(), uintptr(device), uintptr(module), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyCuModuleNVX = &vkCommand{"vkDestroyCuModuleNVX", 3, true, nil}

// DestroyDebugReportCallbackEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDebugReportCallbackEXT.html
func DestroyDebugReportCallbackEXT(instance Instance, callback DebugReportCallbackEXT, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyDebugReportCallbackEXT.fnHandle == nil {
		vkDestroyDebugReportCallbackEXT.fnHandle = dlHandle.NewProc("vkDestroyDebugReportCallbackEXT")
	}
	syscall.SyscallN(vkDestroyDebugReportCallbackEXT.fnHandle.Addr(), uintptr(instance), uintptr(callback), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyDebugReportCallbackEXT = &vkCommand{"vkDestroyDebugReportCallbackEXT", 3, true, nil}

// DestroyDebugUtilsMessengerEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDebugUtilsMessengerEXT.html
func DestroyDebugUtilsMessengerEXT(instance Instance, messenger DebugUtilsMessengerEXT, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyDebugUtilsMessengerEXT.fnHandle == nil {
		vkDestroyDebugUtilsMessengerEXT.fnHandle = dlHandle.NewProc("vkDestroyDebugUtilsMessengerEXT")
	}
	syscall.SyscallN(vkDestroyDebugUtilsMessengerEXT.fnHandle.Addr(), uintptr(instance), uintptr(messenger), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyDebugUtilsMessengerEXT = &vkCommand{"vkDestroyDebugUtilsMessengerEXT", 3, true, nil}

// DestroyDeferredOperationKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDeferredOperationKHR.html
func DestroyDeferredOperationKHR(device Device, operation DeferredOperationKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyDeferredOperationKHR.fnHandle == nil {
		vkDestroyDeferredOperationKHR.fnHandle = dlHandle.NewProc("vkDestroyDeferredOperationKHR")
	}
	syscall.SyscallN(vkDestroyDeferredOperationKHR.fnHandle.Addr(), uintptr(device), uintptr(operation), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyDeferredOperationKHR = &vkCommand{"vkDestroyDeferredOperationKHR", 3, true, nil}

// DestroyDescriptorPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorPool.html
func DestroyDescriptorPool(device Device, descriptorPool DescriptorPool, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyDescriptorPool.fnHandle == nil {
		vkDestroyDescriptorPool.fnHandle = dlHandle.NewProc("vkDestroyDescriptorPool")
	}
	syscall.SyscallN(vkDestroyDescriptorPool.fnHandle.Addr(), uintptr(device), uintptr(descriptorPool), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyDescriptorPool = &vkCommand{"vkDestroyDescriptorPool", 3, true, nil}

// DestroyDescriptorSetLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorSetLayout.html
func DestroyDescriptorSetLayout(device Device, descriptorSetLayout DescriptorSetLayout, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyDescriptorSetLayout.fnHandle == nil {
		vkDestroyDescriptorSetLayout.fnHandle = dlHandle.NewProc("vkDestroyDescriptorSetLayout")
	}
	syscall.SyscallN(vkDestroyDescriptorSetLayout.fnHandle.Addr(), uintptr(device), uintptr(descriptorSetLayout), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyDescriptorSetLayout = &vkCommand{"vkDestroyDescriptorSetLayout", 3, true, nil}

// DestroyDescriptorUpdateTemplate: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorUpdateTemplate.html
func DestroyDescriptorUpdateTemplate(device Device, descriptorUpdateTemplate DescriptorUpdateTemplate, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyDescriptorUpdateTemplate.fnHandle == nil {
		vkDestroyDescriptorUpdateTemplate.fnHandle = dlHandle.NewProc("vkDestroyDescriptorUpdateTemplate")
	}
	syscall.SyscallN(vkDestroyDescriptorUpdateTemplate.fnHandle.Addr(), uintptr(device), uintptr(descriptorUpdateTemplate), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyDescriptorUpdateTemplate = &vkCommand{"vkDestroyDescriptorUpdateTemplate", 3, true, nil}
var DestroyDescriptorUpdateTemplateKHR = DestroyDescriptorUpdateTemplate

// DestroyDevice: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDevice.html
func DestroyDevice(device Device, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyDevice.fnHandle == nil {
		vkDestroyDevice.fnHandle = dlHandle.NewProc("vkDestroyDevice")
	}
	syscall.SyscallN(vkDestroyDevice.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyDevice = &vkCommand{"vkDestroyDevice", 2, true, nil}

// DestroyEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyEvent.html
func DestroyEvent(device Device, event Event, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyEvent.fnHandle == nil {
		vkDestroyEvent.fnHandle = dlHandle.NewProc("vkDestroyEvent")
	}
	syscall.SyscallN(vkDestroyEvent.fnHandle.Addr(), uintptr(device), uintptr(event), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyEvent = &vkCommand{"vkDestroyEvent", 3, true, nil}

// DestroyFence: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyFence.html
func DestroyFence(device Device, fence Fence, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyFence.fnHandle == nil {
		vkDestroyFence.fnHandle = dlHandle.NewProc("vkDestroyFence")
	}
	syscall.SyscallN(vkDestroyFence.fnHandle.Addr(), uintptr(device), uintptr(fence), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyFence = &vkCommand{"vkDestroyFence", 3, true, nil}

// DestroyFramebuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyFramebuffer.html
func DestroyFramebuffer(device Device, framebuffer Framebuffer, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyFramebuffer.fnHandle == nil {
		vkDestroyFramebuffer.fnHandle = dlHandle.NewProc("vkDestroyFramebuffer")
	}
	syscall.SyscallN(vkDestroyFramebuffer.fnHandle.Addr(), uintptr(device), uintptr(framebuffer), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyFramebuffer = &vkCommand{"vkDestroyFramebuffer", 3, true, nil}

// DestroyImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyImage.html
func DestroyImage(device Device, image Image, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyImage.fnHandle == nil {
		vkDestroyImage.fnHandle = dlHandle.NewProc("vkDestroyImage")
	}
	syscall.SyscallN(vkDestroyImage.fnHandle.Addr(), uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyImage = &vkCommand{"vkDestroyImage", 3, true, nil}

// DestroyImageView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyImageView.html
func DestroyImageView(device Device, imageView ImageView, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyImageView.fnHandle == nil {
		vkDestroyImageView.fnHandle = dlHandle.NewProc("vkDestroyImageView")
	}
	syscall.SyscallN(vkDestroyImageView.fnHandle.Addr(), uintptr(device), uintptr(imageView), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyImageView = &vkCommand{"vkDestroyImageView", 3, true, nil}

// DestroyIndirectCommandsLayoutNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyIndirectCommandsLayoutNV.html
func DestroyIndirectCommandsLayoutNV(device Device, indirectCommandsLayout IndirectCommandsLayoutNV, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyIndirectCommandsLayoutNV.fnHandle == nil {
		vkDestroyIndirectCommandsLayoutNV.fnHandle = dlHandle.NewProc("vkDestroyIndirectCommandsLayoutNV")
	}
	syscall.SyscallN(vkDestroyIndirectCommandsLayoutNV.fnHandle.Addr(), uintptr(device), uintptr(indirectCommandsLayout), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyIndirectCommandsLayoutNV = &vkCommand{"vkDestroyIndirectCommandsLayoutNV", 3, true, nil}

// DestroyInstance: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyInstance.html
func DestroyInstance(instance Instance, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyInstance.fnHandle == nil {
		vkDestroyInstance.fnHandle = dlHandle.NewProc("vkDestroyInstance")
	}
	syscall.SyscallN(vkDestroyInstance.fnHandle.Addr(), uintptr(instance), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyInstance = &vkCommand{"vkDestroyInstance", 2, true, nil}

// DestroyPipeline: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipeline.html
func DestroyPipeline(device Device, pipeline Pipeline, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyPipeline.fnHandle == nil {
		vkDestroyPipeline.fnHandle = dlHandle.NewProc("vkDestroyPipeline")
	}
	syscall.SyscallN(vkDestroyPipeline.fnHandle.Addr(), uintptr(device), uintptr(pipeline), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyPipeline = &vkCommand{"vkDestroyPipeline", 3, true, nil}

// DestroyPipelineCache: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineCache.html
func DestroyPipelineCache(device Device, pipelineCache PipelineCache, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyPipelineCache.fnHandle == nil {
		vkDestroyPipelineCache.fnHandle = dlHandle.NewProc("vkDestroyPipelineCache")
	}
	syscall.SyscallN(vkDestroyPipelineCache.fnHandle.Addr(), uintptr(device), uintptr(pipelineCache), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyPipelineCache = &vkCommand{"vkDestroyPipelineCache", 3, true, nil}

// DestroyPipelineLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineLayout.html
func DestroyPipelineLayout(device Device, pipelineLayout PipelineLayout, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyPipelineLayout.fnHandle == nil {
		vkDestroyPipelineLayout.fnHandle = dlHandle.NewProc("vkDestroyPipelineLayout")
	}
	syscall.SyscallN(vkDestroyPipelineLayout.fnHandle.Addr(), uintptr(device), uintptr(pipelineLayout), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyPipelineLayout = &vkCommand{"vkDestroyPipelineLayout", 3, true, nil}

// DestroyPrivateDataSlotEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPrivateDataSlotEXT.html
func DestroyPrivateDataSlotEXT(device Device, privateDataSlot PrivateDataSlotEXT, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyPrivateDataSlotEXT.fnHandle == nil {
		vkDestroyPrivateDataSlotEXT.fnHandle = dlHandle.NewProc("vkDestroyPrivateDataSlotEXT")
	}
	syscall.SyscallN(vkDestroyPrivateDataSlotEXT.fnHandle.Addr(), uintptr(device), uintptr(privateDataSlot), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyPrivateDataSlotEXT = &vkCommand{"vkDestroyPrivateDataSlotEXT", 3, true, nil}

// DestroyQueryPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyQueryPool.html
func DestroyQueryPool(device Device, queryPool QueryPool, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyQueryPool.fnHandle == nil {
		vkDestroyQueryPool.fnHandle = dlHandle.NewProc("vkDestroyQueryPool")
	}
	syscall.SyscallN(vkDestroyQueryPool.fnHandle.Addr(), uintptr(device), uintptr(queryPool), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyQueryPool = &vkCommand{"vkDestroyQueryPool", 3, true, nil}

// DestroyRenderPass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyRenderPass.html
func DestroyRenderPass(device Device, renderPass RenderPass, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyRenderPass.fnHandle == nil {
		vkDestroyRenderPass.fnHandle = dlHandle.NewProc("vkDestroyRenderPass")
	}
	syscall.SyscallN(vkDestroyRenderPass.fnHandle.Addr(), uintptr(device), uintptr(renderPass), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyRenderPass = &vkCommand{"vkDestroyRenderPass", 3, true, nil}

// DestroySampler: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySampler.html
func DestroySampler(device Device, sampler Sampler, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroySampler.fnHandle == nil {
		vkDestroySampler.fnHandle = dlHandle.NewProc("vkDestroySampler")
	}
	syscall.SyscallN(vkDestroySampler.fnHandle.Addr(), uintptr(device), uintptr(sampler), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroySampler = &vkCommand{"vkDestroySampler", 3, true, nil}

// DestroySamplerYcbcrConversion: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySamplerYcbcrConversion.html
func DestroySamplerYcbcrConversion(device Device, ycbcrConversion SamplerYcbcrConversion, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroySamplerYcbcrConversion.fnHandle == nil {
		vkDestroySamplerYcbcrConversion.fnHandle = dlHandle.NewProc("vkDestroySamplerYcbcrConversion")
	}
	syscall.SyscallN(vkDestroySamplerYcbcrConversion.fnHandle.Addr(), uintptr(device), uintptr(ycbcrConversion), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroySamplerYcbcrConversion = &vkCommand{"vkDestroySamplerYcbcrConversion", 3, true, nil}
var DestroySamplerYcbcrConversionKHR = DestroySamplerYcbcrConversion

// DestroySemaphore: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySemaphore.html
func DestroySemaphore(device Device, semaphore Semaphore, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroySemaphore.fnHandle == nil {
		vkDestroySemaphore.fnHandle = dlHandle.NewProc("vkDestroySemaphore")
	}
	syscall.SyscallN(vkDestroySemaphore.fnHandle.Addr(), uintptr(device), uintptr(semaphore), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroySemaphore = &vkCommand{"vkDestroySemaphore", 3, true, nil}

// DestroyShaderModule: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyShaderModule.html
func DestroyShaderModule(device Device, shaderModule ShaderModule, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyShaderModule.fnHandle == nil {
		vkDestroyShaderModule.fnHandle = dlHandle.NewProc("vkDestroyShaderModule")
	}
	syscall.SyscallN(vkDestroyShaderModule.fnHandle.Addr(), uintptr(device), uintptr(shaderModule), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyShaderModule = &vkCommand{"vkDestroyShaderModule", 3, true, nil}

// DestroySurfaceKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySurfaceKHR.html
func DestroySurfaceKHR(instance Instance, surface SurfaceKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroySurfaceKHR.fnHandle == nil {
		vkDestroySurfaceKHR.fnHandle = dlHandle.NewProc("vkDestroySurfaceKHR")
	}
	syscall.SyscallN(vkDestroySurfaceKHR.fnHandle.Addr(), uintptr(instance), uintptr(surface), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroySurfaceKHR = &vkCommand{"vkDestroySurfaceKHR", 3, true, nil}

// DestroySwapchainKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySwapchainKHR.html
func DestroySwapchainKHR(device Device, swapchain SwapchainKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroySwapchainKHR.fnHandle == nil {
		vkDestroySwapchainKHR.fnHandle = dlHandle.NewProc("vkDestroySwapchainKHR")
	}
	syscall.SyscallN(vkDestroySwapchainKHR.fnHandle.Addr(), uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroySwapchainKHR = &vkCommand{"vkDestroySwapchainKHR", 3, true, nil}

// DestroyValidationCacheEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyValidationCacheEXT.html
func DestroyValidationCacheEXT(device Device, validationCache ValidationCacheEXT, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkDestroyValidationCacheEXT.fnHandle == nil {
		vkDestroyValidationCacheEXT.fnHandle = dlHandle.NewProc("vkDestroyValidationCacheEXT")
	}
	syscall.SyscallN(vkDestroyValidationCacheEXT.fnHandle.Addr(), uintptr(device), uintptr(validationCache), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyValidationCacheEXT = &vkCommand{"vkDestroyValidationCacheEXT", 3, true, nil}

// DeviceWaitIdle: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDeviceWaitIdle.html
func DeviceWaitIdle(device Device) (r error) {
	var rsys uintptr

	if vkDeviceWaitIdle.fnHandle == nil {
		vkDeviceWaitIdle.fnHandle = dlHandle.NewProc("vkDeviceWaitIdle")
	}
	rsys, _, _ = syscall.SyscallN(vkDeviceWaitIdle.fnHandle.Addr(), uintptr(device))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkDeviceWaitIdle = &vkCommand{"vkDeviceWaitIdle", 1, true, nil}

// DisplayPowerControlEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDisplayPowerControlEXT.html
func DisplayPowerControlEXT(device Device, display DisplayKHR, displayPowerInfo *DisplayPowerInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - displayPowerInfo
	var pDisplayPowerInfo *_vkDisplayPowerInfoEXT
	if displayPowerInfo != nil {
		pDisplayPowerInfo = displayPowerInfo.Vulkanize()
	}

	var rsys uintptr

	if vkDisplayPowerControlEXT.fnHandle == nil {
		vkDisplayPowerControlEXT.fnHandle = dlHandle.NewProc("vkDisplayPowerControlEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkDisplayPowerControlEXT.fnHandle.Addr(), uintptr(device), uintptr(display), uintptr(unsafe.Pointer(pDisplayPowerInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkDisplayPowerControlEXT = &vkCommand{"vkDisplayPowerControlEXT", 3, true, nil}

// EndCommandBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEndCommandBuffer.html
func EndCommandBuffer(commandBuffer CommandBuffer) (r error) {
	var rsys uintptr

	if vkEndCommandBuffer.fnHandle == nil {
		vkEndCommandBuffer.fnHandle = dlHandle.NewProc("vkEndCommandBuffer")
	}
	rsys, _, _ = syscall.SyscallN(vkEndCommandBuffer.fnHandle.Addr(), uintptr(commandBuffer))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEndCommandBuffer = &vkCommand{"vkEndCommandBuffer", 1, true, nil}

// EnumerateDeviceExtensionProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateDeviceExtensionProperties.html
func EnumerateDeviceExtensionProperties(physicalDevice PhysicalDevice, layerName string) (properties []ExtensionProperties, r error) {
	// Parameter is a singular input, requires translation - layerName
	var pLayerName *byte
	if layerName != "" {
		pLayerName = sys_stringToBytePointer(layerName)
	}

	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkExtensionProperties
	var rsys uintptr

	if vkEnumerateDeviceExtensionProperties.fnHandle == nil {
		vkEnumerateDeviceExtensionProperties.fnHandle = dlHandle.NewProc("vkEnumerateDeviceExtensionProperties")
	}
	rsys, _, _ = syscall.SyscallN(vkEnumerateDeviceExtensionProperties.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pLayerName)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	sl_pProperties := make([]_vkExtensionProperties, propertyCount)
	properties = make([]ExtensionProperties, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	if vkEnumerateDeviceExtensionProperties.fnHandle == nil {
		vkEnumerateDeviceExtensionProperties.fnHandle = dlHandle.NewProc("vkEnumerateDeviceExtensionProperties")
	}
	rsys, _, _ = syscall.SyscallN(vkEnumerateDeviceExtensionProperties.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pLayerName)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEnumerateDeviceExtensionProperties = &vkCommand{"vkEnumerateDeviceExtensionProperties", 4, true, nil}

// EnumerateDeviceLayerProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateDeviceLayerProperties.html
func EnumerateDeviceLayerProperties(physicalDevice PhysicalDevice) (properties []LayerProperties, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkLayerProperties
	var rsys uintptr

	if vkEnumerateDeviceLayerProperties.fnHandle == nil {
		vkEnumerateDeviceLayerProperties.fnHandle = dlHandle.NewProc("vkEnumerateDeviceLayerProperties")
	}
	rsys, _, _ = syscall.SyscallN(vkEnumerateDeviceLayerProperties.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	sl_pProperties := make([]_vkLayerProperties, propertyCount)
	properties = make([]LayerProperties, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	if vkEnumerateDeviceLayerProperties.fnHandle == nil {
		vkEnumerateDeviceLayerProperties.fnHandle = dlHandle.NewProc("vkEnumerateDeviceLayerProperties")
	}
	rsys, _, _ = syscall.SyscallN(vkEnumerateDeviceLayerProperties.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEnumerateDeviceLayerProperties = &vkCommand{"vkEnumerateDeviceLayerProperties", 3, true, nil}

// EnumerateInstanceExtensionProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html
func EnumerateInstanceExtensionProperties(layerName string) (properties []ExtensionProperties, r error) {
	// Parameter is a singular input, requires translation - layerName
	var pLayerName *byte
	if layerName != "" {
		pLayerName = sys_stringToBytePointer(layerName)
	}

	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkExtensionProperties
	var rsys uintptr

	if vkEnumerateInstanceExtensionProperties.fnHandle == nil {
		vkEnumerateInstanceExtensionProperties.fnHandle = dlHandle.NewProc("vkEnumerateInstanceExtensionProperties")
	}
	rsys, _, _ = syscall.SyscallN(vkEnumerateInstanceExtensionProperties.fnHandle.Addr(), uintptr(unsafe.Pointer(pLayerName)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	sl_pProperties := make([]_vkExtensionProperties, propertyCount)
	properties = make([]ExtensionProperties, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	if vkEnumerateInstanceExtensionProperties.fnHandle == nil {
		vkEnumerateInstanceExtensionProperties.fnHandle = dlHandle.NewProc("vkEnumerateInstanceExtensionProperties")
	}
	rsys, _, _ = syscall.SyscallN(vkEnumerateInstanceExtensionProperties.fnHandle.Addr(), uintptr(unsafe.Pointer(pLayerName)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEnumerateInstanceExtensionProperties = &vkCommand{"vkEnumerateInstanceExtensionProperties", 3, true, nil}

// EnumerateInstanceLayerProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceLayerProperties.html
func EnumerateInstanceLayerProperties() (properties []LayerProperties, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkLayerProperties
	var rsys uintptr

	if vkEnumerateInstanceLayerProperties.fnHandle == nil {
		vkEnumerateInstanceLayerProperties.fnHandle = dlHandle.NewProc("vkEnumerateInstanceLayerProperties")
	}
	rsys, _, _ = syscall.SyscallN(vkEnumerateInstanceLayerProperties.fnHandle.Addr(), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	sl_pProperties := make([]_vkLayerProperties, propertyCount)
	properties = make([]LayerProperties, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	if vkEnumerateInstanceLayerProperties.fnHandle == nil {
		vkEnumerateInstanceLayerProperties.fnHandle = dlHandle.NewProc("vkEnumerateInstanceLayerProperties")
	}
	rsys, _, _ = syscall.SyscallN(vkEnumerateInstanceLayerProperties.fnHandle.Addr(), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEnumerateInstanceLayerProperties = &vkCommand{"vkEnumerateInstanceLayerProperties", 2, true, nil}

// EnumerateInstanceVersion: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceVersion.html
func EnumerateInstanceVersion() (apiVersion uint32, r error) {
	// apiVersion is a binding-allocated single return value and will be populated by Vulkan
	ptr_pApiVersion := &apiVersion

	var rsys uintptr

	if vkEnumerateInstanceVersion.fnHandle == nil {
		vkEnumerateInstanceVersion.fnHandle = dlHandle.NewProc("vkEnumerateInstanceVersion")
	}
	rsys, _, _ = syscall.SyscallN(vkEnumerateInstanceVersion.fnHandle.Addr(), uintptr(unsafe.Pointer(ptr_pApiVersion)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEnumerateInstanceVersion = &vkCommand{"vkEnumerateInstanceVersion", 1, true, nil}

// EnumeratePhysicalDeviceGroups: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDeviceGroups.html
func EnumeratePhysicalDeviceGroups(instance Instance) (physicalDeviceGroupProperties []PhysicalDeviceGroupProperties, r error) {
	// physicalDeviceGroupProperties is a double-call array output
	var physicalDeviceGroupCount uint32
	pPhysicalDeviceGroupCount := &physicalDeviceGroupCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pPhysicalDeviceGroupProperties *_vkPhysicalDeviceGroupProperties
	var rsys uintptr

	if vkEnumeratePhysicalDeviceGroups.fnHandle == nil {
		vkEnumeratePhysicalDeviceGroups.fnHandle = dlHandle.NewProc("vkEnumeratePhysicalDeviceGroups")
	}
	rsys, _, _ = syscall.SyscallN(vkEnumeratePhysicalDeviceGroups.fnHandle.Addr(), uintptr(instance), uintptr(unsafe.Pointer(pPhysicalDeviceGroupCount)), uintptr(unsafe.Pointer(pPhysicalDeviceGroupProperties)))
	r = Result(rsys)

	sl_pPhysicalDeviceGroupProperties := make([]_vkPhysicalDeviceGroupProperties, physicalDeviceGroupCount)
	physicalDeviceGroupProperties = make([]PhysicalDeviceGroupProperties, physicalDeviceGroupCount)
	pPhysicalDeviceGroupProperties = &sl_pPhysicalDeviceGroupProperties[0]

	// Trampoline call after last array allocation
	if vkEnumeratePhysicalDeviceGroups.fnHandle == nil {
		vkEnumeratePhysicalDeviceGroups.fnHandle = dlHandle.NewProc("vkEnumeratePhysicalDeviceGroups")
	}
	rsys, _, _ = syscall.SyscallN(vkEnumeratePhysicalDeviceGroups.fnHandle.Addr(), uintptr(instance), uintptr(unsafe.Pointer(pPhysicalDeviceGroupCount)), uintptr(unsafe.Pointer(pPhysicalDeviceGroupProperties)))
	r = Result(rsys)

	for i := range sl_pPhysicalDeviceGroupProperties {
		physicalDeviceGroupProperties[i] = *sl_pPhysicalDeviceGroupProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEnumeratePhysicalDeviceGroups = &vkCommand{"vkEnumeratePhysicalDeviceGroups", 3, true, nil}
var EnumeratePhysicalDeviceGroupsKHR = EnumeratePhysicalDeviceGroups

// EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.html
func EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice PhysicalDevice, queueFamilyIndex uint32) (counters []PerformanceCounterKHR, counterDescriptions []PerformanceCounterDescriptionKHR, r error) {
	// counters is a double-call array output
	var counterCount uint32
	pCounterCount := &counterCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pCounters *_vkPerformanceCounterKHR
	// NOT identical internal and external, result needs translation
	var pCounterDescriptions *_vkPerformanceCounterDescriptionKHR
	var rsys uintptr

	if vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.fnHandle == nil {
		vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.fnHandle = dlHandle.NewProc("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(queueFamilyIndex), uintptr(unsafe.Pointer(pCounterCount)), uintptr(unsafe.Pointer(pCounters)), uintptr(unsafe.Pointer(pCounterDescriptions)))
	r = Result(rsys)

	sl_pCounters := make([]_vkPerformanceCounterKHR, counterCount)
	counters = make([]PerformanceCounterKHR, counterCount)
	pCounters = &sl_pCounters[0]

	sl_pCounterDescriptions := make([]_vkPerformanceCounterDescriptionKHR, counterCount)
	counterDescriptions = make([]PerformanceCounterDescriptionKHR, counterCount)
	pCounterDescriptions = &sl_pCounterDescriptions[0]

	// Trampoline call after last array allocation
	if vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.fnHandle == nil {
		vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.fnHandle = dlHandle.NewProc("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(queueFamilyIndex), uintptr(unsafe.Pointer(pCounterCount)), uintptr(unsafe.Pointer(pCounters)), uintptr(unsafe.Pointer(pCounterDescriptions)))
	r = Result(rsys)

	for i := range sl_pCounters {
		counters[i] = *sl_pCounters[i].Goify()
	}
	for i := range sl_pCounterDescriptions {
		counterDescriptions[i] = *sl_pCounterDescriptions[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = &vkCommand{"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR", 5, true, nil}

// EnumeratePhysicalDevices: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDevices.html
func EnumeratePhysicalDevices(instance Instance) (physicalDevices []PhysicalDevice, r error) {
	// physicalDevices is a double-call array output
	var physicalDeviceCount uint32
	pPhysicalDeviceCount := &physicalDeviceCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pPhysicalDevices *PhysicalDevice
	var rsys uintptr

	if vkEnumeratePhysicalDevices.fnHandle == nil {
		vkEnumeratePhysicalDevices.fnHandle = dlHandle.NewProc("vkEnumeratePhysicalDevices")
	}
	rsys, _, _ = syscall.SyscallN(vkEnumeratePhysicalDevices.fnHandle.Addr(), uintptr(instance), uintptr(unsafe.Pointer(pPhysicalDeviceCount)), uintptr(unsafe.Pointer(pPhysicalDevices)))
	r = Result(rsys)

	sl_pPhysicalDevices := make([]PhysicalDevice, physicalDeviceCount)
	physicalDevices = make([]PhysicalDevice, physicalDeviceCount)
	pPhysicalDevices = &sl_pPhysicalDevices[0]

	// Trampoline call after last array allocation
	if vkEnumeratePhysicalDevices.fnHandle == nil {
		vkEnumeratePhysicalDevices.fnHandle = dlHandle.NewProc("vkEnumeratePhysicalDevices")
	}
	rsys, _, _ = syscall.SyscallN(vkEnumeratePhysicalDevices.fnHandle.Addr(), uintptr(instance), uintptr(unsafe.Pointer(pPhysicalDeviceCount)), uintptr(unsafe.Pointer(pPhysicalDevices)))
	r = Result(rsys)

	for i := range sl_pPhysicalDevices {
		physicalDevices[i] = *&sl_pPhysicalDevices[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEnumeratePhysicalDevices = &vkCommand{"vkEnumeratePhysicalDevices", 3, true, nil}

// FlushMappedMemoryRanges: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFlushMappedMemoryRanges.html
func FlushMappedMemoryRanges(device Device, memoryRanges []MappedMemoryRange) (r error) {
	memoryRangeCount := len(memoryRanges)
	// memoryRanges is an input slice that requires translation to an internal type
	var pMemoryRanges unsafe.Pointer
	if len(memoryRanges) > 0 {
		sl_memoryRanges := make([]_vkMappedMemoryRange, memoryRangeCount)
		for i, v := range memoryRanges {
			sl_memoryRanges[i] = *(v.Vulkanize())
		}
		pMemoryRanges = unsafe.Pointer(&sl_memoryRanges[0])
	}

	var rsys uintptr

	if vkFlushMappedMemoryRanges.fnHandle == nil {
		vkFlushMappedMemoryRanges.fnHandle = dlHandle.NewProc("vkFlushMappedMemoryRanges")
	}
	rsys, _, _ = syscall.SyscallN(vkFlushMappedMemoryRanges.fnHandle.Addr(), uintptr(device), uintptr(memoryRangeCount), uintptr(unsafe.Pointer(pMemoryRanges)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkFlushMappedMemoryRanges = &vkCommand{"vkFlushMappedMemoryRanges", 3, true, nil}

// FreeCommandBuffers: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeCommandBuffers.html
func FreeCommandBuffers(device Device, commandPool CommandPool, commandBuffers []CommandBuffer) {
	commandBufferCount := len(commandBuffers)
	// commandBuffers is an input slice of values that do not need translation used
	var pCommandBuffers unsafe.Pointer
	if commandBuffers != nil {
		pCommandBuffers = unsafe.Pointer(&commandBuffers[0])
	}

	if vkFreeCommandBuffers.fnHandle == nil {
		vkFreeCommandBuffers.fnHandle = dlHandle.NewProc("vkFreeCommandBuffers")
	}
	syscall.SyscallN(vkFreeCommandBuffers.fnHandle.Addr(), uintptr(device), uintptr(commandPool), uintptr(commandBufferCount), uintptr(unsafe.Pointer(pCommandBuffers)))

}

var vkFreeCommandBuffers = &vkCommand{"vkFreeCommandBuffers", 4, true, nil}

// FreeDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeDescriptorSets.html
func FreeDescriptorSets(device Device, descriptorPool DescriptorPool, descriptorSets []DescriptorSet) (r error) {
	descriptorSetCount := len(descriptorSets)
	// descriptorSets is an input slice of values that do not need translation used
	var pDescriptorSets unsafe.Pointer
	if descriptorSets != nil {
		pDescriptorSets = unsafe.Pointer(&descriptorSets[0])
	}

	var rsys uintptr

	if vkFreeDescriptorSets.fnHandle == nil {
		vkFreeDescriptorSets.fnHandle = dlHandle.NewProc("vkFreeDescriptorSets")
	}
	rsys, _, _ = syscall.SyscallN(vkFreeDescriptorSets.fnHandle.Addr(), uintptr(device), uintptr(descriptorPool), uintptr(descriptorSetCount), uintptr(unsafe.Pointer(pDescriptorSets)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkFreeDescriptorSets = &vkCommand{"vkFreeDescriptorSets", 4, true, nil}

// FreeMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeMemory.html
func FreeMemory(device Device, memory DeviceMemory, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	if vkFreeMemory.fnHandle == nil {
		vkFreeMemory.fnHandle = dlHandle.NewProc("vkFreeMemory")
	}
	syscall.SyscallN(vkFreeMemory.fnHandle.Addr(), uintptr(device), uintptr(memory), uintptr(unsafe.Pointer(pAllocator)))

}

var vkFreeMemory = &vkCommand{"vkFreeMemory", 3, true, nil}

// GetAccelerationStructureBuildSizesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureBuildSizesKHR.html
func GetAccelerationStructureBuildSizesKHR(device Device, buildType AccelerationStructureBuildTypeKHR, buildInfo *AccelerationStructureBuildGeometryInfoKHR, maxPrimitiveCounts []uint32) (sizeInfo AccelerationStructureBuildSizesInfoKHR) {
	// Parameter is a singular input, requires translation - buildInfo
	var pBuildInfo *_vkAccelerationStructureBuildGeometryInfoKHR
	if buildInfo != nil {
		pBuildInfo = buildInfo.Vulkanize()
	}

	// maxPrimitiveCounts is an input slice that requires translation to an internal type; length is embedded in pBuildInfo
	pMaxPrimitiveCounts := unsafe.Pointer(nil)
	// WARNING TODO - passing nil pointer to get to a version that will compile. THIS VULKAN CALL WILL FAIL!// sizeInfo is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSizeInfo *_vkAccelerationStructureBuildSizesInfoKHR = sizeInfo.Vulkanize()

	if vkGetAccelerationStructureBuildSizesKHR.fnHandle == nil {
		vkGetAccelerationStructureBuildSizesKHR.fnHandle = dlHandle.NewProc("vkGetAccelerationStructureBuildSizesKHR")
	}
	syscall.SyscallN(vkGetAccelerationStructureBuildSizesKHR.fnHandle.Addr(), uintptr(device), uintptr(buildType), uintptr(unsafe.Pointer(pBuildInfo)), uintptr(unsafe.Pointer(pMaxPrimitiveCounts)), uintptr(unsafe.Pointer(pSizeInfo)))

	sizeInfo = *(pSizeInfo.Goify())
	return
}

var vkGetAccelerationStructureBuildSizesKHR = &vkCommand{"vkGetAccelerationStructureBuildSizesKHR", 5, true, nil}

// GetAccelerationStructureDeviceAddressKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureDeviceAddressKHR.html
func GetAccelerationStructureDeviceAddressKHR(device Device, info *AccelerationStructureDeviceAddressInfoKHR) (deviceAddress DeviceAddress) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkAccelerationStructureDeviceAddressInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	var rsys uintptr

	if vkGetAccelerationStructureDeviceAddressKHR.fnHandle == nil {
		vkGetAccelerationStructureDeviceAddressKHR.fnHandle = dlHandle.NewProc("vkGetAccelerationStructureDeviceAddressKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetAccelerationStructureDeviceAddressKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInfo)))
	deviceAddress = DeviceAddress(rsys)

	return
}

var vkGetAccelerationStructureDeviceAddressKHR = &vkCommand{"vkGetAccelerationStructureDeviceAddressKHR", 2, true, nil}

// GetAccelerationStructureHandleNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureHandleNV.html
func GetAccelerationStructureHandleNV(device Device, accelerationStructure AccelerationStructureNV, data []byte) (r error) {
	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	var rsys uintptr

	if vkGetAccelerationStructureHandleNV.fnHandle == nil {
		vkGetAccelerationStructureHandleNV.fnHandle = dlHandle.NewProc("vkGetAccelerationStructureHandleNV")
	}
	rsys, _, _ = syscall.SyscallN(vkGetAccelerationStructureHandleNV.fnHandle.Addr(), uintptr(device), uintptr(accelerationStructure), uintptr(dataSize), uintptr(unsafe.Pointer(pData)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetAccelerationStructureHandleNV = &vkCommand{"vkGetAccelerationStructureHandleNV", 4, true, nil}

// GetAccelerationStructureMemoryRequirementsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureMemoryRequirementsNV.html
func GetAccelerationStructureMemoryRequirementsNV(device Device, info *AccelerationStructureMemoryRequirementsInfoNV) (memoryRequirements MemoryRequirements2KHR) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkAccelerationStructureMemoryRequirementsInfoNV
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMemoryRequirements := &memoryRequirements

	if vkGetAccelerationStructureMemoryRequirementsNV.fnHandle == nil {
		vkGetAccelerationStructureMemoryRequirementsNV.fnHandle = dlHandle.NewProc("vkGetAccelerationStructureMemoryRequirementsNV")
	}
	syscall.SyscallN(vkGetAccelerationStructureMemoryRequirementsNV.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(ptr_pMemoryRequirements)))

	return
}

var vkGetAccelerationStructureMemoryRequirementsNV = &vkCommand{"vkGetAccelerationStructureMemoryRequirementsNV", 3, true, nil}

// GetBufferDeviceAddress: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferDeviceAddress.html
func GetBufferDeviceAddress(device Device, info *BufferDeviceAddressInfo) (deviceAddress DeviceAddress) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkBufferDeviceAddressInfo
	if info != nil {
		pInfo = info.Vulkanize()
	}

	var rsys uintptr

	if vkGetBufferDeviceAddress.fnHandle == nil {
		vkGetBufferDeviceAddress.fnHandle = dlHandle.NewProc("vkGetBufferDeviceAddress")
	}
	rsys, _, _ = syscall.SyscallN(vkGetBufferDeviceAddress.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInfo)))
	deviceAddress = DeviceAddress(rsys)

	return
}

var vkGetBufferDeviceAddress = &vkCommand{"vkGetBufferDeviceAddress", 2, true, nil}
var GetBufferDeviceAddressEXT = GetBufferDeviceAddress

var GetBufferDeviceAddressKHR = GetBufferDeviceAddress

// GetBufferMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements.html
func GetBufferMemoryRequirements(device Device, buffer Buffer) (memoryRequirements MemoryRequirements) {
	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMemoryRequirements := &memoryRequirements

	if vkGetBufferMemoryRequirements.fnHandle == nil {
		vkGetBufferMemoryRequirements.fnHandle = dlHandle.NewProc("vkGetBufferMemoryRequirements")
	}
	syscall.SyscallN(vkGetBufferMemoryRequirements.fnHandle.Addr(), uintptr(device), uintptr(buffer), uintptr(unsafe.Pointer(ptr_pMemoryRequirements)))

	return
}

var vkGetBufferMemoryRequirements = &vkCommand{"vkGetBufferMemoryRequirements", 3, true, nil}

// GetBufferMemoryRequirements2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements2.html
func GetBufferMemoryRequirements2(device Device, info *BufferMemoryRequirementsInfo2) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkBufferMemoryRequirementsInfo2
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryRequirements *_vkMemoryRequirements2 = memoryRequirements.Vulkanize()

	if vkGetBufferMemoryRequirements2.fnHandle == nil {
		vkGetBufferMemoryRequirements2.fnHandle = dlHandle.NewProc("vkGetBufferMemoryRequirements2")
	}
	syscall.SyscallN(vkGetBufferMemoryRequirements2.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pMemoryRequirements)))

	memoryRequirements = *(pMemoryRequirements.Goify())
	return
}

var vkGetBufferMemoryRequirements2 = &vkCommand{"vkGetBufferMemoryRequirements2", 3, true, nil}
var GetBufferMemoryRequirements2KHR = GetBufferMemoryRequirements2

// GetBufferOpaqueCaptureAddress: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferOpaqueCaptureAddress.html
func GetBufferOpaqueCaptureAddress(device Device, info *BufferDeviceAddressInfo) (r uint64) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkBufferDeviceAddressInfo
	if info != nil {
		pInfo = info.Vulkanize()
	}

	var rsys uintptr

	if vkGetBufferOpaqueCaptureAddress.fnHandle == nil {
		vkGetBufferOpaqueCaptureAddress.fnHandle = dlHandle.NewProc("vkGetBufferOpaqueCaptureAddress")
	}
	rsys, _, _ = syscall.SyscallN(vkGetBufferOpaqueCaptureAddress.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInfo)))
	r = uint64(rsys)

	return
}

var vkGetBufferOpaqueCaptureAddress = &vkCommand{"vkGetBufferOpaqueCaptureAddress", 2, true, nil}
var GetBufferOpaqueCaptureAddressKHR = GetBufferOpaqueCaptureAddress

// GetCalibratedTimestampsEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetCalibratedTimestampsEXT.html
func GetCalibratedTimestampsEXT(device Device, timestampInfos []CalibratedTimestampInfoEXT) (timestamps []uint64, maxDeviation uint64, r error) {
	timestampCount := len(timestampInfos)
	// timestampInfos is an input slice that requires translation to an internal type
	var pTimestampInfos unsafe.Pointer
	if len(timestampInfos) > 0 {
		sl_timestampInfos := make([]_vkCalibratedTimestampInfoEXT, timestampCount)
		for i, v := range timestampInfos {
			sl_timestampInfos[i] = *(v.Vulkanize())
		}
		pTimestampInfos = unsafe.Pointer(&sl_timestampInfos[0])
	}

	// timestamps is an output array that will be allocated by the binding, len is from timestampCount
	timestamps = make([]uint64, timestampCount)
	pTimestamps := unsafe.Pointer(&timestamps[0])

	// maxDeviation is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMaxDeviation := &maxDeviation

	var rsys uintptr

	if vkGetCalibratedTimestampsEXT.fnHandle == nil {
		vkGetCalibratedTimestampsEXT.fnHandle = dlHandle.NewProc("vkGetCalibratedTimestampsEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkGetCalibratedTimestampsEXT.fnHandle.Addr(), uintptr(device), uintptr(timestampCount), uintptr(unsafe.Pointer(pTimestampInfos)), uintptr(unsafe.Pointer(pTimestamps)), uintptr(unsafe.Pointer(ptr_pMaxDeviation)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetCalibratedTimestampsEXT = &vkCommand{"vkGetCalibratedTimestampsEXT", 5, true, nil}

// GetDeferredOperationMaxConcurrencyKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeferredOperationMaxConcurrencyKHR.html
func GetDeferredOperationMaxConcurrencyKHR(device Device, operation DeferredOperationKHR) (r uint32) {
	var rsys uintptr

	if vkGetDeferredOperationMaxConcurrencyKHR.fnHandle == nil {
		vkGetDeferredOperationMaxConcurrencyKHR.fnHandle = dlHandle.NewProc("vkGetDeferredOperationMaxConcurrencyKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDeferredOperationMaxConcurrencyKHR.fnHandle.Addr(), uintptr(device), uintptr(operation))
	r = uint32(rsys)

	return
}

var vkGetDeferredOperationMaxConcurrencyKHR = &vkCommand{"vkGetDeferredOperationMaxConcurrencyKHR", 2, true, nil}

// GetDeferredOperationResultKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeferredOperationResultKHR.html
func GetDeferredOperationResultKHR(device Device, operation DeferredOperationKHR) (r error) {
	var rsys uintptr

	if vkGetDeferredOperationResultKHR.fnHandle == nil {
		vkGetDeferredOperationResultKHR.fnHandle = dlHandle.NewProc("vkGetDeferredOperationResultKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDeferredOperationResultKHR.fnHandle.Addr(), uintptr(device), uintptr(operation))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDeferredOperationResultKHR = &vkCommand{"vkGetDeferredOperationResultKHR", 2, true, nil}

// GetDescriptorSetLayoutSupport: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutSupport.html
func GetDescriptorSetLayoutSupport(device Device, createInfo *DescriptorSetLayoutCreateInfo) (support DescriptorSetLayoutSupport) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDescriptorSetLayoutCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// support is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSupport *_vkDescriptorSetLayoutSupport = support.Vulkanize()

	if vkGetDescriptorSetLayoutSupport.fnHandle == nil {
		vkGetDescriptorSetLayoutSupport.fnHandle = dlHandle.NewProc("vkGetDescriptorSetLayoutSupport")
	}
	syscall.SyscallN(vkGetDescriptorSetLayoutSupport.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pSupport)))

	support = *(pSupport.Goify())
	return
}

var vkGetDescriptorSetLayoutSupport = &vkCommand{"vkGetDescriptorSetLayoutSupport", 3, true, nil}
var GetDescriptorSetLayoutSupportKHR = GetDescriptorSetLayoutSupport

// GetDeviceAccelerationStructureCompatibilityKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceAccelerationStructureCompatibilityKHR.html
func GetDeviceAccelerationStructureCompatibilityKHR(device Device, versionInfo *AccelerationStructureVersionInfoKHR) (compatibility AccelerationStructureCompatibilityKHR) {
	// Parameter is a singular input, requires translation - versionInfo
	var pVersionInfo *_vkAccelerationStructureVersionInfoKHR
	if versionInfo != nil {
		pVersionInfo = versionInfo.Vulkanize()
	}

	// compatibility is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCompatibility := &compatibility

	if vkGetDeviceAccelerationStructureCompatibilityKHR.fnHandle == nil {
		vkGetDeviceAccelerationStructureCompatibilityKHR.fnHandle = dlHandle.NewProc("vkGetDeviceAccelerationStructureCompatibilityKHR")
	}
	syscall.SyscallN(vkGetDeviceAccelerationStructureCompatibilityKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pVersionInfo)), uintptr(unsafe.Pointer(ptr_pCompatibility)))

	return
}

var vkGetDeviceAccelerationStructureCompatibilityKHR = &vkCommand{"vkGetDeviceAccelerationStructureCompatibilityKHR", 3, true, nil}

// GetDeviceBufferMemoryRequirementsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceBufferMemoryRequirementsKHR.html
func GetDeviceBufferMemoryRequirementsKHR(device Device, info *DeviceBufferMemoryRequirementsKHR) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkDeviceBufferMemoryRequirementsKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryRequirements *_vkMemoryRequirements2 = memoryRequirements.Vulkanize()

	if vkGetDeviceBufferMemoryRequirementsKHR.fnHandle == nil {
		vkGetDeviceBufferMemoryRequirementsKHR.fnHandle = dlHandle.NewProc("vkGetDeviceBufferMemoryRequirementsKHR")
	}
	syscall.SyscallN(vkGetDeviceBufferMemoryRequirementsKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pMemoryRequirements)))

	memoryRequirements = *(pMemoryRequirements.Goify())
	return
}

var vkGetDeviceBufferMemoryRequirementsKHR = &vkCommand{"vkGetDeviceBufferMemoryRequirementsKHR", 3, true, nil}

// GetDeviceGroupPeerMemoryFeatures: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupPeerMemoryFeatures.html
func GetDeviceGroupPeerMemoryFeatures(device Device, heapIndex uint32, localDeviceIndex uint32, remoteDeviceIndex uint32) (peerMemoryFeatures PeerMemoryFeatureFlags) {
	// peerMemoryFeatures is a binding-allocated single return value and will be populated by Vulkan
	ptr_pPeerMemoryFeatures := &peerMemoryFeatures

	if vkGetDeviceGroupPeerMemoryFeatures.fnHandle == nil {
		vkGetDeviceGroupPeerMemoryFeatures.fnHandle = dlHandle.NewProc("vkGetDeviceGroupPeerMemoryFeatures")
	}
	syscall.SyscallN(vkGetDeviceGroupPeerMemoryFeatures.fnHandle.Addr(), uintptr(device), uintptr(heapIndex), uintptr(localDeviceIndex), uintptr(remoteDeviceIndex), uintptr(unsafe.Pointer(ptr_pPeerMemoryFeatures)))

	return
}

var vkGetDeviceGroupPeerMemoryFeatures = &vkCommand{"vkGetDeviceGroupPeerMemoryFeatures", 5, true, nil}
var GetDeviceGroupPeerMemoryFeaturesKHR = GetDeviceGroupPeerMemoryFeatures

// GetDeviceGroupPresentCapabilitiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupPresentCapabilitiesKHR.html
func GetDeviceGroupPresentCapabilitiesKHR(device Device) (deviceGroupPresentCapabilities DeviceGroupPresentCapabilitiesKHR, r error) {
	// deviceGroupPresentCapabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pDeviceGroupPresentCapabilities *_vkDeviceGroupPresentCapabilitiesKHR = deviceGroupPresentCapabilities.Vulkanize()

	var rsys uintptr

	if vkGetDeviceGroupPresentCapabilitiesKHR.fnHandle == nil {
		vkGetDeviceGroupPresentCapabilitiesKHR.fnHandle = dlHandle.NewProc("vkGetDeviceGroupPresentCapabilitiesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDeviceGroupPresentCapabilitiesKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pDeviceGroupPresentCapabilities)))
	r = Result(rsys)

	deviceGroupPresentCapabilities = *(pDeviceGroupPresentCapabilities.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDeviceGroupPresentCapabilitiesKHR = &vkCommand{"vkGetDeviceGroupPresentCapabilitiesKHR", 2, true, nil}

// GetDeviceGroupSurfacePresentModesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupSurfacePresentModesKHR.html
func GetDeviceGroupSurfacePresentModesKHR(device Device, surface SurfaceKHR) (modes DeviceGroupPresentModeFlagsKHR, r error) {
	// modes is a binding-allocated single return value and will be populated by Vulkan
	ptr_pModes := &modes

	var rsys uintptr

	if vkGetDeviceGroupSurfacePresentModesKHR.fnHandle == nil {
		vkGetDeviceGroupSurfacePresentModesKHR.fnHandle = dlHandle.NewProc("vkGetDeviceGroupSurfacePresentModesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDeviceGroupSurfacePresentModesKHR.fnHandle.Addr(), uintptr(device), uintptr(surface), uintptr(unsafe.Pointer(ptr_pModes)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDeviceGroupSurfacePresentModesKHR = &vkCommand{"vkGetDeviceGroupSurfacePresentModesKHR", 3, true, nil}

// GetDeviceImageMemoryRequirementsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageMemoryRequirementsKHR.html
func GetDeviceImageMemoryRequirementsKHR(device Device, info *DeviceImageMemoryRequirementsKHR) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkDeviceImageMemoryRequirementsKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryRequirements *_vkMemoryRequirements2 = memoryRequirements.Vulkanize()

	if vkGetDeviceImageMemoryRequirementsKHR.fnHandle == nil {
		vkGetDeviceImageMemoryRequirementsKHR.fnHandle = dlHandle.NewProc("vkGetDeviceImageMemoryRequirementsKHR")
	}
	syscall.SyscallN(vkGetDeviceImageMemoryRequirementsKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pMemoryRequirements)))

	memoryRequirements = *(pMemoryRequirements.Goify())
	return
}

var vkGetDeviceImageMemoryRequirementsKHR = &vkCommand{"vkGetDeviceImageMemoryRequirementsKHR", 3, true, nil}

// GetDeviceImageSparseMemoryRequirementsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageSparseMemoryRequirementsKHR.html
func GetDeviceImageSparseMemoryRequirementsKHR(device Device, info *DeviceImageMemoryRequirementsKHR) (sparseMemoryRequirements []SparseImageMemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkDeviceImageMemoryRequirementsKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// sparseMemoryRequirements is a double-call array output
	var sparseMemoryRequirementCount uint32
	pSparseMemoryRequirementCount := &sparseMemoryRequirementCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSparseMemoryRequirements *_vkSparseImageMemoryRequirements2

	if vkGetDeviceImageSparseMemoryRequirementsKHR.fnHandle == nil {
		vkGetDeviceImageSparseMemoryRequirementsKHR.fnHandle = dlHandle.NewProc("vkGetDeviceImageSparseMemoryRequirementsKHR")
	}
	syscall.SyscallN(vkGetDeviceImageSparseMemoryRequirementsKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	sl_pSparseMemoryRequirements := make([]_vkSparseImageMemoryRequirements2, sparseMemoryRequirementCount)
	sparseMemoryRequirements = make([]SparseImageMemoryRequirements2, sparseMemoryRequirementCount)
	pSparseMemoryRequirements = &sl_pSparseMemoryRequirements[0]

	// Trampoline call after last array allocation
	if vkGetDeviceImageSparseMemoryRequirementsKHR.fnHandle == nil {
		vkGetDeviceImageSparseMemoryRequirementsKHR.fnHandle = dlHandle.NewProc("vkGetDeviceImageSparseMemoryRequirementsKHR")
	}
	syscall.SyscallN(vkGetDeviceImageSparseMemoryRequirementsKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	for i := range sl_pSparseMemoryRequirements {
		sparseMemoryRequirements[i] = *sl_pSparseMemoryRequirements[i].Goify()
	}
	return
}

var vkGetDeviceImageSparseMemoryRequirementsKHR = &vkCommand{"vkGetDeviceImageSparseMemoryRequirementsKHR", 4, true, nil}

// GetDeviceMemoryCommitment: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMemoryCommitment.html
func GetDeviceMemoryCommitment(device Device, memory DeviceMemory) (committedMemoryInBytes DeviceSize) {
	// committedMemoryInBytes is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCommittedMemoryInBytes := &committedMemoryInBytes

	if vkGetDeviceMemoryCommitment.fnHandle == nil {
		vkGetDeviceMemoryCommitment.fnHandle = dlHandle.NewProc("vkGetDeviceMemoryCommitment")
	}
	syscall.SyscallN(vkGetDeviceMemoryCommitment.fnHandle.Addr(), uintptr(device), uintptr(memory), uintptr(unsafe.Pointer(ptr_pCommittedMemoryInBytes)))

	return
}

var vkGetDeviceMemoryCommitment = &vkCommand{"vkGetDeviceMemoryCommitment", 3, true, nil}

// GetDeviceMemoryOpaqueCaptureAddress: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMemoryOpaqueCaptureAddress.html
func GetDeviceMemoryOpaqueCaptureAddress(device Device, info *DeviceMemoryOpaqueCaptureAddressInfo) (r uint64) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkDeviceMemoryOpaqueCaptureAddressInfo
	if info != nil {
		pInfo = info.Vulkanize()
	}

	var rsys uintptr

	if vkGetDeviceMemoryOpaqueCaptureAddress.fnHandle == nil {
		vkGetDeviceMemoryOpaqueCaptureAddress.fnHandle = dlHandle.NewProc("vkGetDeviceMemoryOpaqueCaptureAddress")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDeviceMemoryOpaqueCaptureAddress.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInfo)))
	r = uint64(rsys)

	return
}

var vkGetDeviceMemoryOpaqueCaptureAddress = &vkCommand{"vkGetDeviceMemoryOpaqueCaptureAddress", 2, true, nil}
var GetDeviceMemoryOpaqueCaptureAddressKHR = GetDeviceMemoryOpaqueCaptureAddress

// GetDeviceProcAddr: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceProcAddr.html
func GetDeviceProcAddr(device Device, name string) (fn PFN_vkVoidFunction) {
	// Parameter is a singular input, requires translation - name
	var pName *byte
	if name != "" {
		pName = sys_stringToBytePointer(name)
	}

	var rsys uintptr

	if vkGetDeviceProcAddr.fnHandle == nil {
		vkGetDeviceProcAddr.fnHandle = dlHandle.NewProc("vkGetDeviceProcAddr")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDeviceProcAddr.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pName)))
	fn = PFN_vkVoidFunction(rsys)

	return
}

var vkGetDeviceProcAddr = &vkCommand{"vkGetDeviceProcAddr", 2, true, nil}

// GetDeviceQueue: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html
func GetDeviceQueue(device Device, queueFamilyIndex uint32, queueIndex uint32) (queue Queue) {
	// queue is a binding-allocated single return value and will be populated by Vulkan
	ptr_pQueue := &queue

	if vkGetDeviceQueue.fnHandle == nil {
		vkGetDeviceQueue.fnHandle = dlHandle.NewProc("vkGetDeviceQueue")
	}
	syscall.SyscallN(vkGetDeviceQueue.fnHandle.Addr(), uintptr(device), uintptr(queueFamilyIndex), uintptr(queueIndex), uintptr(unsafe.Pointer(ptr_pQueue)))

	return
}

var vkGetDeviceQueue = &vkCommand{"vkGetDeviceQueue", 4, true, nil}

// GetDeviceQueue2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue2.html
func GetDeviceQueue2(device Device, queueInfo *DeviceQueueInfo2) (queue Queue) {
	// Parameter is a singular input, requires translation - queueInfo
	var pQueueInfo *_vkDeviceQueueInfo2
	if queueInfo != nil {
		pQueueInfo = queueInfo.Vulkanize()
	}

	// queue is a binding-allocated single return value and will be populated by Vulkan
	ptr_pQueue := &queue

	if vkGetDeviceQueue2.fnHandle == nil {
		vkGetDeviceQueue2.fnHandle = dlHandle.NewProc("vkGetDeviceQueue2")
	}
	syscall.SyscallN(vkGetDeviceQueue2.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pQueueInfo)), uintptr(unsafe.Pointer(ptr_pQueue)))

	return
}

var vkGetDeviceQueue2 = &vkCommand{"vkGetDeviceQueue2", 3, true, nil}

// GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.html
func GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(device Device, renderpass RenderPass) (maxWorkgroupSize Extent2D, r error) {
	// maxWorkgroupSize is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMaxWorkgroupSize := &maxWorkgroupSize

	var rsys uintptr

	if vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.fnHandle == nil {
		vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.fnHandle = dlHandle.NewProc("vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.fnHandle.Addr(), uintptr(device), uintptr(renderpass), uintptr(unsafe.Pointer(ptr_pMaxWorkgroupSize)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = &vkCommand{"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI", 3, true, nil}

// GetDisplayModeProperties2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayModeProperties2KHR.html
func GetDisplayModeProperties2KHR(physicalDevice PhysicalDevice, display DisplayKHR) (properties []DisplayModeProperties2KHR, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayModeProperties2KHR
	var rsys uintptr

	if vkGetDisplayModeProperties2KHR.fnHandle == nil {
		vkGetDisplayModeProperties2KHR.fnHandle = dlHandle.NewProc("vkGetDisplayModeProperties2KHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDisplayModeProperties2KHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(display), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	sl_pProperties := make([]_vkDisplayModeProperties2KHR, propertyCount)
	properties = make([]DisplayModeProperties2KHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	if vkGetDisplayModeProperties2KHR.fnHandle == nil {
		vkGetDisplayModeProperties2KHR.fnHandle = dlHandle.NewProc("vkGetDisplayModeProperties2KHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDisplayModeProperties2KHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(display), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDisplayModeProperties2KHR = &vkCommand{"vkGetDisplayModeProperties2KHR", 4, true, nil}

// GetDisplayModePropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayModePropertiesKHR.html
func GetDisplayModePropertiesKHR(physicalDevice PhysicalDevice, display DisplayKHR) (properties []DisplayModePropertiesKHR, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayModePropertiesKHR
	var rsys uintptr

	if vkGetDisplayModePropertiesKHR.fnHandle == nil {
		vkGetDisplayModePropertiesKHR.fnHandle = dlHandle.NewProc("vkGetDisplayModePropertiesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDisplayModePropertiesKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(display), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	sl_pProperties := make([]_vkDisplayModePropertiesKHR, propertyCount)
	properties = make([]DisplayModePropertiesKHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	if vkGetDisplayModePropertiesKHR.fnHandle == nil {
		vkGetDisplayModePropertiesKHR.fnHandle = dlHandle.NewProc("vkGetDisplayModePropertiesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDisplayModePropertiesKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(display), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDisplayModePropertiesKHR = &vkCommand{"vkGetDisplayModePropertiesKHR", 4, true, nil}

// GetDisplayPlaneCapabilities2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneCapabilities2KHR.html
func GetDisplayPlaneCapabilities2KHR(physicalDevice PhysicalDevice, displayPlaneInfo *DisplayPlaneInfo2KHR) (capabilities DisplayPlaneCapabilities2KHR, r error) {
	// Parameter is a singular input, requires translation - displayPlaneInfo
	var pDisplayPlaneInfo *_vkDisplayPlaneInfo2KHR
	if displayPlaneInfo != nil {
		pDisplayPlaneInfo = displayPlaneInfo.Vulkanize()
	}

	// capabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pCapabilities *_vkDisplayPlaneCapabilities2KHR = capabilities.Vulkanize()

	var rsys uintptr

	if vkGetDisplayPlaneCapabilities2KHR.fnHandle == nil {
		vkGetDisplayPlaneCapabilities2KHR.fnHandle = dlHandle.NewProc("vkGetDisplayPlaneCapabilities2KHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDisplayPlaneCapabilities2KHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pDisplayPlaneInfo)), uintptr(unsafe.Pointer(pCapabilities)))
	r = Result(rsys)

	capabilities = *(pCapabilities.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDisplayPlaneCapabilities2KHR = &vkCommand{"vkGetDisplayPlaneCapabilities2KHR", 3, true, nil}

// GetDisplayPlaneCapabilitiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneCapabilitiesKHR.html
func GetDisplayPlaneCapabilitiesKHR(physicalDevice PhysicalDevice, mode DisplayModeKHR, planeIndex uint32) (capabilities DisplayPlaneCapabilitiesKHR, r error) {
	// capabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pCapabilities *_vkDisplayPlaneCapabilitiesKHR = capabilities.Vulkanize()

	var rsys uintptr

	if vkGetDisplayPlaneCapabilitiesKHR.fnHandle == nil {
		vkGetDisplayPlaneCapabilitiesKHR.fnHandle = dlHandle.NewProc("vkGetDisplayPlaneCapabilitiesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDisplayPlaneCapabilitiesKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(mode), uintptr(planeIndex), uintptr(unsafe.Pointer(pCapabilities)))
	r = Result(rsys)

	capabilities = *(pCapabilities.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDisplayPlaneCapabilitiesKHR = &vkCommand{"vkGetDisplayPlaneCapabilitiesKHR", 4, true, nil}

// GetDisplayPlaneSupportedDisplaysKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneSupportedDisplaysKHR.html
func GetDisplayPlaneSupportedDisplaysKHR(physicalDevice PhysicalDevice, planeIndex uint32) (displays []DisplayKHR, r error) {
	// displays is a double-call array output
	var displayCount uint32
	pDisplayCount := &displayCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pDisplays *DisplayKHR
	var rsys uintptr

	if vkGetDisplayPlaneSupportedDisplaysKHR.fnHandle == nil {
		vkGetDisplayPlaneSupportedDisplaysKHR.fnHandle = dlHandle.NewProc("vkGetDisplayPlaneSupportedDisplaysKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDisplayPlaneSupportedDisplaysKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(planeIndex), uintptr(unsafe.Pointer(pDisplayCount)), uintptr(unsafe.Pointer(pDisplays)))
	r = Result(rsys)

	sl_pDisplays := make([]DisplayKHR, displayCount)
	displays = make([]DisplayKHR, displayCount)
	pDisplays = &sl_pDisplays[0]

	// Trampoline call after last array allocation
	if vkGetDisplayPlaneSupportedDisplaysKHR.fnHandle == nil {
		vkGetDisplayPlaneSupportedDisplaysKHR.fnHandle = dlHandle.NewProc("vkGetDisplayPlaneSupportedDisplaysKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDisplayPlaneSupportedDisplaysKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(planeIndex), uintptr(unsafe.Pointer(pDisplayCount)), uintptr(unsafe.Pointer(pDisplays)))
	r = Result(rsys)

	for i := range sl_pDisplays {
		displays[i] = *&sl_pDisplays[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDisplayPlaneSupportedDisplaysKHR = &vkCommand{"vkGetDisplayPlaneSupportedDisplaysKHR", 4, true, nil}

// GetDrmDisplayEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDrmDisplayEXT.html
func GetDrmDisplayEXT(physicalDevice PhysicalDevice, drmFd int32, connectorId uint32) (display DisplayKHR, r error) {
	// display is a binding-allocated single return value and will be populated by Vulkan
	ptr_display := &display

	var rsys uintptr

	if vkGetDrmDisplayEXT.fnHandle == nil {
		vkGetDrmDisplayEXT.fnHandle = dlHandle.NewProc("vkGetDrmDisplayEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDrmDisplayEXT.fnHandle.Addr(), uintptr(physicalDevice), uintptr(drmFd), uintptr(connectorId), uintptr(unsafe.Pointer(ptr_display)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDrmDisplayEXT = &vkCommand{"vkGetDrmDisplayEXT", 4, true, nil}

// GetEventStatus: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetEventStatus.html
func GetEventStatus(device Device, event Event) (r error) {
	var rsys uintptr

	if vkGetEventStatus.fnHandle == nil {
		vkGetEventStatus.fnHandle = dlHandle.NewProc("vkGetEventStatus")
	}
	rsys, _, _ = syscall.SyscallN(vkGetEventStatus.fnHandle.Addr(), uintptr(device), uintptr(event))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetEventStatus = &vkCommand{"vkGetEventStatus", 2, true, nil}

// GetFenceFdKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceFdKHR.html
func GetFenceFdKHR(device Device, getFdInfo *FenceGetFdInfoKHR) (fd int32, r error) {
	// Parameter is a singular input, requires translation - getFdInfo
	var pGetFdInfo *_vkFenceGetFdInfoKHR
	if getFdInfo != nil {
		pGetFdInfo = getFdInfo.Vulkanize()
	}

	// fd is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFd := &fd

	var rsys uintptr

	if vkGetFenceFdKHR.fnHandle == nil {
		vkGetFenceFdKHR.fnHandle = dlHandle.NewProc("vkGetFenceFdKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetFenceFdKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pGetFdInfo)), uintptr(unsafe.Pointer(ptr_pFd)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetFenceFdKHR = &vkCommand{"vkGetFenceFdKHR", 3, true, nil}

// GetFenceStatus: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceStatus.html
func GetFenceStatus(device Device, fence Fence) (r error) {
	var rsys uintptr

	if vkGetFenceStatus.fnHandle == nil {
		vkGetFenceStatus.fnHandle = dlHandle.NewProc("vkGetFenceStatus")
	}
	rsys, _, _ = syscall.SyscallN(vkGetFenceStatus.fnHandle.Addr(), uintptr(device), uintptr(fence))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetFenceStatus = &vkCommand{"vkGetFenceStatus", 2, true, nil}

// GetGeneratedCommandsMemoryRequirementsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetGeneratedCommandsMemoryRequirementsNV.html
func GetGeneratedCommandsMemoryRequirementsNV(device Device, info *GeneratedCommandsMemoryRequirementsInfoNV) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkGeneratedCommandsMemoryRequirementsInfoNV
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryRequirements *_vkMemoryRequirements2 = memoryRequirements.Vulkanize()

	if vkGetGeneratedCommandsMemoryRequirementsNV.fnHandle == nil {
		vkGetGeneratedCommandsMemoryRequirementsNV.fnHandle = dlHandle.NewProc("vkGetGeneratedCommandsMemoryRequirementsNV")
	}
	syscall.SyscallN(vkGetGeneratedCommandsMemoryRequirementsNV.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pMemoryRequirements)))

	memoryRequirements = *(pMemoryRequirements.Goify())
	return
}

var vkGetGeneratedCommandsMemoryRequirementsNV = &vkCommand{"vkGetGeneratedCommandsMemoryRequirementsNV", 3, true, nil}

// GetImageDrmFormatModifierPropertiesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageDrmFormatModifierPropertiesEXT.html
func GetImageDrmFormatModifierPropertiesEXT(device Device, image Image) (properties ImageDrmFormatModifierPropertiesEXT, r error) {
	// properties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pProperties *_vkImageDrmFormatModifierPropertiesEXT = properties.Vulkanize()

	var rsys uintptr

	if vkGetImageDrmFormatModifierPropertiesEXT.fnHandle == nil {
		vkGetImageDrmFormatModifierPropertiesEXT.fnHandle = dlHandle.NewProc("vkGetImageDrmFormatModifierPropertiesEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkGetImageDrmFormatModifierPropertiesEXT.fnHandle.Addr(), uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	properties = *(pProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetImageDrmFormatModifierPropertiesEXT = &vkCommand{"vkGetImageDrmFormatModifierPropertiesEXT", 3, true, nil}

// GetImageMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageMemoryRequirements.html
func GetImageMemoryRequirements(device Device, image Image) (memoryRequirements MemoryRequirements) {
	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMemoryRequirements := &memoryRequirements

	if vkGetImageMemoryRequirements.fnHandle == nil {
		vkGetImageMemoryRequirements.fnHandle = dlHandle.NewProc("vkGetImageMemoryRequirements")
	}
	syscall.SyscallN(vkGetImageMemoryRequirements.fnHandle.Addr(), uintptr(device), uintptr(image), uintptr(unsafe.Pointer(ptr_pMemoryRequirements)))

	return
}

var vkGetImageMemoryRequirements = &vkCommand{"vkGetImageMemoryRequirements", 3, true, nil}

// GetImageMemoryRequirements2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageMemoryRequirements2.html
func GetImageMemoryRequirements2(device Device, info *ImageMemoryRequirementsInfo2) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkImageMemoryRequirementsInfo2
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryRequirements *_vkMemoryRequirements2 = memoryRequirements.Vulkanize()

	if vkGetImageMemoryRequirements2.fnHandle == nil {
		vkGetImageMemoryRequirements2.fnHandle = dlHandle.NewProc("vkGetImageMemoryRequirements2")
	}
	syscall.SyscallN(vkGetImageMemoryRequirements2.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pMemoryRequirements)))

	memoryRequirements = *(pMemoryRequirements.Goify())
	return
}

var vkGetImageMemoryRequirements2 = &vkCommand{"vkGetImageMemoryRequirements2", 3, true, nil}
var GetImageMemoryRequirements2KHR = GetImageMemoryRequirements2

// GetImageSparseMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSparseMemoryRequirements.html
func GetImageSparseMemoryRequirements(device Device, image Image) (sparseMemoryRequirements []SparseImageMemoryRequirements) {
	// sparseMemoryRequirements is a double-call array output
	var sparseMemoryRequirementCount uint32
	pSparseMemoryRequirementCount := &sparseMemoryRequirementCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSparseMemoryRequirements *_vkSparseImageMemoryRequirements

	if vkGetImageSparseMemoryRequirements.fnHandle == nil {
		vkGetImageSparseMemoryRequirements.fnHandle = dlHandle.NewProc("vkGetImageSparseMemoryRequirements")
	}
	syscall.SyscallN(vkGetImageSparseMemoryRequirements.fnHandle.Addr(), uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	sl_pSparseMemoryRequirements := make([]_vkSparseImageMemoryRequirements, sparseMemoryRequirementCount)
	sparseMemoryRequirements = make([]SparseImageMemoryRequirements, sparseMemoryRequirementCount)
	pSparseMemoryRequirements = &sl_pSparseMemoryRequirements[0]

	// Trampoline call after last array allocation
	if vkGetImageSparseMemoryRequirements.fnHandle == nil {
		vkGetImageSparseMemoryRequirements.fnHandle = dlHandle.NewProc("vkGetImageSparseMemoryRequirements")
	}
	syscall.SyscallN(vkGetImageSparseMemoryRequirements.fnHandle.Addr(), uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	for i := range sl_pSparseMemoryRequirements {
		sparseMemoryRequirements[i] = *sl_pSparseMemoryRequirements[i].Goify()
	}
	return
}

var vkGetImageSparseMemoryRequirements = &vkCommand{"vkGetImageSparseMemoryRequirements", 4, true, nil}

// GetImageSparseMemoryRequirements2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSparseMemoryRequirements2.html
func GetImageSparseMemoryRequirements2(device Device, info *ImageSparseMemoryRequirementsInfo2) (sparseMemoryRequirements []SparseImageMemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkImageSparseMemoryRequirementsInfo2
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// sparseMemoryRequirements is a double-call array output
	var sparseMemoryRequirementCount uint32
	pSparseMemoryRequirementCount := &sparseMemoryRequirementCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSparseMemoryRequirements *_vkSparseImageMemoryRequirements2

	if vkGetImageSparseMemoryRequirements2.fnHandle == nil {
		vkGetImageSparseMemoryRequirements2.fnHandle = dlHandle.NewProc("vkGetImageSparseMemoryRequirements2")
	}
	syscall.SyscallN(vkGetImageSparseMemoryRequirements2.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	sl_pSparseMemoryRequirements := make([]_vkSparseImageMemoryRequirements2, sparseMemoryRequirementCount)
	sparseMemoryRequirements = make([]SparseImageMemoryRequirements2, sparseMemoryRequirementCount)
	pSparseMemoryRequirements = &sl_pSparseMemoryRequirements[0]

	// Trampoline call after last array allocation
	if vkGetImageSparseMemoryRequirements2.fnHandle == nil {
		vkGetImageSparseMemoryRequirements2.fnHandle = dlHandle.NewProc("vkGetImageSparseMemoryRequirements2")
	}
	syscall.SyscallN(vkGetImageSparseMemoryRequirements2.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	for i := range sl_pSparseMemoryRequirements {
		sparseMemoryRequirements[i] = *sl_pSparseMemoryRequirements[i].Goify()
	}
	return
}

var vkGetImageSparseMemoryRequirements2 = &vkCommand{"vkGetImageSparseMemoryRequirements2", 4, true, nil}
var GetImageSparseMemoryRequirements2KHR = GetImageSparseMemoryRequirements2

// GetImageSubresourceLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSubresourceLayout.html
func GetImageSubresourceLayout(device Device, image Image, subresource *ImageSubresource) (layout SubresourceLayout) {
	// Parameter is a singular input, pass direct - subresource
	var pSubresource unsafe.Pointer
	if subresource != nil {
		pSubresource = unsafe.Pointer(subresource)
	}

	// layout is a binding-allocated single return value and will be populated by Vulkan
	ptr_pLayout := &layout

	if vkGetImageSubresourceLayout.fnHandle == nil {
		vkGetImageSubresourceLayout.fnHandle = dlHandle.NewProc("vkGetImageSubresourceLayout")
	}
	syscall.SyscallN(vkGetImageSubresourceLayout.fnHandle.Addr(), uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pSubresource)), uintptr(unsafe.Pointer(ptr_pLayout)))

	return
}

var vkGetImageSubresourceLayout = &vkCommand{"vkGetImageSubresourceLayout", 4, true, nil}

// GetImageViewAddressNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageViewAddressNVX.html
func GetImageViewAddressNVX(device Device, imageView ImageView) (properties ImageViewAddressPropertiesNVX, r error) {
	// properties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pProperties *_vkImageViewAddressPropertiesNVX = properties.Vulkanize()

	var rsys uintptr

	if vkGetImageViewAddressNVX.fnHandle == nil {
		vkGetImageViewAddressNVX.fnHandle = dlHandle.NewProc("vkGetImageViewAddressNVX")
	}
	rsys, _, _ = syscall.SyscallN(vkGetImageViewAddressNVX.fnHandle.Addr(), uintptr(device), uintptr(imageView), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	properties = *(pProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetImageViewAddressNVX = &vkCommand{"vkGetImageViewAddressNVX", 3, true, nil}

// GetImageViewHandleNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageViewHandleNVX.html
func GetImageViewHandleNVX(device Device, info *ImageViewHandleInfoNVX) (r uint32) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkImageViewHandleInfoNVX
	if info != nil {
		pInfo = info.Vulkanize()
	}

	var rsys uintptr

	if vkGetImageViewHandleNVX.fnHandle == nil {
		vkGetImageViewHandleNVX.fnHandle = dlHandle.NewProc("vkGetImageViewHandleNVX")
	}
	rsys, _, _ = syscall.SyscallN(vkGetImageViewHandleNVX.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInfo)))
	r = uint32(rsys)

	return
}

var vkGetImageViewHandleNVX = &vkCommand{"vkGetImageViewHandleNVX", 2, true, nil}

// GetInstanceProcAddr: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetInstanceProcAddr.html
func GetInstanceProcAddr(instance Instance, name string) (fn PFN_vkVoidFunction) {
	// Parameter is a singular input, requires translation - name
	var pName *byte
	if name != "" {
		pName = sys_stringToBytePointer(name)
	}

	var rsys uintptr

	if vkGetInstanceProcAddr.fnHandle == nil {
		vkGetInstanceProcAddr.fnHandle = dlHandle.NewProc("vkGetInstanceProcAddr")
	}
	rsys, _, _ = syscall.SyscallN(vkGetInstanceProcAddr.fnHandle.Addr(), uintptr(instance), uintptr(unsafe.Pointer(pName)))
	fn = PFN_vkVoidFunction(rsys)

	return
}

var vkGetInstanceProcAddr = &vkCommand{"vkGetInstanceProcAddr", 2, true, nil}

// GetMemoryFdKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryFdKHR.html
func GetMemoryFdKHR(device Device, getFdInfo *MemoryGetFdInfoKHR) (fd int32, r error) {
	// Parameter is a singular input, requires translation - getFdInfo
	var pGetFdInfo *_vkMemoryGetFdInfoKHR
	if getFdInfo != nil {
		pGetFdInfo = getFdInfo.Vulkanize()
	}

	// fd is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFd := &fd

	var rsys uintptr

	if vkGetMemoryFdKHR.fnHandle == nil {
		vkGetMemoryFdKHR.fnHandle = dlHandle.NewProc("vkGetMemoryFdKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetMemoryFdKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pGetFdInfo)), uintptr(unsafe.Pointer(ptr_pFd)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetMemoryFdKHR = &vkCommand{"vkGetMemoryFdKHR", 3, true, nil}

// GetMemoryFdPropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryFdPropertiesKHR.html
func GetMemoryFdPropertiesKHR(device Device, handleType ExternalMemoryHandleTypeFlagBits, fd int32) (memoryFdProperties MemoryFdPropertiesKHR, r error) {
	// memoryFdProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryFdProperties *_vkMemoryFdPropertiesKHR = memoryFdProperties.Vulkanize()

	var rsys uintptr

	if vkGetMemoryFdPropertiesKHR.fnHandle == nil {
		vkGetMemoryFdPropertiesKHR.fnHandle = dlHandle.NewProc("vkGetMemoryFdPropertiesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetMemoryFdPropertiesKHR.fnHandle.Addr(), uintptr(device), uintptr(handleType), uintptr(fd), uintptr(unsafe.Pointer(pMemoryFdProperties)))
	r = Result(rsys)

	memoryFdProperties = *(pMemoryFdProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetMemoryFdPropertiesKHR = &vkCommand{"vkGetMemoryFdPropertiesKHR", 4, true, nil}

// GetMemoryHostPointerPropertiesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryHostPointerPropertiesEXT.html
func GetMemoryHostPointerPropertiesEXT(device Device, handleType ExternalMemoryHandleTypeFlagBits, hostPointer *byte) (memoryHostPointerProperties MemoryHostPointerPropertiesEXT, r error) {
	// Parameter is a singular input, pass direct - hostPointer
	var pHostPointer unsafe.Pointer
	if hostPointer != nil {
		pHostPointer = unsafe.Pointer(hostPointer)
	}

	// memoryHostPointerProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryHostPointerProperties *_vkMemoryHostPointerPropertiesEXT = memoryHostPointerProperties.Vulkanize()

	var rsys uintptr

	if vkGetMemoryHostPointerPropertiesEXT.fnHandle == nil {
		vkGetMemoryHostPointerPropertiesEXT.fnHandle = dlHandle.NewProc("vkGetMemoryHostPointerPropertiesEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkGetMemoryHostPointerPropertiesEXT.fnHandle.Addr(), uintptr(device), uintptr(handleType), uintptr(unsafe.Pointer(pHostPointer)), uintptr(unsafe.Pointer(pMemoryHostPointerProperties)))
	r = Result(rsys)

	memoryHostPointerProperties = *(pMemoryHostPointerProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetMemoryHostPointerPropertiesEXT = &vkCommand{"vkGetMemoryHostPointerPropertiesEXT", 4, true, nil}

// GetMemoryRemoteAddressNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryRemoteAddressNV.html
func GetMemoryRemoteAddressNV(device Device, memoryGetRemoteAddressInfo *MemoryGetRemoteAddressInfoNV) (address RemoteAddressNV, r error) {
	// Parameter is a singular input, requires translation - memoryGetRemoteAddressInfo
	var pMemoryGetRemoteAddressInfo *_vkMemoryGetRemoteAddressInfoNV
	if memoryGetRemoteAddressInfo != nil {
		pMemoryGetRemoteAddressInfo = memoryGetRemoteAddressInfo.Vulkanize()
	}

	// address is a binding-allocated single return value and will be populated by Vulkan
	ptr_pAddress := &address

	var rsys uintptr

	if vkGetMemoryRemoteAddressNV.fnHandle == nil {
		vkGetMemoryRemoteAddressNV.fnHandle = dlHandle.NewProc("vkGetMemoryRemoteAddressNV")
	}
	rsys, _, _ = syscall.SyscallN(vkGetMemoryRemoteAddressNV.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pMemoryGetRemoteAddressInfo)), uintptr(unsafe.Pointer(ptr_pAddress)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetMemoryRemoteAddressNV = &vkCommand{"vkGetMemoryRemoteAddressNV", 3, true, nil}

// GetPastPresentationTimingGOOGLE: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPastPresentationTimingGOOGLE.html
func GetPastPresentationTimingGOOGLE(device Device, swapchain SwapchainKHR) (presentationTimings []PastPresentationTimingGOOGLE, r error) {
	// presentationTimings is a double-call array output
	var presentationTimingCount uint32
	pPresentationTimingCount := &presentationTimingCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pPresentationTimings *_vkPastPresentationTimingGOOGLE
	var rsys uintptr

	if vkGetPastPresentationTimingGOOGLE.fnHandle == nil {
		vkGetPastPresentationTimingGOOGLE.fnHandle = dlHandle.NewProc("vkGetPastPresentationTimingGOOGLE")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPastPresentationTimingGOOGLE.fnHandle.Addr(), uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pPresentationTimingCount)), uintptr(unsafe.Pointer(pPresentationTimings)))
	r = Result(rsys)

	sl_pPresentationTimings := make([]_vkPastPresentationTimingGOOGLE, presentationTimingCount)
	presentationTimings = make([]PastPresentationTimingGOOGLE, presentationTimingCount)
	pPresentationTimings = &sl_pPresentationTimings[0]

	// Trampoline call after last array allocation
	if vkGetPastPresentationTimingGOOGLE.fnHandle == nil {
		vkGetPastPresentationTimingGOOGLE.fnHandle = dlHandle.NewProc("vkGetPastPresentationTimingGOOGLE")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPastPresentationTimingGOOGLE.fnHandle.Addr(), uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pPresentationTimingCount)), uintptr(unsafe.Pointer(pPresentationTimings)))
	r = Result(rsys)

	for i := range sl_pPresentationTimings {
		presentationTimings[i] = *sl_pPresentationTimings[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPastPresentationTimingGOOGLE = &vkCommand{"vkGetPastPresentationTimingGOOGLE", 4, true, nil}

// GetPerformanceParameterINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPerformanceParameterINTEL.html
func GetPerformanceParameterINTEL(device Device, parameter PerformanceParameterTypeINTEL) (value PerformanceValueINTEL, r error) {
	// value is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pValue *_vkPerformanceValueINTEL = value.Vulkanize()

	var rsys uintptr

	if vkGetPerformanceParameterINTEL.fnHandle == nil {
		vkGetPerformanceParameterINTEL.fnHandle = dlHandle.NewProc("vkGetPerformanceParameterINTEL")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPerformanceParameterINTEL.fnHandle.Addr(), uintptr(device), uintptr(parameter), uintptr(unsafe.Pointer(pValue)))
	r = Result(rsys)

	value = *(pValue.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPerformanceParameterINTEL = &vkCommand{"vkGetPerformanceParameterINTEL", 3, true, nil}

// GetPhysicalDeviceCalibrateableTimeDomainsEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.html
func GetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice PhysicalDevice) (timeDomains []TimeDomainEXT, r error) {
	// timeDomains is a double-call array output
	var timeDomainCount uint32
	pTimeDomainCount := &timeDomainCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pTimeDomains *TimeDomainEXT
	var rsys uintptr

	if vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.fnHandle == nil {
		vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pTimeDomainCount)), uintptr(unsafe.Pointer(pTimeDomains)))
	r = Result(rsys)

	sl_pTimeDomains := make([]TimeDomainEXT, timeDomainCount)
	timeDomains = make([]TimeDomainEXT, timeDomainCount)
	pTimeDomains = &sl_pTimeDomains[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.fnHandle == nil {
		vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pTimeDomainCount)), uintptr(unsafe.Pointer(pTimeDomains)))
	r = Result(rsys)

	for i := range sl_pTimeDomains {
		timeDomains[i] = *&sl_pTimeDomains[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = &vkCommand{"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT", 3, true, nil}

// GetPhysicalDeviceCooperativeMatrixPropertiesNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.html
func GetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice PhysicalDevice) (properties []CooperativeMatrixPropertiesNV, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkCooperativeMatrixPropertiesNV
	var rsys uintptr

	if vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.fnHandle == nil {
		vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	sl_pProperties := make([]_vkCooperativeMatrixPropertiesNV, propertyCount)
	properties = make([]CooperativeMatrixPropertiesNV, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.fnHandle == nil {
		vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = &vkCommand{"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", 3, true, nil}

// GetPhysicalDeviceDisplayPlaneProperties2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPlaneProperties2KHR.html
func GetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice PhysicalDevice) (properties []DisplayPlaneProperties2KHR, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayPlaneProperties2KHR
	var rsys uintptr

	if vkGetPhysicalDeviceDisplayPlaneProperties2KHR.fnHandle == nil {
		vkGetPhysicalDeviceDisplayPlaneProperties2KHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceDisplayPlaneProperties2KHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceDisplayPlaneProperties2KHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	sl_pProperties := make([]_vkDisplayPlaneProperties2KHR, propertyCount)
	properties = make([]DisplayPlaneProperties2KHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceDisplayPlaneProperties2KHR.fnHandle == nil {
		vkGetPhysicalDeviceDisplayPlaneProperties2KHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceDisplayPlaneProperties2KHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceDisplayPlaneProperties2KHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceDisplayPlaneProperties2KHR = &vkCommand{"vkGetPhysicalDeviceDisplayPlaneProperties2KHR", 3, true, nil}

// GetPhysicalDeviceDisplayPlanePropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPlanePropertiesKHR.html
func GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice PhysicalDevice) (properties []DisplayPlanePropertiesKHR, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayPlanePropertiesKHR
	var rsys uintptr

	if vkGetPhysicalDeviceDisplayPlanePropertiesKHR.fnHandle == nil {
		vkGetPhysicalDeviceDisplayPlanePropertiesKHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceDisplayPlanePropertiesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceDisplayPlanePropertiesKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	sl_pProperties := make([]_vkDisplayPlanePropertiesKHR, propertyCount)
	properties = make([]DisplayPlanePropertiesKHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceDisplayPlanePropertiesKHR.fnHandle == nil {
		vkGetPhysicalDeviceDisplayPlanePropertiesKHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceDisplayPlanePropertiesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceDisplayPlanePropertiesKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceDisplayPlanePropertiesKHR = &vkCommand{"vkGetPhysicalDeviceDisplayPlanePropertiesKHR", 3, true, nil}

// GetPhysicalDeviceDisplayProperties2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayProperties2KHR.html
func GetPhysicalDeviceDisplayProperties2KHR(physicalDevice PhysicalDevice) (properties []DisplayProperties2KHR, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayProperties2KHR
	var rsys uintptr

	if vkGetPhysicalDeviceDisplayProperties2KHR.fnHandle == nil {
		vkGetPhysicalDeviceDisplayProperties2KHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceDisplayProperties2KHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceDisplayProperties2KHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	sl_pProperties := make([]_vkDisplayProperties2KHR, propertyCount)
	properties = make([]DisplayProperties2KHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceDisplayProperties2KHR.fnHandle == nil {
		vkGetPhysicalDeviceDisplayProperties2KHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceDisplayProperties2KHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceDisplayProperties2KHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceDisplayProperties2KHR = &vkCommand{"vkGetPhysicalDeviceDisplayProperties2KHR", 3, true, nil}

// GetPhysicalDeviceDisplayPropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPropertiesKHR.html
func GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice PhysicalDevice) (properties []DisplayPropertiesKHR, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayPropertiesKHR
	var rsys uintptr

	if vkGetPhysicalDeviceDisplayPropertiesKHR.fnHandle == nil {
		vkGetPhysicalDeviceDisplayPropertiesKHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceDisplayPropertiesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceDisplayPropertiesKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	sl_pProperties := make([]_vkDisplayPropertiesKHR, propertyCount)
	properties = make([]DisplayPropertiesKHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceDisplayPropertiesKHR.fnHandle == nil {
		vkGetPhysicalDeviceDisplayPropertiesKHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceDisplayPropertiesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceDisplayPropertiesKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceDisplayPropertiesKHR = &vkCommand{"vkGetPhysicalDeviceDisplayPropertiesKHR", 3, true, nil}

// GetPhysicalDeviceExternalBufferProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalBufferProperties.html
func GetPhysicalDeviceExternalBufferProperties(physicalDevice PhysicalDevice, externalBufferInfo *PhysicalDeviceExternalBufferInfo) (externalBufferProperties ExternalBufferProperties) {
	// Parameter is a singular input, requires translation - externalBufferInfo
	var pExternalBufferInfo *_vkPhysicalDeviceExternalBufferInfo
	if externalBufferInfo != nil {
		pExternalBufferInfo = externalBufferInfo.Vulkanize()
	}

	// externalBufferProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pExternalBufferProperties *_vkExternalBufferProperties = externalBufferProperties.Vulkanize()

	if vkGetPhysicalDeviceExternalBufferProperties.fnHandle == nil {
		vkGetPhysicalDeviceExternalBufferProperties.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceExternalBufferProperties")
	}
	syscall.SyscallN(vkGetPhysicalDeviceExternalBufferProperties.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pExternalBufferInfo)), uintptr(unsafe.Pointer(pExternalBufferProperties)))

	externalBufferProperties = *(pExternalBufferProperties.Goify())
	return
}

var vkGetPhysicalDeviceExternalBufferProperties = &vkCommand{"vkGetPhysicalDeviceExternalBufferProperties", 3, true, nil}
var GetPhysicalDeviceExternalBufferPropertiesKHR = GetPhysicalDeviceExternalBufferProperties

// GetPhysicalDeviceExternalFenceProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalFenceProperties.html
func GetPhysicalDeviceExternalFenceProperties(physicalDevice PhysicalDevice, externalFenceInfo *PhysicalDeviceExternalFenceInfo) (externalFenceProperties ExternalFenceProperties) {
	// Parameter is a singular input, requires translation - externalFenceInfo
	var pExternalFenceInfo *_vkPhysicalDeviceExternalFenceInfo
	if externalFenceInfo != nil {
		pExternalFenceInfo = externalFenceInfo.Vulkanize()
	}

	// externalFenceProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pExternalFenceProperties *_vkExternalFenceProperties = externalFenceProperties.Vulkanize()

	if vkGetPhysicalDeviceExternalFenceProperties.fnHandle == nil {
		vkGetPhysicalDeviceExternalFenceProperties.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceExternalFenceProperties")
	}
	syscall.SyscallN(vkGetPhysicalDeviceExternalFenceProperties.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pExternalFenceInfo)), uintptr(unsafe.Pointer(pExternalFenceProperties)))

	externalFenceProperties = *(pExternalFenceProperties.Goify())
	return
}

var vkGetPhysicalDeviceExternalFenceProperties = &vkCommand{"vkGetPhysicalDeviceExternalFenceProperties", 3, true, nil}
var GetPhysicalDeviceExternalFencePropertiesKHR = GetPhysicalDeviceExternalFenceProperties

// GetPhysicalDeviceExternalImageFormatPropertiesNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalImageFormatPropertiesNV.html
func GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice PhysicalDevice, format Format, typ ImageType, tiling ImageTiling, usage ImageUsageFlags, flags ImageCreateFlags, externalHandleType ExternalMemoryHandleTypeFlagsNV) (externalImageFormatProperties ExternalImageFormatPropertiesNV, r error) {
	// externalImageFormatProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pExternalImageFormatProperties *_vkExternalImageFormatPropertiesNV = externalImageFormatProperties.Vulkanize()

	var rsys uintptr

	if vkGetPhysicalDeviceExternalImageFormatPropertiesNV.fnHandle == nil {
		vkGetPhysicalDeviceExternalImageFormatPropertiesNV.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceExternalImageFormatPropertiesNV")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceExternalImageFormatPropertiesNV.fnHandle.Addr(), uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(tiling), uintptr(usage), uintptr(flags), uintptr(externalHandleType), uintptr(unsafe.Pointer(pExternalImageFormatProperties)))
	r = Result(rsys)

	externalImageFormatProperties = *(pExternalImageFormatProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceExternalImageFormatPropertiesNV = &vkCommand{"vkGetPhysicalDeviceExternalImageFormatPropertiesNV", 8, true, nil}

// GetPhysicalDeviceExternalSemaphoreProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalSemaphoreProperties.html
func GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice PhysicalDevice, externalSemaphoreInfo *PhysicalDeviceExternalSemaphoreInfo) (externalSemaphoreProperties ExternalSemaphoreProperties) {
	// Parameter is a singular input, requires translation - externalSemaphoreInfo
	var pExternalSemaphoreInfo *_vkPhysicalDeviceExternalSemaphoreInfo
	if externalSemaphoreInfo != nil {
		pExternalSemaphoreInfo = externalSemaphoreInfo.Vulkanize()
	}

	// externalSemaphoreProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pExternalSemaphoreProperties *_vkExternalSemaphoreProperties = externalSemaphoreProperties.Vulkanize()

	if vkGetPhysicalDeviceExternalSemaphoreProperties.fnHandle == nil {
		vkGetPhysicalDeviceExternalSemaphoreProperties.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceExternalSemaphoreProperties")
	}
	syscall.SyscallN(vkGetPhysicalDeviceExternalSemaphoreProperties.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pExternalSemaphoreInfo)), uintptr(unsafe.Pointer(pExternalSemaphoreProperties)))

	externalSemaphoreProperties = *(pExternalSemaphoreProperties.Goify())
	return
}

var vkGetPhysicalDeviceExternalSemaphoreProperties = &vkCommand{"vkGetPhysicalDeviceExternalSemaphoreProperties", 3, true, nil}
var GetPhysicalDeviceExternalSemaphorePropertiesKHR = GetPhysicalDeviceExternalSemaphoreProperties

// GetPhysicalDeviceFeatures: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html
func GetPhysicalDeviceFeatures(physicalDevice PhysicalDevice) (features PhysicalDeviceFeatures) {
	// features is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pFeatures *_vkPhysicalDeviceFeatures = features.Vulkanize()

	if vkGetPhysicalDeviceFeatures.fnHandle == nil {
		vkGetPhysicalDeviceFeatures.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceFeatures")
	}
	syscall.SyscallN(vkGetPhysicalDeviceFeatures.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pFeatures)))

	features = *(pFeatures.Goify())
	return
}

var vkGetPhysicalDeviceFeatures = &vkCommand{"vkGetPhysicalDeviceFeatures", 2, true, nil}

// GetPhysicalDeviceFeatures2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures2.html
func GetPhysicalDeviceFeatures2(physicalDevice PhysicalDevice) (features PhysicalDeviceFeatures2) {
	// features is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pFeatures *_vkPhysicalDeviceFeatures2 = features.Vulkanize()

	if vkGetPhysicalDeviceFeatures2.fnHandle == nil {
		vkGetPhysicalDeviceFeatures2.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceFeatures2")
	}
	syscall.SyscallN(vkGetPhysicalDeviceFeatures2.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pFeatures)))

	features = *(pFeatures.Goify())
	return
}

var vkGetPhysicalDeviceFeatures2 = &vkCommand{"vkGetPhysicalDeviceFeatures2", 2, true, nil}
var GetPhysicalDeviceFeatures2KHR = GetPhysicalDeviceFeatures2

// GetPhysicalDeviceFormatProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFormatProperties.html
func GetPhysicalDeviceFormatProperties(physicalDevice PhysicalDevice, format Format) (formatProperties FormatProperties) {
	// formatProperties is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFormatProperties := &formatProperties

	if vkGetPhysicalDeviceFormatProperties.fnHandle == nil {
		vkGetPhysicalDeviceFormatProperties.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceFormatProperties")
	}
	syscall.SyscallN(vkGetPhysicalDeviceFormatProperties.fnHandle.Addr(), uintptr(physicalDevice), uintptr(format), uintptr(unsafe.Pointer(ptr_pFormatProperties)))

	return
}

var vkGetPhysicalDeviceFormatProperties = &vkCommand{"vkGetPhysicalDeviceFormatProperties", 3, true, nil}

// GetPhysicalDeviceFormatProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFormatProperties2.html
func GetPhysicalDeviceFormatProperties2(physicalDevice PhysicalDevice, format Format) (formatProperties FormatProperties2) {
	// formatProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pFormatProperties *_vkFormatProperties2 = formatProperties.Vulkanize()

	if vkGetPhysicalDeviceFormatProperties2.fnHandle == nil {
		vkGetPhysicalDeviceFormatProperties2.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceFormatProperties2")
	}
	syscall.SyscallN(vkGetPhysicalDeviceFormatProperties2.fnHandle.Addr(), uintptr(physicalDevice), uintptr(format), uintptr(unsafe.Pointer(pFormatProperties)))

	formatProperties = *(pFormatProperties.Goify())
	return
}

var vkGetPhysicalDeviceFormatProperties2 = &vkCommand{"vkGetPhysicalDeviceFormatProperties2", 3, true, nil}
var GetPhysicalDeviceFormatProperties2KHR = GetPhysicalDeviceFormatProperties2

// GetPhysicalDeviceFragmentShadingRatesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFragmentShadingRatesKHR.html
func GetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice PhysicalDevice) (fragmentShadingRates []PhysicalDeviceFragmentShadingRateKHR, r error) {
	// fragmentShadingRates is a double-call array output
	var fragmentShadingRateCount uint32
	pFragmentShadingRateCount := &fragmentShadingRateCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pFragmentShadingRates *_vkPhysicalDeviceFragmentShadingRateKHR
	var rsys uintptr

	if vkGetPhysicalDeviceFragmentShadingRatesKHR.fnHandle == nil {
		vkGetPhysicalDeviceFragmentShadingRatesKHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceFragmentShadingRatesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceFragmentShadingRatesKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pFragmentShadingRateCount)), uintptr(unsafe.Pointer(pFragmentShadingRates)))
	r = Result(rsys)

	sl_pFragmentShadingRates := make([]_vkPhysicalDeviceFragmentShadingRateKHR, fragmentShadingRateCount)
	fragmentShadingRates = make([]PhysicalDeviceFragmentShadingRateKHR, fragmentShadingRateCount)
	pFragmentShadingRates = &sl_pFragmentShadingRates[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceFragmentShadingRatesKHR.fnHandle == nil {
		vkGetPhysicalDeviceFragmentShadingRatesKHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceFragmentShadingRatesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceFragmentShadingRatesKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pFragmentShadingRateCount)), uintptr(unsafe.Pointer(pFragmentShadingRates)))
	r = Result(rsys)

	for i := range sl_pFragmentShadingRates {
		fragmentShadingRates[i] = *sl_pFragmentShadingRates[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceFragmentShadingRatesKHR = &vkCommand{"vkGetPhysicalDeviceFragmentShadingRatesKHR", 3, true, nil}

// GetPhysicalDeviceImageFormatProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties.html
func GetPhysicalDeviceImageFormatProperties(physicalDevice PhysicalDevice, format Format, typ ImageType, tiling ImageTiling, usage ImageUsageFlags, flags ImageCreateFlags) (imageFormatProperties ImageFormatProperties, r error) {
	// imageFormatProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pImageFormatProperties *_vkImageFormatProperties = imageFormatProperties.Vulkanize()

	var rsys uintptr

	if vkGetPhysicalDeviceImageFormatProperties.fnHandle == nil {
		vkGetPhysicalDeviceImageFormatProperties.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceImageFormatProperties")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceImageFormatProperties.fnHandle.Addr(), uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(tiling), uintptr(usage), uintptr(flags), uintptr(unsafe.Pointer(pImageFormatProperties)))
	r = Result(rsys)

	imageFormatProperties = *(pImageFormatProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceImageFormatProperties = &vkCommand{"vkGetPhysicalDeviceImageFormatProperties", 7, true, nil}

// GetPhysicalDeviceImageFormatProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties2.html
func GetPhysicalDeviceImageFormatProperties2(physicalDevice PhysicalDevice, imageFormatInfo *PhysicalDeviceImageFormatInfo2) (imageFormatProperties ImageFormatProperties2, r error) {
	// Parameter is a singular input, requires translation - imageFormatInfo
	var pImageFormatInfo *_vkPhysicalDeviceImageFormatInfo2
	if imageFormatInfo != nil {
		pImageFormatInfo = imageFormatInfo.Vulkanize()
	}

	// imageFormatProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pImageFormatProperties *_vkImageFormatProperties2 = imageFormatProperties.Vulkanize()

	var rsys uintptr

	if vkGetPhysicalDeviceImageFormatProperties2.fnHandle == nil {
		vkGetPhysicalDeviceImageFormatProperties2.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceImageFormatProperties2")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceImageFormatProperties2.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pImageFormatInfo)), uintptr(unsafe.Pointer(pImageFormatProperties)))
	r = Result(rsys)

	imageFormatProperties = *(pImageFormatProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceImageFormatProperties2 = &vkCommand{"vkGetPhysicalDeviceImageFormatProperties2", 3, true, nil}
var GetPhysicalDeviceImageFormatProperties2KHR = GetPhysicalDeviceImageFormatProperties2

// GetPhysicalDeviceMemoryProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMemoryProperties.html
func GetPhysicalDeviceMemoryProperties(physicalDevice PhysicalDevice) (memoryProperties PhysicalDeviceMemoryProperties) {
	// memoryProperties is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMemoryProperties := &memoryProperties

	if vkGetPhysicalDeviceMemoryProperties.fnHandle == nil {
		vkGetPhysicalDeviceMemoryProperties.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceMemoryProperties")
	}
	syscall.SyscallN(vkGetPhysicalDeviceMemoryProperties.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(ptr_pMemoryProperties)))

	return
}

var vkGetPhysicalDeviceMemoryProperties = &vkCommand{"vkGetPhysicalDeviceMemoryProperties", 2, true, nil}

// GetPhysicalDeviceMemoryProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMemoryProperties2.html
func GetPhysicalDeviceMemoryProperties2(physicalDevice PhysicalDevice) (memoryProperties PhysicalDeviceMemoryProperties2) {
	// memoryProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryProperties *_vkPhysicalDeviceMemoryProperties2 = memoryProperties.Vulkanize()

	if vkGetPhysicalDeviceMemoryProperties2.fnHandle == nil {
		vkGetPhysicalDeviceMemoryProperties2.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceMemoryProperties2")
	}
	syscall.SyscallN(vkGetPhysicalDeviceMemoryProperties2.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pMemoryProperties)))

	memoryProperties = *(pMemoryProperties.Goify())
	return
}

var vkGetPhysicalDeviceMemoryProperties2 = &vkCommand{"vkGetPhysicalDeviceMemoryProperties2", 2, true, nil}
var GetPhysicalDeviceMemoryProperties2KHR = GetPhysicalDeviceMemoryProperties2

// GetPhysicalDeviceMultisamplePropertiesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMultisamplePropertiesEXT.html
func GetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice PhysicalDevice, samples SampleCountFlagBits) (multisampleProperties MultisamplePropertiesEXT) {
	// multisampleProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMultisampleProperties *_vkMultisamplePropertiesEXT = multisampleProperties.Vulkanize()

	if vkGetPhysicalDeviceMultisamplePropertiesEXT.fnHandle == nil {
		vkGetPhysicalDeviceMultisamplePropertiesEXT.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceMultisamplePropertiesEXT")
	}
	syscall.SyscallN(vkGetPhysicalDeviceMultisamplePropertiesEXT.fnHandle.Addr(), uintptr(physicalDevice), uintptr(samples), uintptr(unsafe.Pointer(pMultisampleProperties)))

	multisampleProperties = *(pMultisampleProperties.Goify())
	return
}

var vkGetPhysicalDeviceMultisamplePropertiesEXT = &vkCommand{"vkGetPhysicalDeviceMultisamplePropertiesEXT", 3, true, nil}

// GetPhysicalDevicePresentRectanglesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDevicePresentRectanglesKHR.html
func GetPhysicalDevicePresentRectanglesKHR(physicalDevice PhysicalDevice, surface SurfaceKHR) (rects []Rect2D, r error) {
	// rects is a double-call array output
	var rectCount uint32
	pRectCount := &rectCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pRects *_vkRect2D
	var rsys uintptr

	if vkGetPhysicalDevicePresentRectanglesKHR.fnHandle == nil {
		vkGetPhysicalDevicePresentRectanglesKHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDevicePresentRectanglesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDevicePresentRectanglesKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pRectCount)), uintptr(unsafe.Pointer(pRects)))
	r = Result(rsys)

	sl_pRects := make([]_vkRect2D, rectCount)
	rects = make([]Rect2D, rectCount)
	pRects = &sl_pRects[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDevicePresentRectanglesKHR.fnHandle == nil {
		vkGetPhysicalDevicePresentRectanglesKHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDevicePresentRectanglesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDevicePresentRectanglesKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pRectCount)), uintptr(unsafe.Pointer(pRects)))
	r = Result(rsys)

	for i := range sl_pRects {
		rects[i] = *sl_pRects[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDevicePresentRectanglesKHR = &vkCommand{"vkGetPhysicalDevicePresentRectanglesKHR", 4, true, nil}

// GetPhysicalDeviceProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceProperties.html
func GetPhysicalDeviceProperties(physicalDevice PhysicalDevice) (properties PhysicalDeviceProperties) {
	// properties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pProperties *_vkPhysicalDeviceProperties = properties.Vulkanize()

	if vkGetPhysicalDeviceProperties.fnHandle == nil {
		vkGetPhysicalDeviceProperties.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceProperties")
	}
	syscall.SyscallN(vkGetPhysicalDeviceProperties.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pProperties)))

	properties = *(pProperties.Goify())
	return
}

var vkGetPhysicalDeviceProperties = &vkCommand{"vkGetPhysicalDeviceProperties", 2, true, nil}

// GetPhysicalDeviceProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceProperties2.html
func GetPhysicalDeviceProperties2(physicalDevice PhysicalDevice) (properties PhysicalDeviceProperties2) {
	// properties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pProperties *_vkPhysicalDeviceProperties2 = properties.Vulkanize()

	if vkGetPhysicalDeviceProperties2.fnHandle == nil {
		vkGetPhysicalDeviceProperties2.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceProperties2")
	}
	syscall.SyscallN(vkGetPhysicalDeviceProperties2.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pProperties)))

	properties = *(pProperties.Goify())
	return
}

var vkGetPhysicalDeviceProperties2 = &vkCommand{"vkGetPhysicalDeviceProperties2", 2, true, nil}
var GetPhysicalDeviceProperties2KHR = GetPhysicalDeviceProperties2

// GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR.html
func GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice PhysicalDevice, performanceQueryCreateInfo *QueryPoolPerformanceCreateInfoKHR) (numPasses uint32) {
	// Parameter is a singular input, requires translation - performanceQueryCreateInfo
	var pPerformanceQueryCreateInfo *_vkQueryPoolPerformanceCreateInfoKHR
	if performanceQueryCreateInfo != nil {
		pPerformanceQueryCreateInfo = performanceQueryCreateInfo.Vulkanize()
	}

	// numPasses is a binding-allocated single return value and will be populated by Vulkan
	ptr_pNumPasses := &numPasses

	if vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR.fnHandle == nil {
		vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR")
	}
	syscall.SyscallN(vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pPerformanceQueryCreateInfo)), uintptr(unsafe.Pointer(ptr_pNumPasses)))

	return
}

var vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = &vkCommand{"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR", 3, true, nil}

// GetPhysicalDeviceQueueFamilyProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties.html
func GetPhysicalDeviceQueueFamilyProperties(physicalDevice PhysicalDevice) (queueFamilyProperties []QueueFamilyProperties) {
	// queueFamilyProperties is a double-call array output
	var queueFamilyPropertyCount uint32
	pQueueFamilyPropertyCount := &queueFamilyPropertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pQueueFamilyProperties *_vkQueueFamilyProperties

	if vkGetPhysicalDeviceQueueFamilyProperties.fnHandle == nil {
		vkGetPhysicalDeviceQueueFamilyProperties.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceQueueFamilyProperties")
	}
	syscall.SyscallN(vkGetPhysicalDeviceQueueFamilyProperties.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pQueueFamilyPropertyCount)), uintptr(unsafe.Pointer(pQueueFamilyProperties)))

	sl_pQueueFamilyProperties := make([]_vkQueueFamilyProperties, queueFamilyPropertyCount)
	queueFamilyProperties = make([]QueueFamilyProperties, queueFamilyPropertyCount)
	pQueueFamilyProperties = &sl_pQueueFamilyProperties[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceQueueFamilyProperties.fnHandle == nil {
		vkGetPhysicalDeviceQueueFamilyProperties.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceQueueFamilyProperties")
	}
	syscall.SyscallN(vkGetPhysicalDeviceQueueFamilyProperties.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pQueueFamilyPropertyCount)), uintptr(unsafe.Pointer(pQueueFamilyProperties)))

	for i := range sl_pQueueFamilyProperties {
		queueFamilyProperties[i] = *sl_pQueueFamilyProperties[i].Goify()
	}
	return
}

var vkGetPhysicalDeviceQueueFamilyProperties = &vkCommand{"vkGetPhysicalDeviceQueueFamilyProperties", 3, true, nil}

// GetPhysicalDeviceQueueFamilyProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties2.html
func GetPhysicalDeviceQueueFamilyProperties2(physicalDevice PhysicalDevice) (queueFamilyProperties []QueueFamilyProperties2) {
	// queueFamilyProperties is a double-call array output
	var queueFamilyPropertyCount uint32
	pQueueFamilyPropertyCount := &queueFamilyPropertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pQueueFamilyProperties *_vkQueueFamilyProperties2

	if vkGetPhysicalDeviceQueueFamilyProperties2.fnHandle == nil {
		vkGetPhysicalDeviceQueueFamilyProperties2.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceQueueFamilyProperties2")
	}
	syscall.SyscallN(vkGetPhysicalDeviceQueueFamilyProperties2.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pQueueFamilyPropertyCount)), uintptr(unsafe.Pointer(pQueueFamilyProperties)))

	sl_pQueueFamilyProperties := make([]_vkQueueFamilyProperties2, queueFamilyPropertyCount)
	queueFamilyProperties = make([]QueueFamilyProperties2, queueFamilyPropertyCount)
	pQueueFamilyProperties = &sl_pQueueFamilyProperties[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceQueueFamilyProperties2.fnHandle == nil {
		vkGetPhysicalDeviceQueueFamilyProperties2.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceQueueFamilyProperties2")
	}
	syscall.SyscallN(vkGetPhysicalDeviceQueueFamilyProperties2.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pQueueFamilyPropertyCount)), uintptr(unsafe.Pointer(pQueueFamilyProperties)))

	for i := range sl_pQueueFamilyProperties {
		queueFamilyProperties[i] = *sl_pQueueFamilyProperties[i].Goify()
	}
	return
}

var vkGetPhysicalDeviceQueueFamilyProperties2 = &vkCommand{"vkGetPhysicalDeviceQueueFamilyProperties2", 3, true, nil}
var GetPhysicalDeviceQueueFamilyProperties2KHR = GetPhysicalDeviceQueueFamilyProperties2

// GetPhysicalDeviceSparseImageFormatProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties.html
func GetPhysicalDeviceSparseImageFormatProperties(physicalDevice PhysicalDevice, format Format, typ ImageType, samples SampleCountFlagBits, usage ImageUsageFlags, tiling ImageTiling) (properties []SparseImageFormatProperties) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkSparseImageFormatProperties

	if vkGetPhysicalDeviceSparseImageFormatProperties.fnHandle == nil {
		vkGetPhysicalDeviceSparseImageFormatProperties.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSparseImageFormatProperties")
	}
	syscall.SyscallN(vkGetPhysicalDeviceSparseImageFormatProperties.fnHandle.Addr(), uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(samples), uintptr(usage), uintptr(tiling), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))

	sl_pProperties := make([]_vkSparseImageFormatProperties, propertyCount)
	properties = make([]SparseImageFormatProperties, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceSparseImageFormatProperties.fnHandle == nil {
		vkGetPhysicalDeviceSparseImageFormatProperties.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSparseImageFormatProperties")
	}
	syscall.SyscallN(vkGetPhysicalDeviceSparseImageFormatProperties.fnHandle.Addr(), uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(samples), uintptr(usage), uintptr(tiling), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

var vkGetPhysicalDeviceSparseImageFormatProperties = &vkCommand{"vkGetPhysicalDeviceSparseImageFormatProperties", 8, true, nil}

// GetPhysicalDeviceSparseImageFormatProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2.html
func GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice PhysicalDevice, formatInfo *PhysicalDeviceSparseImageFormatInfo2) (properties []SparseImageFormatProperties2) {
	// Parameter is a singular input, requires translation - formatInfo
	var pFormatInfo *_vkPhysicalDeviceSparseImageFormatInfo2
	if formatInfo != nil {
		pFormatInfo = formatInfo.Vulkanize()
	}

	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkSparseImageFormatProperties2

	if vkGetPhysicalDeviceSparseImageFormatProperties2.fnHandle == nil {
		vkGetPhysicalDeviceSparseImageFormatProperties2.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSparseImageFormatProperties2")
	}
	syscall.SyscallN(vkGetPhysicalDeviceSparseImageFormatProperties2.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pFormatInfo)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))

	sl_pProperties := make([]_vkSparseImageFormatProperties2, propertyCount)
	properties = make([]SparseImageFormatProperties2, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceSparseImageFormatProperties2.fnHandle == nil {
		vkGetPhysicalDeviceSparseImageFormatProperties2.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSparseImageFormatProperties2")
	}
	syscall.SyscallN(vkGetPhysicalDeviceSparseImageFormatProperties2.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pFormatInfo)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

var vkGetPhysicalDeviceSparseImageFormatProperties2 = &vkCommand{"vkGetPhysicalDeviceSparseImageFormatProperties2", 4, true, nil}
var GetPhysicalDeviceSparseImageFormatProperties2KHR = GetPhysicalDeviceSparseImageFormatProperties2

// GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.html
func GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice PhysicalDevice) (combinations []FramebufferMixedSamplesCombinationNV, r error) {
	// combinations is a double-call array output
	var combinationCount uint32
	pCombinationCount := &combinationCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pCombinations *_vkFramebufferMixedSamplesCombinationNV
	var rsys uintptr

	if vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.fnHandle == nil {
		vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pCombinationCount)), uintptr(unsafe.Pointer(pCombinations)))
	r = Result(rsys)

	sl_pCombinations := make([]_vkFramebufferMixedSamplesCombinationNV, combinationCount)
	combinations = make([]FramebufferMixedSamplesCombinationNV, combinationCount)
	pCombinations = &sl_pCombinations[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.fnHandle == nil {
		vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pCombinationCount)), uintptr(unsafe.Pointer(pCombinations)))
	r = Result(rsys)

	for i := range sl_pCombinations {
		combinations[i] = *sl_pCombinations[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = &vkCommand{"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", 3, true, nil}

// GetPhysicalDeviceSurfaceCapabilities2EXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilities2EXT.html
func GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice PhysicalDevice, surface SurfaceKHR) (surfaceCapabilities SurfaceCapabilities2EXT, r error) {
	// surfaceCapabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSurfaceCapabilities *_vkSurfaceCapabilities2EXT = surfaceCapabilities.Vulkanize()

	var rsys uintptr

	if vkGetPhysicalDeviceSurfaceCapabilities2EXT.fnHandle == nil {
		vkGetPhysicalDeviceSurfaceCapabilities2EXT.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSurfaceCapabilities2EXT")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceSurfaceCapabilities2EXT.fnHandle.Addr(), uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pSurfaceCapabilities)))
	r = Result(rsys)

	surfaceCapabilities = *(pSurfaceCapabilities.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSurfaceCapabilities2EXT = &vkCommand{"vkGetPhysicalDeviceSurfaceCapabilities2EXT", 3, true, nil}

// GetPhysicalDeviceSurfaceCapabilities2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilities2KHR.html
func GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice PhysicalDevice, surfaceInfo *PhysicalDeviceSurfaceInfo2KHR) (surfaceCapabilities SurfaceCapabilities2KHR, r error) {
	// Parameter is a singular input, requires translation - surfaceInfo
	var pSurfaceInfo *_vkPhysicalDeviceSurfaceInfo2KHR
	if surfaceInfo != nil {
		pSurfaceInfo = surfaceInfo.Vulkanize()
	}

	// surfaceCapabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSurfaceCapabilities *_vkSurfaceCapabilities2KHR = surfaceCapabilities.Vulkanize()

	var rsys uintptr

	if vkGetPhysicalDeviceSurfaceCapabilities2KHR.fnHandle == nil {
		vkGetPhysicalDeviceSurfaceCapabilities2KHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSurfaceCapabilities2KHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceSurfaceCapabilities2KHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pSurfaceInfo)), uintptr(unsafe.Pointer(pSurfaceCapabilities)))
	r = Result(rsys)

	surfaceCapabilities = *(pSurfaceCapabilities.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSurfaceCapabilities2KHR = &vkCommand{"vkGetPhysicalDeviceSurfaceCapabilities2KHR", 3, true, nil}

// GetPhysicalDeviceSurfaceCapabilitiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilitiesKHR.html
func GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice PhysicalDevice, surface SurfaceKHR) (surfaceCapabilities SurfaceCapabilitiesKHR, r error) {
	// surfaceCapabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSurfaceCapabilities *_vkSurfaceCapabilitiesKHR = surfaceCapabilities.Vulkanize()

	var rsys uintptr

	if vkGetPhysicalDeviceSurfaceCapabilitiesKHR.fnHandle == nil {
		vkGetPhysicalDeviceSurfaceCapabilitiesKHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSurfaceCapabilitiesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceSurfaceCapabilitiesKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pSurfaceCapabilities)))
	r = Result(rsys)

	surfaceCapabilities = *(pSurfaceCapabilities.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSurfaceCapabilitiesKHR = &vkCommand{"vkGetPhysicalDeviceSurfaceCapabilitiesKHR", 3, true, nil}

// GetPhysicalDeviceSurfaceFormats2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceFormats2KHR.html
func GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice PhysicalDevice, surfaceInfo *PhysicalDeviceSurfaceInfo2KHR) (surfaceFormats []SurfaceFormat2KHR, r error) {
	// Parameter is a singular input, requires translation - surfaceInfo
	var pSurfaceInfo *_vkPhysicalDeviceSurfaceInfo2KHR
	if surfaceInfo != nil {
		pSurfaceInfo = surfaceInfo.Vulkanize()
	}

	// surfaceFormats is a double-call array output
	var surfaceFormatCount uint32
	pSurfaceFormatCount := &surfaceFormatCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSurfaceFormats *_vkSurfaceFormat2KHR
	var rsys uintptr

	if vkGetPhysicalDeviceSurfaceFormats2KHR.fnHandle == nil {
		vkGetPhysicalDeviceSurfaceFormats2KHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSurfaceFormats2KHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceSurfaceFormats2KHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pSurfaceInfo)), uintptr(unsafe.Pointer(pSurfaceFormatCount)), uintptr(unsafe.Pointer(pSurfaceFormats)))
	r = Result(rsys)

	sl_pSurfaceFormats := make([]_vkSurfaceFormat2KHR, surfaceFormatCount)
	surfaceFormats = make([]SurfaceFormat2KHR, surfaceFormatCount)
	pSurfaceFormats = &sl_pSurfaceFormats[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceSurfaceFormats2KHR.fnHandle == nil {
		vkGetPhysicalDeviceSurfaceFormats2KHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSurfaceFormats2KHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceSurfaceFormats2KHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pSurfaceInfo)), uintptr(unsafe.Pointer(pSurfaceFormatCount)), uintptr(unsafe.Pointer(pSurfaceFormats)))
	r = Result(rsys)

	for i := range sl_pSurfaceFormats {
		surfaceFormats[i] = *sl_pSurfaceFormats[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSurfaceFormats2KHR = &vkCommand{"vkGetPhysicalDeviceSurfaceFormats2KHR", 4, true, nil}

// GetPhysicalDeviceSurfaceFormatsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceFormatsKHR.html
func GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice PhysicalDevice, surface SurfaceKHR) (surfaceFormats []SurfaceFormatKHR, r error) {
	// surfaceFormats is a double-call array output
	var surfaceFormatCount uint32
	pSurfaceFormatCount := &surfaceFormatCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSurfaceFormats *_vkSurfaceFormatKHR
	var rsys uintptr

	if vkGetPhysicalDeviceSurfaceFormatsKHR.fnHandle == nil {
		vkGetPhysicalDeviceSurfaceFormatsKHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSurfaceFormatsKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceSurfaceFormatsKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pSurfaceFormatCount)), uintptr(unsafe.Pointer(pSurfaceFormats)))
	r = Result(rsys)

	sl_pSurfaceFormats := make([]_vkSurfaceFormatKHR, surfaceFormatCount)
	surfaceFormats = make([]SurfaceFormatKHR, surfaceFormatCount)
	pSurfaceFormats = &sl_pSurfaceFormats[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceSurfaceFormatsKHR.fnHandle == nil {
		vkGetPhysicalDeviceSurfaceFormatsKHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSurfaceFormatsKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceSurfaceFormatsKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pSurfaceFormatCount)), uintptr(unsafe.Pointer(pSurfaceFormats)))
	r = Result(rsys)

	for i := range sl_pSurfaceFormats {
		surfaceFormats[i] = *sl_pSurfaceFormats[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSurfaceFormatsKHR = &vkCommand{"vkGetPhysicalDeviceSurfaceFormatsKHR", 4, true, nil}

// GetPhysicalDeviceSurfacePresentModesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfacePresentModesKHR.html
func GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice PhysicalDevice, surface SurfaceKHR) (presentModes []PresentModeKHR, r error) {
	// presentModes is a double-call array output
	var presentModeCount uint32
	pPresentModeCount := &presentModeCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pPresentModes *PresentModeKHR
	var rsys uintptr

	if vkGetPhysicalDeviceSurfacePresentModesKHR.fnHandle == nil {
		vkGetPhysicalDeviceSurfacePresentModesKHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSurfacePresentModesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceSurfacePresentModesKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pPresentModeCount)), uintptr(unsafe.Pointer(pPresentModes)))
	r = Result(rsys)

	sl_pPresentModes := make([]PresentModeKHR, presentModeCount)
	presentModes = make([]PresentModeKHR, presentModeCount)
	pPresentModes = &sl_pPresentModes[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceSurfacePresentModesKHR.fnHandle == nil {
		vkGetPhysicalDeviceSurfacePresentModesKHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSurfacePresentModesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceSurfacePresentModesKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pPresentModeCount)), uintptr(unsafe.Pointer(pPresentModes)))
	r = Result(rsys)

	for i := range sl_pPresentModes {
		presentModes[i] = *&sl_pPresentModes[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSurfacePresentModesKHR = &vkCommand{"vkGetPhysicalDeviceSurfacePresentModesKHR", 4, true, nil}

// GetPhysicalDeviceSurfaceSupportKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html
func GetPhysicalDeviceSurfaceSupportKHR(physicalDevice PhysicalDevice, queueFamilyIndex uint32, surface SurfaceKHR) (supported bool, r error) {
	// supported is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var internal_supported Bool32 = translateInternal_Bool32(supported)
	var pSupported = &internal_supported

	var rsys uintptr

	if vkGetPhysicalDeviceSurfaceSupportKHR.fnHandle == nil {
		vkGetPhysicalDeviceSurfaceSupportKHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSurfaceSupportKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceSurfaceSupportKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(queueFamilyIndex), uintptr(surface), uintptr(unsafe.Pointer(pSupported)))
	r = Result(rsys)

	supported = translatePublic_Bool32(internal_supported)
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSurfaceSupportKHR = &vkCommand{"vkGetPhysicalDeviceSurfaceSupportKHR", 4, true, nil}

// GetPhysicalDeviceToolPropertiesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceToolPropertiesEXT.html
func GetPhysicalDeviceToolPropertiesEXT(physicalDevice PhysicalDevice) (toolProperties []PhysicalDeviceToolPropertiesEXT, r error) {
	// toolProperties is a double-call array output
	var toolCount uint32
	pToolCount := &toolCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pToolProperties *_vkPhysicalDeviceToolPropertiesEXT
	var rsys uintptr

	if vkGetPhysicalDeviceToolPropertiesEXT.fnHandle == nil {
		vkGetPhysicalDeviceToolPropertiesEXT.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceToolPropertiesEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceToolPropertiesEXT.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pToolCount)), uintptr(unsafe.Pointer(pToolProperties)))
	r = Result(rsys)

	sl_pToolProperties := make([]_vkPhysicalDeviceToolPropertiesEXT, toolCount)
	toolProperties = make([]PhysicalDeviceToolPropertiesEXT, toolCount)
	pToolProperties = &sl_pToolProperties[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceToolPropertiesEXT.fnHandle == nil {
		vkGetPhysicalDeviceToolPropertiesEXT.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceToolPropertiesEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceToolPropertiesEXT.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pToolCount)), uintptr(unsafe.Pointer(pToolProperties)))
	r = Result(rsys)

	for i := range sl_pToolProperties {
		toolProperties[i] = *sl_pToolProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceToolPropertiesEXT = &vkCommand{"vkGetPhysicalDeviceToolPropertiesEXT", 3, true, nil}

// GetPipelineCacheData: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineCacheData.html
func GetPipelineCacheData(device Device, pipelineCache PipelineCache) (data []byte, r error) {
	// data is a double-call array output
	var dataSize uintptr
	pDataSize := &dataSize
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pData *byte
	var rsys uintptr

	if vkGetPipelineCacheData.fnHandle == nil {
		vkGetPipelineCacheData.fnHandle = dlHandle.NewProc("vkGetPipelineCacheData")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPipelineCacheData.fnHandle.Addr(), uintptr(device), uintptr(pipelineCache), uintptr(unsafe.Pointer(pDataSize)), uintptr(unsafe.Pointer(pData)))
	r = Result(rsys)

	sl_pData := make([]byte, dataSize)
	data = make([]byte, dataSize)
	pData = &sl_pData[0]

	// Trampoline call after last array allocation
	if vkGetPipelineCacheData.fnHandle == nil {
		vkGetPipelineCacheData.fnHandle = dlHandle.NewProc("vkGetPipelineCacheData")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPipelineCacheData.fnHandle.Addr(), uintptr(device), uintptr(pipelineCache), uintptr(unsafe.Pointer(pDataSize)), uintptr(unsafe.Pointer(pData)))
	r = Result(rsys)

	for i := range sl_pData {
		data[i] = *&sl_pData[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPipelineCacheData = &vkCommand{"vkGetPipelineCacheData", 4, true, nil}

// GetPipelineExecutableInternalRepresentationsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineExecutableInternalRepresentationsKHR.html
func GetPipelineExecutableInternalRepresentationsKHR(device Device, executableInfo *PipelineExecutableInfoKHR) (internalRepresentations []PipelineExecutableInternalRepresentationKHR, r error) {
	// Parameter is a singular input, requires translation - executableInfo
	var pExecutableInfo *_vkPipelineExecutableInfoKHR
	if executableInfo != nil {
		pExecutableInfo = executableInfo.Vulkanize()
	}

	// internalRepresentations is a double-call array output
	var internalRepresentationCount uint32
	pInternalRepresentationCount := &internalRepresentationCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pInternalRepresentations *_vkPipelineExecutableInternalRepresentationKHR
	var rsys uintptr

	if vkGetPipelineExecutableInternalRepresentationsKHR.fnHandle == nil {
		vkGetPipelineExecutableInternalRepresentationsKHR.fnHandle = dlHandle.NewProc("vkGetPipelineExecutableInternalRepresentationsKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPipelineExecutableInternalRepresentationsKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pExecutableInfo)), uintptr(unsafe.Pointer(pInternalRepresentationCount)), uintptr(unsafe.Pointer(pInternalRepresentations)))
	r = Result(rsys)

	sl_pInternalRepresentations := make([]_vkPipelineExecutableInternalRepresentationKHR, internalRepresentationCount)
	internalRepresentations = make([]PipelineExecutableInternalRepresentationKHR, internalRepresentationCount)
	pInternalRepresentations = &sl_pInternalRepresentations[0]

	// Trampoline call after last array allocation
	if vkGetPipelineExecutableInternalRepresentationsKHR.fnHandle == nil {
		vkGetPipelineExecutableInternalRepresentationsKHR.fnHandle = dlHandle.NewProc("vkGetPipelineExecutableInternalRepresentationsKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPipelineExecutableInternalRepresentationsKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pExecutableInfo)), uintptr(unsafe.Pointer(pInternalRepresentationCount)), uintptr(unsafe.Pointer(pInternalRepresentations)))
	r = Result(rsys)

	for i := range sl_pInternalRepresentations {
		internalRepresentations[i] = *sl_pInternalRepresentations[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPipelineExecutableInternalRepresentationsKHR = &vkCommand{"vkGetPipelineExecutableInternalRepresentationsKHR", 4, true, nil}

// GetPipelineExecutablePropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineExecutablePropertiesKHR.html
func GetPipelineExecutablePropertiesKHR(device Device, pipelineInfo *PipelineInfoKHR) (properties []PipelineExecutablePropertiesKHR, r error) {
	// Parameter is a singular input, requires translation - pipelineInfo
	var pPipelineInfo *_vkPipelineInfoKHR
	if pipelineInfo != nil {
		pPipelineInfo = pipelineInfo.Vulkanize()
	}

	// properties is a double-call array output
	var executableCount uint32
	pExecutableCount := &executableCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkPipelineExecutablePropertiesKHR
	var rsys uintptr

	if vkGetPipelineExecutablePropertiesKHR.fnHandle == nil {
		vkGetPipelineExecutablePropertiesKHR.fnHandle = dlHandle.NewProc("vkGetPipelineExecutablePropertiesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPipelineExecutablePropertiesKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pPipelineInfo)), uintptr(unsafe.Pointer(pExecutableCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	sl_pProperties := make([]_vkPipelineExecutablePropertiesKHR, executableCount)
	properties = make([]PipelineExecutablePropertiesKHR, executableCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	if vkGetPipelineExecutablePropertiesKHR.fnHandle == nil {
		vkGetPipelineExecutablePropertiesKHR.fnHandle = dlHandle.NewProc("vkGetPipelineExecutablePropertiesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPipelineExecutablePropertiesKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pPipelineInfo)), uintptr(unsafe.Pointer(pExecutableCount)), uintptr(unsafe.Pointer(pProperties)))
	r = Result(rsys)

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPipelineExecutablePropertiesKHR = &vkCommand{"vkGetPipelineExecutablePropertiesKHR", 4, true, nil}

// GetPipelineExecutableStatisticsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineExecutableStatisticsKHR.html
func GetPipelineExecutableStatisticsKHR(device Device, executableInfo *PipelineExecutableInfoKHR) (statistics []PipelineExecutableStatisticKHR, r error) {
	// Parameter is a singular input, requires translation - executableInfo
	var pExecutableInfo *_vkPipelineExecutableInfoKHR
	if executableInfo != nil {
		pExecutableInfo = executableInfo.Vulkanize()
	}

	// statistics is a double-call array output
	var statisticCount uint32
	pStatisticCount := &statisticCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pStatistics *_vkPipelineExecutableStatisticKHR
	var rsys uintptr

	if vkGetPipelineExecutableStatisticsKHR.fnHandle == nil {
		vkGetPipelineExecutableStatisticsKHR.fnHandle = dlHandle.NewProc("vkGetPipelineExecutableStatisticsKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPipelineExecutableStatisticsKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pExecutableInfo)), uintptr(unsafe.Pointer(pStatisticCount)), uintptr(unsafe.Pointer(pStatistics)))
	r = Result(rsys)

	sl_pStatistics := make([]_vkPipelineExecutableStatisticKHR, statisticCount)
	statistics = make([]PipelineExecutableStatisticKHR, statisticCount)
	pStatistics = &sl_pStatistics[0]

	// Trampoline call after last array allocation
	if vkGetPipelineExecutableStatisticsKHR.fnHandle == nil {
		vkGetPipelineExecutableStatisticsKHR.fnHandle = dlHandle.NewProc("vkGetPipelineExecutableStatisticsKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPipelineExecutableStatisticsKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pExecutableInfo)), uintptr(unsafe.Pointer(pStatisticCount)), uintptr(unsafe.Pointer(pStatistics)))
	r = Result(rsys)

	for i := range sl_pStatistics {
		statistics[i] = *sl_pStatistics[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPipelineExecutableStatisticsKHR = &vkCommand{"vkGetPipelineExecutableStatisticsKHR", 4, true, nil}

// GetPrivateDataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPrivateDataEXT.html
func GetPrivateDataEXT(device Device, objectType ObjectType, objectHandle uint64, privateDataSlot PrivateDataSlotEXT) (data uint64) {
	// data is a binding-allocated single return value and will be populated by Vulkan
	ptr_pData := &data

	if vkGetPrivateDataEXT.fnHandle == nil {
		vkGetPrivateDataEXT.fnHandle = dlHandle.NewProc("vkGetPrivateDataEXT")
	}
	syscall.SyscallN(vkGetPrivateDataEXT.fnHandle.Addr(), uintptr(device), uintptr(objectType), uintptr(objectHandle), uintptr(privateDataSlot), uintptr(unsafe.Pointer(ptr_pData)))

	return
}

var vkGetPrivateDataEXT = &vkCommand{"vkGetPrivateDataEXT", 5, true, nil}

// GetQueryPoolResults: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetQueryPoolResults.html
func GetQueryPoolResults(device Device, queryPool QueryPool, firstQuery uint32, queryCount uint32, data []byte, stride DeviceSize, flags QueryResultFlags) (r error) {
	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	var rsys uintptr

	if vkGetQueryPoolResults.fnHandle == nil {
		vkGetQueryPoolResults.fnHandle = dlHandle.NewProc("vkGetQueryPoolResults")
	}
	rsys, _, _ = syscall.SyscallN(vkGetQueryPoolResults.fnHandle.Addr(), uintptr(device), uintptr(queryPool), uintptr(firstQuery), uintptr(queryCount), uintptr(dataSize), uintptr(unsafe.Pointer(pData)), uintptr(stride), uintptr(flags))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetQueryPoolResults = &vkCommand{"vkGetQueryPoolResults", 8, true, nil}

// GetQueueCheckpointData2NV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetQueueCheckpointData2NV.html
func GetQueueCheckpointData2NV(queue Queue) (checkpointData []CheckpointData2NV) {
	// checkpointData is a double-call array output
	var checkpointDataCount uint32
	pCheckpointDataCount := &checkpointDataCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pCheckpointData *_vkCheckpointData2NV

	if vkGetQueueCheckpointData2NV.fnHandle == nil {
		vkGetQueueCheckpointData2NV.fnHandle = dlHandle.NewProc("vkGetQueueCheckpointData2NV")
	}
	syscall.SyscallN(vkGetQueueCheckpointData2NV.fnHandle.Addr(), uintptr(queue), uintptr(unsafe.Pointer(pCheckpointDataCount)), uintptr(unsafe.Pointer(pCheckpointData)))

	sl_pCheckpointData := make([]_vkCheckpointData2NV, checkpointDataCount)
	checkpointData = make([]CheckpointData2NV, checkpointDataCount)
	pCheckpointData = &sl_pCheckpointData[0]

	// Trampoline call after last array allocation
	if vkGetQueueCheckpointData2NV.fnHandle == nil {
		vkGetQueueCheckpointData2NV.fnHandle = dlHandle.NewProc("vkGetQueueCheckpointData2NV")
	}
	syscall.SyscallN(vkGetQueueCheckpointData2NV.fnHandle.Addr(), uintptr(queue), uintptr(unsafe.Pointer(pCheckpointDataCount)), uintptr(unsafe.Pointer(pCheckpointData)))

	for i := range sl_pCheckpointData {
		checkpointData[i] = *sl_pCheckpointData[i].Goify()
	}
	return
}

var vkGetQueueCheckpointData2NV = &vkCommand{"vkGetQueueCheckpointData2NV", 3, true, nil}

// GetQueueCheckpointDataNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetQueueCheckpointDataNV.html
func GetQueueCheckpointDataNV(queue Queue) (checkpointData []CheckpointDataNV) {
	// checkpointData is a double-call array output
	var checkpointDataCount uint32
	pCheckpointDataCount := &checkpointDataCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pCheckpointData *_vkCheckpointDataNV

	if vkGetQueueCheckpointDataNV.fnHandle == nil {
		vkGetQueueCheckpointDataNV.fnHandle = dlHandle.NewProc("vkGetQueueCheckpointDataNV")
	}
	syscall.SyscallN(vkGetQueueCheckpointDataNV.fnHandle.Addr(), uintptr(queue), uintptr(unsafe.Pointer(pCheckpointDataCount)), uintptr(unsafe.Pointer(pCheckpointData)))

	sl_pCheckpointData := make([]_vkCheckpointDataNV, checkpointDataCount)
	checkpointData = make([]CheckpointDataNV, checkpointDataCount)
	pCheckpointData = &sl_pCheckpointData[0]

	// Trampoline call after last array allocation
	if vkGetQueueCheckpointDataNV.fnHandle == nil {
		vkGetQueueCheckpointDataNV.fnHandle = dlHandle.NewProc("vkGetQueueCheckpointDataNV")
	}
	syscall.SyscallN(vkGetQueueCheckpointDataNV.fnHandle.Addr(), uintptr(queue), uintptr(unsafe.Pointer(pCheckpointDataCount)), uintptr(unsafe.Pointer(pCheckpointData)))

	for i := range sl_pCheckpointData {
		checkpointData[i] = *sl_pCheckpointData[i].Goify()
	}
	return
}

var vkGetQueueCheckpointDataNV = &vkCommand{"vkGetQueueCheckpointDataNV", 3, true, nil}

// GetRayTracingCaptureReplayShaderGroupHandlesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.html
func GetRayTracingCaptureReplayShaderGroupHandlesKHR(device Device, pipeline Pipeline, firstGroup uint32, groupCount uint32, data []byte) (r error) {
	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	var rsys uintptr

	if vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.fnHandle == nil {
		vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.fnHandle = dlHandle.NewProc("vkGetRayTracingCaptureReplayShaderGroupHandlesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.fnHandle.Addr(), uintptr(device), uintptr(pipeline), uintptr(firstGroup), uintptr(groupCount), uintptr(dataSize), uintptr(unsafe.Pointer(pData)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = &vkCommand{"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR", 6, true, nil}

// GetRayTracingShaderGroupHandlesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRayTracingShaderGroupHandlesKHR.html
func GetRayTracingShaderGroupHandlesKHR(device Device, pipeline Pipeline, firstGroup uint32, groupCount uint32, data []byte) (r error) {
	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	var rsys uintptr

	if vkGetRayTracingShaderGroupHandlesKHR.fnHandle == nil {
		vkGetRayTracingShaderGroupHandlesKHR.fnHandle = dlHandle.NewProc("vkGetRayTracingShaderGroupHandlesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetRayTracingShaderGroupHandlesKHR.fnHandle.Addr(), uintptr(device), uintptr(pipeline), uintptr(firstGroup), uintptr(groupCount), uintptr(dataSize), uintptr(unsafe.Pointer(pData)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetRayTracingShaderGroupHandlesKHR = &vkCommand{"vkGetRayTracingShaderGroupHandlesKHR", 6, true, nil}
var GetRayTracingShaderGroupHandlesNV = GetRayTracingShaderGroupHandlesKHR

// GetRayTracingShaderGroupStackSizeKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRayTracingShaderGroupStackSizeKHR.html
func GetRayTracingShaderGroupStackSizeKHR(device Device, pipeline Pipeline, group uint32, groupShader ShaderGroupShaderKHR) (deviceSize DeviceSize) {
	var rsys uintptr

	if vkGetRayTracingShaderGroupStackSizeKHR.fnHandle == nil {
		vkGetRayTracingShaderGroupStackSizeKHR.fnHandle = dlHandle.NewProc("vkGetRayTracingShaderGroupStackSizeKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetRayTracingShaderGroupStackSizeKHR.fnHandle.Addr(), uintptr(device), uintptr(pipeline), uintptr(group), uintptr(groupShader))
	deviceSize = DeviceSize(rsys)

	return
}

var vkGetRayTracingShaderGroupStackSizeKHR = &vkCommand{"vkGetRayTracingShaderGroupStackSizeKHR", 4, true, nil}

// GetRefreshCycleDurationGOOGLE: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRefreshCycleDurationGOOGLE.html
func GetRefreshCycleDurationGOOGLE(device Device, swapchain SwapchainKHR) (displayTimingProperties RefreshCycleDurationGOOGLE, r error) {
	// displayTimingProperties is a binding-allocated single return value and will be populated by Vulkan
	ptr_pDisplayTimingProperties := &displayTimingProperties

	var rsys uintptr

	if vkGetRefreshCycleDurationGOOGLE.fnHandle == nil {
		vkGetRefreshCycleDurationGOOGLE.fnHandle = dlHandle.NewProc("vkGetRefreshCycleDurationGOOGLE")
	}
	rsys, _, _ = syscall.SyscallN(vkGetRefreshCycleDurationGOOGLE.fnHandle.Addr(), uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(ptr_pDisplayTimingProperties)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetRefreshCycleDurationGOOGLE = &vkCommand{"vkGetRefreshCycleDurationGOOGLE", 3, true, nil}

// GetRenderAreaGranularity: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRenderAreaGranularity.html
func GetRenderAreaGranularity(device Device, renderPass RenderPass) (granularity Extent2D) {
	// granularity is a binding-allocated single return value and will be populated by Vulkan
	ptr_pGranularity := &granularity

	if vkGetRenderAreaGranularity.fnHandle == nil {
		vkGetRenderAreaGranularity.fnHandle = dlHandle.NewProc("vkGetRenderAreaGranularity")
	}
	syscall.SyscallN(vkGetRenderAreaGranularity.fnHandle.Addr(), uintptr(device), uintptr(renderPass), uintptr(unsafe.Pointer(ptr_pGranularity)))

	return
}

var vkGetRenderAreaGranularity = &vkCommand{"vkGetRenderAreaGranularity", 3, true, nil}

// GetSemaphoreCounterValue: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreCounterValue.html
func GetSemaphoreCounterValue(device Device, semaphore Semaphore) (value uint64, r error) {
	// value is a binding-allocated single return value and will be populated by Vulkan
	ptr_pValue := &value

	var rsys uintptr

	if vkGetSemaphoreCounterValue.fnHandle == nil {
		vkGetSemaphoreCounterValue.fnHandle = dlHandle.NewProc("vkGetSemaphoreCounterValue")
	}
	rsys, _, _ = syscall.SyscallN(vkGetSemaphoreCounterValue.fnHandle.Addr(), uintptr(device), uintptr(semaphore), uintptr(unsafe.Pointer(ptr_pValue)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetSemaphoreCounterValue = &vkCommand{"vkGetSemaphoreCounterValue", 3, true, nil}
var GetSemaphoreCounterValueKHR = GetSemaphoreCounterValue

// GetSemaphoreFdKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreFdKHR.html
func GetSemaphoreFdKHR(device Device, getFdInfo *SemaphoreGetFdInfoKHR) (fd int32, r error) {
	// Parameter is a singular input, requires translation - getFdInfo
	var pGetFdInfo *_vkSemaphoreGetFdInfoKHR
	if getFdInfo != nil {
		pGetFdInfo = getFdInfo.Vulkanize()
	}

	// fd is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFd := &fd

	var rsys uintptr

	if vkGetSemaphoreFdKHR.fnHandle == nil {
		vkGetSemaphoreFdKHR.fnHandle = dlHandle.NewProc("vkGetSemaphoreFdKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetSemaphoreFdKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pGetFdInfo)), uintptr(unsafe.Pointer(ptr_pFd)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetSemaphoreFdKHR = &vkCommand{"vkGetSemaphoreFdKHR", 3, true, nil}

// GetShaderInfoAMD: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetShaderInfoAMD.html
func GetShaderInfoAMD(device Device, pipeline Pipeline, shaderStage ShaderStageFlagBits, infoType ShaderInfoTypeAMD) (info []byte, r error) {
	// info is a double-call array output
	var infoSize uintptr
	pInfoSize := &infoSize
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pInfo *byte
	var rsys uintptr

	if vkGetShaderInfoAMD.fnHandle == nil {
		vkGetShaderInfoAMD.fnHandle = dlHandle.NewProc("vkGetShaderInfoAMD")
	}
	rsys, _, _ = syscall.SyscallN(vkGetShaderInfoAMD.fnHandle.Addr(), uintptr(device), uintptr(pipeline), uintptr(shaderStage), uintptr(infoType), uintptr(unsafe.Pointer(pInfoSize)), uintptr(unsafe.Pointer(pInfo)))
	r = Result(rsys)

	sl_pInfo := make([]byte, infoSize)
	info = make([]byte, infoSize)
	pInfo = &sl_pInfo[0]

	// Trampoline call after last array allocation
	if vkGetShaderInfoAMD.fnHandle == nil {
		vkGetShaderInfoAMD.fnHandle = dlHandle.NewProc("vkGetShaderInfoAMD")
	}
	rsys, _, _ = syscall.SyscallN(vkGetShaderInfoAMD.fnHandle.Addr(), uintptr(device), uintptr(pipeline), uintptr(shaderStage), uintptr(infoType), uintptr(unsafe.Pointer(pInfoSize)), uintptr(unsafe.Pointer(pInfo)))
	r = Result(rsys)

	for i := range sl_pInfo {
		info[i] = *&sl_pInfo[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetShaderInfoAMD = &vkCommand{"vkGetShaderInfoAMD", 6, true, nil}

// GetSwapchainCounterEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainCounterEXT.html
func GetSwapchainCounterEXT(device Device, swapchain SwapchainKHR, counter SurfaceCounterFlagBitsEXT) (counterValue uint64, r error) {
	// counterValue is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCounterValue := &counterValue

	var rsys uintptr

	if vkGetSwapchainCounterEXT.fnHandle == nil {
		vkGetSwapchainCounterEXT.fnHandle = dlHandle.NewProc("vkGetSwapchainCounterEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkGetSwapchainCounterEXT.fnHandle.Addr(), uintptr(device), uintptr(swapchain), uintptr(counter), uintptr(unsafe.Pointer(ptr_pCounterValue)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetSwapchainCounterEXT = &vkCommand{"vkGetSwapchainCounterEXT", 4, true, nil}

// GetSwapchainImagesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainImagesKHR.html
func GetSwapchainImagesKHR(device Device, swapchain SwapchainKHR) (swapchainImages []Image, r error) {
	// swapchainImages is a double-call array output
	var swapchainImageCount uint32
	pSwapchainImageCount := &swapchainImageCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSwapchainImages *Image
	var rsys uintptr

	if vkGetSwapchainImagesKHR.fnHandle == nil {
		vkGetSwapchainImagesKHR.fnHandle = dlHandle.NewProc("vkGetSwapchainImagesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetSwapchainImagesKHR.fnHandle.Addr(), uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pSwapchainImageCount)), uintptr(unsafe.Pointer(pSwapchainImages)))
	r = Result(rsys)

	sl_pSwapchainImages := make([]Image, swapchainImageCount)
	swapchainImages = make([]Image, swapchainImageCount)
	pSwapchainImages = &sl_pSwapchainImages[0]

	// Trampoline call after last array allocation
	if vkGetSwapchainImagesKHR.fnHandle == nil {
		vkGetSwapchainImagesKHR.fnHandle = dlHandle.NewProc("vkGetSwapchainImagesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetSwapchainImagesKHR.fnHandle.Addr(), uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pSwapchainImageCount)), uintptr(unsafe.Pointer(pSwapchainImages)))
	r = Result(rsys)

	for i := range sl_pSwapchainImages {
		swapchainImages[i] = *&sl_pSwapchainImages[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetSwapchainImagesKHR = &vkCommand{"vkGetSwapchainImagesKHR", 4, true, nil}

// GetSwapchainStatusKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainStatusKHR.html
func GetSwapchainStatusKHR(device Device, swapchain SwapchainKHR) (r error) {
	var rsys uintptr

	if vkGetSwapchainStatusKHR.fnHandle == nil {
		vkGetSwapchainStatusKHR.fnHandle = dlHandle.NewProc("vkGetSwapchainStatusKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetSwapchainStatusKHR.fnHandle.Addr(), uintptr(device), uintptr(swapchain))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetSwapchainStatusKHR = &vkCommand{"vkGetSwapchainStatusKHR", 2, true, nil}

// GetValidationCacheDataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetValidationCacheDataEXT.html
func GetValidationCacheDataEXT(device Device, validationCache ValidationCacheEXT) (data []byte, r error) {
	// data is a double-call array output
	var dataSize uintptr
	pDataSize := &dataSize
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pData *byte
	var rsys uintptr

	if vkGetValidationCacheDataEXT.fnHandle == nil {
		vkGetValidationCacheDataEXT.fnHandle = dlHandle.NewProc("vkGetValidationCacheDataEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkGetValidationCacheDataEXT.fnHandle.Addr(), uintptr(device), uintptr(validationCache), uintptr(unsafe.Pointer(pDataSize)), uintptr(unsafe.Pointer(pData)))
	r = Result(rsys)

	sl_pData := make([]byte, dataSize)
	data = make([]byte, dataSize)
	pData = &sl_pData[0]

	// Trampoline call after last array allocation
	if vkGetValidationCacheDataEXT.fnHandle == nil {
		vkGetValidationCacheDataEXT.fnHandle = dlHandle.NewProc("vkGetValidationCacheDataEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkGetValidationCacheDataEXT.fnHandle.Addr(), uintptr(device), uintptr(validationCache), uintptr(unsafe.Pointer(pDataSize)), uintptr(unsafe.Pointer(pData)))
	r = Result(rsys)

	for i := range sl_pData {
		data[i] = *&sl_pData[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetValidationCacheDataEXT = &vkCommand{"vkGetValidationCacheDataEXT", 4, true, nil}

// ImportFenceFdKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportFenceFdKHR.html
func ImportFenceFdKHR(device Device, importFenceFdInfo *ImportFenceFdInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - importFenceFdInfo
	var pImportFenceFdInfo *_vkImportFenceFdInfoKHR
	if importFenceFdInfo != nil {
		pImportFenceFdInfo = importFenceFdInfo.Vulkanize()
	}

	var rsys uintptr

	if vkImportFenceFdKHR.fnHandle == nil {
		vkImportFenceFdKHR.fnHandle = dlHandle.NewProc("vkImportFenceFdKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkImportFenceFdKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pImportFenceFdInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkImportFenceFdKHR = &vkCommand{"vkImportFenceFdKHR", 2, true, nil}

// ImportSemaphoreFdKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportSemaphoreFdKHR.html
func ImportSemaphoreFdKHR(device Device, importSemaphoreFdInfo *ImportSemaphoreFdInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - importSemaphoreFdInfo
	var pImportSemaphoreFdInfo *_vkImportSemaphoreFdInfoKHR
	if importSemaphoreFdInfo != nil {
		pImportSemaphoreFdInfo = importSemaphoreFdInfo.Vulkanize()
	}

	var rsys uintptr

	if vkImportSemaphoreFdKHR.fnHandle == nil {
		vkImportSemaphoreFdKHR.fnHandle = dlHandle.NewProc("vkImportSemaphoreFdKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkImportSemaphoreFdKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pImportSemaphoreFdInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkImportSemaphoreFdKHR = &vkCommand{"vkImportSemaphoreFdKHR", 2, true, nil}

// InitializePerformanceApiINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkInitializePerformanceApiINTEL.html
func InitializePerformanceApiINTEL(device Device, initializeInfo *InitializePerformanceApiInfoINTEL) (r error) {
	// Parameter is a singular input, requires translation - initializeInfo
	var pInitializeInfo *_vkInitializePerformanceApiInfoINTEL
	if initializeInfo != nil {
		pInitializeInfo = initializeInfo.Vulkanize()
	}

	var rsys uintptr

	if vkInitializePerformanceApiINTEL.fnHandle == nil {
		vkInitializePerformanceApiINTEL.fnHandle = dlHandle.NewProc("vkInitializePerformanceApiINTEL")
	}
	rsys, _, _ = syscall.SyscallN(vkInitializePerformanceApiINTEL.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pInitializeInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkInitializePerformanceApiINTEL = &vkCommand{"vkInitializePerformanceApiINTEL", 2, true, nil}

// InvalidateMappedMemoryRanges: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkInvalidateMappedMemoryRanges.html
func InvalidateMappedMemoryRanges(device Device, memoryRanges []MappedMemoryRange) (r error) {
	memoryRangeCount := len(memoryRanges)
	// memoryRanges is an input slice that requires translation to an internal type
	var pMemoryRanges unsafe.Pointer
	if len(memoryRanges) > 0 {
		sl_memoryRanges := make([]_vkMappedMemoryRange, memoryRangeCount)
		for i, v := range memoryRanges {
			sl_memoryRanges[i] = *(v.Vulkanize())
		}
		pMemoryRanges = unsafe.Pointer(&sl_memoryRanges[0])
	}

	var rsys uintptr

	if vkInvalidateMappedMemoryRanges.fnHandle == nil {
		vkInvalidateMappedMemoryRanges.fnHandle = dlHandle.NewProc("vkInvalidateMappedMemoryRanges")
	}
	rsys, _, _ = syscall.SyscallN(vkInvalidateMappedMemoryRanges.fnHandle.Addr(), uintptr(device), uintptr(memoryRangeCount), uintptr(unsafe.Pointer(pMemoryRanges)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkInvalidateMappedMemoryRanges = &vkCommand{"vkInvalidateMappedMemoryRanges", 3, true, nil}

// MapMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMapMemory.html
func MapMemory(device Device, memory DeviceMemory, offset DeviceSize, size DeviceSize, flags MemoryMapFlags) (pData *byte, r error) {
	// pData is a binding-allocated single return value and will be populated by Vulkan
	ptr_ppData := &pData

	var rsys uintptr

	if vkMapMemory.fnHandle == nil {
		vkMapMemory.fnHandle = dlHandle.NewProc("vkMapMemory")
	}
	rsys, _, _ = syscall.SyscallN(vkMapMemory.fnHandle.Addr(), uintptr(device), uintptr(memory), uintptr(offset), uintptr(size), uintptr(flags), uintptr(unsafe.Pointer(ptr_ppData)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkMapMemory = &vkCommand{"vkMapMemory", 6, true, nil}

// MergePipelineCaches: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMergePipelineCaches.html
func MergePipelineCaches(device Device, dstCache PipelineCache, srcCaches []PipelineCache) (r error) {
	srcCacheCount := len(srcCaches)
	// srcCaches is an input slice of values that do not need translation used
	var pSrcCaches unsafe.Pointer
	if srcCaches != nil {
		pSrcCaches = unsafe.Pointer(&srcCaches[0])
	}

	var rsys uintptr

	if vkMergePipelineCaches.fnHandle == nil {
		vkMergePipelineCaches.fnHandle = dlHandle.NewProc("vkMergePipelineCaches")
	}
	rsys, _, _ = syscall.SyscallN(vkMergePipelineCaches.fnHandle.Addr(), uintptr(device), uintptr(dstCache), uintptr(srcCacheCount), uintptr(unsafe.Pointer(pSrcCaches)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkMergePipelineCaches = &vkCommand{"vkMergePipelineCaches", 4, true, nil}

// MergeValidationCachesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMergeValidationCachesEXT.html
func MergeValidationCachesEXT(device Device, dstCache ValidationCacheEXT, srcCaches []ValidationCacheEXT) (r error) {
	srcCacheCount := len(srcCaches)
	// srcCaches is an input slice of values that do not need translation used
	var pSrcCaches unsafe.Pointer
	if srcCaches != nil {
		pSrcCaches = unsafe.Pointer(&srcCaches[0])
	}

	var rsys uintptr

	if vkMergeValidationCachesEXT.fnHandle == nil {
		vkMergeValidationCachesEXT.fnHandle = dlHandle.NewProc("vkMergeValidationCachesEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkMergeValidationCachesEXT.fnHandle.Addr(), uintptr(device), uintptr(dstCache), uintptr(srcCacheCount), uintptr(unsafe.Pointer(pSrcCaches)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkMergeValidationCachesEXT = &vkCommand{"vkMergeValidationCachesEXT", 4, true, nil}

// QueueBeginDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueBeginDebugUtilsLabelEXT.html
func QueueBeginDebugUtilsLabelEXT(queue Queue, labelInfo *DebugUtilsLabelEXT) {
	// Parameter is a singular input, requires translation - labelInfo
	var pLabelInfo *_vkDebugUtilsLabelEXT
	if labelInfo != nil {
		pLabelInfo = labelInfo.Vulkanize()
	}

	if vkQueueBeginDebugUtilsLabelEXT.fnHandle == nil {
		vkQueueBeginDebugUtilsLabelEXT.fnHandle = dlHandle.NewProc("vkQueueBeginDebugUtilsLabelEXT")
	}
	syscall.SyscallN(vkQueueBeginDebugUtilsLabelEXT.fnHandle.Addr(), uintptr(queue), uintptr(unsafe.Pointer(pLabelInfo)))

}

var vkQueueBeginDebugUtilsLabelEXT = &vkCommand{"vkQueueBeginDebugUtilsLabelEXT", 2, true, nil}

// QueueBindSparse: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueBindSparse.html
func QueueBindSparse(queue Queue, bindInfo []BindSparseInfo, fence Fence) (r error) {
	bindInfoCount := len(bindInfo)
	// bindInfo is an input slice that requires translation to an internal type
	var pBindInfo unsafe.Pointer
	if len(bindInfo) > 0 {
		sl_bindInfo := make([]_vkBindSparseInfo, bindInfoCount)
		for i, v := range bindInfo {
			sl_bindInfo[i] = *(v.Vulkanize())
		}
		pBindInfo = unsafe.Pointer(&sl_bindInfo[0])
	}

	var rsys uintptr

	if vkQueueBindSparse.fnHandle == nil {
		vkQueueBindSparse.fnHandle = dlHandle.NewProc("vkQueueBindSparse")
	}
	rsys, _, _ = syscall.SyscallN(vkQueueBindSparse.fnHandle.Addr(), uintptr(queue), uintptr(bindInfoCount), uintptr(unsafe.Pointer(pBindInfo)), uintptr(fence))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkQueueBindSparse = &vkCommand{"vkQueueBindSparse", 4, true, nil}

// QueueEndDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueEndDebugUtilsLabelEXT.html
func QueueEndDebugUtilsLabelEXT(queue Queue) {

	if vkQueueEndDebugUtilsLabelEXT.fnHandle == nil {
		vkQueueEndDebugUtilsLabelEXT.fnHandle = dlHandle.NewProc("vkQueueEndDebugUtilsLabelEXT")
	}
	syscall.SyscallN(vkQueueEndDebugUtilsLabelEXT.fnHandle.Addr(), uintptr(queue))

}

var vkQueueEndDebugUtilsLabelEXT = &vkCommand{"vkQueueEndDebugUtilsLabelEXT", 1, true, nil}

// QueueInsertDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueInsertDebugUtilsLabelEXT.html
func QueueInsertDebugUtilsLabelEXT(queue Queue, labelInfo *DebugUtilsLabelEXT) {
	// Parameter is a singular input, requires translation - labelInfo
	var pLabelInfo *_vkDebugUtilsLabelEXT
	if labelInfo != nil {
		pLabelInfo = labelInfo.Vulkanize()
	}

	if vkQueueInsertDebugUtilsLabelEXT.fnHandle == nil {
		vkQueueInsertDebugUtilsLabelEXT.fnHandle = dlHandle.NewProc("vkQueueInsertDebugUtilsLabelEXT")
	}
	syscall.SyscallN(vkQueueInsertDebugUtilsLabelEXT.fnHandle.Addr(), uintptr(queue), uintptr(unsafe.Pointer(pLabelInfo)))

}

var vkQueueInsertDebugUtilsLabelEXT = &vkCommand{"vkQueueInsertDebugUtilsLabelEXT", 2, true, nil}

// QueuePresentKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html
func QueuePresentKHR(queue Queue, presentInfo *PresentInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - presentInfo
	var pPresentInfo *_vkPresentInfoKHR
	if presentInfo != nil {
		pPresentInfo = presentInfo.Vulkanize()
	}

	var rsys uintptr

	if vkQueuePresentKHR.fnHandle == nil {
		vkQueuePresentKHR.fnHandle = dlHandle.NewProc("vkQueuePresentKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkQueuePresentKHR.fnHandle.Addr(), uintptr(queue), uintptr(unsafe.Pointer(pPresentInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkQueuePresentKHR = &vkCommand{"vkQueuePresentKHR", 2, true, nil}

// QueueSetPerformanceConfigurationINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSetPerformanceConfigurationINTEL.html
func QueueSetPerformanceConfigurationINTEL(queue Queue, configuration PerformanceConfigurationINTEL) (r error) {
	var rsys uintptr

	if vkQueueSetPerformanceConfigurationINTEL.fnHandle == nil {
		vkQueueSetPerformanceConfigurationINTEL.fnHandle = dlHandle.NewProc("vkQueueSetPerformanceConfigurationINTEL")
	}
	rsys, _, _ = syscall.SyscallN(vkQueueSetPerformanceConfigurationINTEL.fnHandle.Addr(), uintptr(queue), uintptr(configuration))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkQueueSetPerformanceConfigurationINTEL = &vkCommand{"vkQueueSetPerformanceConfigurationINTEL", 2, true, nil}

// QueueSubmit: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit.html
func QueueSubmit(queue Queue, submits []SubmitInfo, fence Fence) (r error) {
	submitCount := len(submits)
	// submits is an input slice that requires translation to an internal type
	var pSubmits unsafe.Pointer
	if len(submits) > 0 {
		sl_submits := make([]_vkSubmitInfo, submitCount)
		for i, v := range submits {
			sl_submits[i] = *(v.Vulkanize())
		}
		pSubmits = unsafe.Pointer(&sl_submits[0])
	}

	var rsys uintptr

	if vkQueueSubmit.fnHandle == nil {
		vkQueueSubmit.fnHandle = dlHandle.NewProc("vkQueueSubmit")
	}
	rsys, _, _ = syscall.SyscallN(vkQueueSubmit.fnHandle.Addr(), uintptr(queue), uintptr(submitCount), uintptr(unsafe.Pointer(pSubmits)), uintptr(fence))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkQueueSubmit = &vkCommand{"vkQueueSubmit", 4, true, nil}

// QueueSubmit2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit2KHR.html
func QueueSubmit2KHR(queue Queue, submits []SubmitInfo2KHR, fence Fence) (r error) {
	submitCount := len(submits)
	// submits is an input slice that requires translation to an internal type
	var pSubmits unsafe.Pointer
	if len(submits) > 0 {
		sl_submits := make([]_vkSubmitInfo2KHR, submitCount)
		for i, v := range submits {
			sl_submits[i] = *(v.Vulkanize())
		}
		pSubmits = unsafe.Pointer(&sl_submits[0])
	}

	var rsys uintptr

	if vkQueueSubmit2KHR.fnHandle == nil {
		vkQueueSubmit2KHR.fnHandle = dlHandle.NewProc("vkQueueSubmit2KHR")
	}
	rsys, _, _ = syscall.SyscallN(vkQueueSubmit2KHR.fnHandle.Addr(), uintptr(queue), uintptr(submitCount), uintptr(unsafe.Pointer(pSubmits)), uintptr(fence))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkQueueSubmit2KHR = &vkCommand{"vkQueueSubmit2KHR", 4, true, nil}

// QueueWaitIdle: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueWaitIdle.html
func QueueWaitIdle(queue Queue) (r error) {
	var rsys uintptr

	if vkQueueWaitIdle.fnHandle == nil {
		vkQueueWaitIdle.fnHandle = dlHandle.NewProc("vkQueueWaitIdle")
	}
	rsys, _, _ = syscall.SyscallN(vkQueueWaitIdle.fnHandle.Addr(), uintptr(queue))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkQueueWaitIdle = &vkCommand{"vkQueueWaitIdle", 1, true, nil}

// RegisterDeviceEventEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkRegisterDeviceEventEXT.html
func RegisterDeviceEventEXT(device Device, deviceEventInfo *DeviceEventInfoEXT, allocator *AllocationCallbacks) (fence Fence, r error) {
	// Parameter is a singular input, requires translation - deviceEventInfo
	var pDeviceEventInfo *_vkDeviceEventInfoEXT
	if deviceEventInfo != nil {
		pDeviceEventInfo = deviceEventInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// fence is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFence := &fence

	var rsys uintptr

	if vkRegisterDeviceEventEXT.fnHandle == nil {
		vkRegisterDeviceEventEXT.fnHandle = dlHandle.NewProc("vkRegisterDeviceEventEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkRegisterDeviceEventEXT.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pDeviceEventInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pFence)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkRegisterDeviceEventEXT = &vkCommand{"vkRegisterDeviceEventEXT", 4, true, nil}

// RegisterDisplayEventEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkRegisterDisplayEventEXT.html
func RegisterDisplayEventEXT(device Device, display DisplayKHR, displayEventInfo *DisplayEventInfoEXT, allocator *AllocationCallbacks) (fence Fence, r error) {
	// Parameter is a singular input, requires translation - displayEventInfo
	var pDisplayEventInfo *_vkDisplayEventInfoEXT
	if displayEventInfo != nil {
		pDisplayEventInfo = displayEventInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// fence is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFence := &fence

	var rsys uintptr

	if vkRegisterDisplayEventEXT.fnHandle == nil {
		vkRegisterDisplayEventEXT.fnHandle = dlHandle.NewProc("vkRegisterDisplayEventEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkRegisterDisplayEventEXT.fnHandle.Addr(), uintptr(device), uintptr(display), uintptr(unsafe.Pointer(pDisplayEventInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pFence)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkRegisterDisplayEventEXT = &vkCommand{"vkRegisterDisplayEventEXT", 5, true, nil}

// ReleaseDisplayEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleaseDisplayEXT.html
func ReleaseDisplayEXT(physicalDevice PhysicalDevice, display DisplayKHR) (r error) {
	var rsys uintptr

	if vkReleaseDisplayEXT.fnHandle == nil {
		vkReleaseDisplayEXT.fnHandle = dlHandle.NewProc("vkReleaseDisplayEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkReleaseDisplayEXT.fnHandle.Addr(), uintptr(physicalDevice), uintptr(display))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkReleaseDisplayEXT = &vkCommand{"vkReleaseDisplayEXT", 2, true, nil}

// ReleasePerformanceConfigurationINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleasePerformanceConfigurationINTEL.html
func ReleasePerformanceConfigurationINTEL(device Device, configuration PerformanceConfigurationINTEL) (r error) {
	var rsys uintptr

	if vkReleasePerformanceConfigurationINTEL.fnHandle == nil {
		vkReleasePerformanceConfigurationINTEL.fnHandle = dlHandle.NewProc("vkReleasePerformanceConfigurationINTEL")
	}
	rsys, _, _ = syscall.SyscallN(vkReleasePerformanceConfigurationINTEL.fnHandle.Addr(), uintptr(device), uintptr(configuration))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkReleasePerformanceConfigurationINTEL = &vkCommand{"vkReleasePerformanceConfigurationINTEL", 2, true, nil}

// ReleaseProfilingLockKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleaseProfilingLockKHR.html
func ReleaseProfilingLockKHR(device Device) {

	if vkReleaseProfilingLockKHR.fnHandle == nil {
		vkReleaseProfilingLockKHR.fnHandle = dlHandle.NewProc("vkReleaseProfilingLockKHR")
	}
	syscall.SyscallN(vkReleaseProfilingLockKHR.fnHandle.Addr(), uintptr(device))

}

var vkReleaseProfilingLockKHR = &vkCommand{"vkReleaseProfilingLockKHR", 1, true, nil}

// ResetCommandBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html
func ResetCommandBuffer(commandBuffer CommandBuffer, flags CommandBufferResetFlags) (r error) {
	var rsys uintptr

	if vkResetCommandBuffer.fnHandle == nil {
		vkResetCommandBuffer.fnHandle = dlHandle.NewProc("vkResetCommandBuffer")
	}
	rsys, _, _ = syscall.SyscallN(vkResetCommandBuffer.fnHandle.Addr(), uintptr(commandBuffer), uintptr(flags))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkResetCommandBuffer = &vkCommand{"vkResetCommandBuffer", 2, true, nil}

// ResetCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetCommandPool.html
func ResetCommandPool(device Device, commandPool CommandPool, flags CommandPoolResetFlags) (r error) {
	var rsys uintptr

	if vkResetCommandPool.fnHandle == nil {
		vkResetCommandPool.fnHandle = dlHandle.NewProc("vkResetCommandPool")
	}
	rsys, _, _ = syscall.SyscallN(vkResetCommandPool.fnHandle.Addr(), uintptr(device), uintptr(commandPool), uintptr(flags))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkResetCommandPool = &vkCommand{"vkResetCommandPool", 3, true, nil}

// ResetDescriptorPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetDescriptorPool.html
func ResetDescriptorPool(device Device, descriptorPool DescriptorPool, flags DescriptorPoolResetFlags) (r error) {
	var rsys uintptr

	if vkResetDescriptorPool.fnHandle == nil {
		vkResetDescriptorPool.fnHandle = dlHandle.NewProc("vkResetDescriptorPool")
	}
	rsys, _, _ = syscall.SyscallN(vkResetDescriptorPool.fnHandle.Addr(), uintptr(device), uintptr(descriptorPool), uintptr(flags))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkResetDescriptorPool = &vkCommand{"vkResetDescriptorPool", 3, true, nil}

// ResetEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetEvent.html
func ResetEvent(device Device, event Event) (r error) {
	var rsys uintptr

	if vkResetEvent.fnHandle == nil {
		vkResetEvent.fnHandle = dlHandle.NewProc("vkResetEvent")
	}
	rsys, _, _ = syscall.SyscallN(vkResetEvent.fnHandle.Addr(), uintptr(device), uintptr(event))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkResetEvent = &vkCommand{"vkResetEvent", 2, true, nil}

// ResetFences: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetFences.html
func ResetFences(device Device, fences []Fence) (r error) {
	fenceCount := len(fences)
	// fences is an input slice of values that do not need translation used
	var pFences unsafe.Pointer
	if fences != nil {
		pFences = unsafe.Pointer(&fences[0])
	}

	var rsys uintptr

	if vkResetFences.fnHandle == nil {
		vkResetFences.fnHandle = dlHandle.NewProc("vkResetFences")
	}
	rsys, _, _ = syscall.SyscallN(vkResetFences.fnHandle.Addr(), uintptr(device), uintptr(fenceCount), uintptr(unsafe.Pointer(pFences)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkResetFences = &vkCommand{"vkResetFences", 3, true, nil}

// ResetQueryPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetQueryPool.html
func ResetQueryPool(device Device, queryPool QueryPool, firstQuery uint32, queryCount uint32) {

	if vkResetQueryPool.fnHandle == nil {
		vkResetQueryPool.fnHandle = dlHandle.NewProc("vkResetQueryPool")
	}
	syscall.SyscallN(vkResetQueryPool.fnHandle.Addr(), uintptr(device), uintptr(queryPool), uintptr(firstQuery), uintptr(queryCount))

}

var vkResetQueryPool = &vkCommand{"vkResetQueryPool", 4, true, nil}
var ResetQueryPoolEXT = ResetQueryPool

// SetDebugUtilsObjectNameEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetDebugUtilsObjectNameEXT.html
func SetDebugUtilsObjectNameEXT(device Device, nameInfo *DebugUtilsObjectNameInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - nameInfo
	var pNameInfo *_vkDebugUtilsObjectNameInfoEXT
	if nameInfo != nil {
		pNameInfo = nameInfo.Vulkanize()
	}

	var rsys uintptr

	if vkSetDebugUtilsObjectNameEXT.fnHandle == nil {
		vkSetDebugUtilsObjectNameEXT.fnHandle = dlHandle.NewProc("vkSetDebugUtilsObjectNameEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkSetDebugUtilsObjectNameEXT.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pNameInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkSetDebugUtilsObjectNameEXT = &vkCommand{"vkSetDebugUtilsObjectNameEXT", 2, true, nil}

// SetDebugUtilsObjectTagEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetDebugUtilsObjectTagEXT.html
func SetDebugUtilsObjectTagEXT(device Device, tagInfo *DebugUtilsObjectTagInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - tagInfo
	var pTagInfo *_vkDebugUtilsObjectTagInfoEXT
	if tagInfo != nil {
		pTagInfo = tagInfo.Vulkanize()
	}

	var rsys uintptr

	if vkSetDebugUtilsObjectTagEXT.fnHandle == nil {
		vkSetDebugUtilsObjectTagEXT.fnHandle = dlHandle.NewProc("vkSetDebugUtilsObjectTagEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkSetDebugUtilsObjectTagEXT.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pTagInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkSetDebugUtilsObjectTagEXT = &vkCommand{"vkSetDebugUtilsObjectTagEXT", 2, true, nil}

// SetDeviceMemoryPriorityEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetDeviceMemoryPriorityEXT.html
func SetDeviceMemoryPriorityEXT(device Device, memory DeviceMemory, priority float32) {

	if vkSetDeviceMemoryPriorityEXT.fnHandle == nil {
		vkSetDeviceMemoryPriorityEXT.fnHandle = dlHandle.NewProc("vkSetDeviceMemoryPriorityEXT")
	}
	syscall.SyscallN(vkSetDeviceMemoryPriorityEXT.fnHandle.Addr(), uintptr(device), uintptr(memory), uintptr(priority))

}

var vkSetDeviceMemoryPriorityEXT = &vkCommand{"vkSetDeviceMemoryPriorityEXT", 3, true, nil}

// SetEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetEvent.html
func SetEvent(device Device, event Event) (r error) {
	var rsys uintptr

	if vkSetEvent.fnHandle == nil {
		vkSetEvent.fnHandle = dlHandle.NewProc("vkSetEvent")
	}
	rsys, _, _ = syscall.SyscallN(vkSetEvent.fnHandle.Addr(), uintptr(device), uintptr(event))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkSetEvent = &vkCommand{"vkSetEvent", 2, true, nil}

// SetHdrMetadataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetHdrMetadataEXT.html
func SetHdrMetadataEXT(device Device, swapchains []SwapchainKHR, metadata []HdrMetadataEXT) {
	swapchainCount := len(swapchains)
	// swapchains is an input slice of values that do not need translation used
	var pSwapchains unsafe.Pointer
	if swapchains != nil {
		pSwapchains = unsafe.Pointer(&swapchains[0])
	}

	// metadata is an input slice that requires translation to an internal type
	var pMetadata unsafe.Pointer
	if len(metadata) > 0 {
		sl_metadata := make([]_vkHdrMetadataEXT, swapchainCount)
		for i, v := range metadata {
			sl_metadata[i] = *(v.Vulkanize())
		}
		pMetadata = unsafe.Pointer(&sl_metadata[0])
	}

	if vkSetHdrMetadataEXT.fnHandle == nil {
		vkSetHdrMetadataEXT.fnHandle = dlHandle.NewProc("vkSetHdrMetadataEXT")
	}
	syscall.SyscallN(vkSetHdrMetadataEXT.fnHandle.Addr(), uintptr(device), uintptr(swapchainCount), uintptr(unsafe.Pointer(pSwapchains)), uintptr(unsafe.Pointer(pMetadata)))

}

var vkSetHdrMetadataEXT = &vkCommand{"vkSetHdrMetadataEXT", 4, true, nil}

// SetLocalDimmingAMD: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetLocalDimmingAMD.html
func SetLocalDimmingAMD(device Device, swapChain SwapchainKHR, localDimmingEnable bool) {
	localDimmingEnable_Bool32 := translateInternal_Bool32(localDimmingEnable)

	if vkSetLocalDimmingAMD.fnHandle == nil {
		vkSetLocalDimmingAMD.fnHandle = dlHandle.NewProc("vkSetLocalDimmingAMD")
	}
	syscall.SyscallN(vkSetLocalDimmingAMD.fnHandle.Addr(), uintptr(device), uintptr(swapChain), uintptr(localDimmingEnable_Bool32))

}

var vkSetLocalDimmingAMD = &vkCommand{"vkSetLocalDimmingAMD", 3, true, nil}

// SetPrivateDataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetPrivateDataEXT.html
func SetPrivateDataEXT(device Device, objectType ObjectType, objectHandle uint64, privateDataSlot PrivateDataSlotEXT, data uint64) (r error) {
	var rsys uintptr

	if vkSetPrivateDataEXT.fnHandle == nil {
		vkSetPrivateDataEXT.fnHandle = dlHandle.NewProc("vkSetPrivateDataEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkSetPrivateDataEXT.fnHandle.Addr(), uintptr(device), uintptr(objectType), uintptr(objectHandle), uintptr(privateDataSlot), uintptr(data))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkSetPrivateDataEXT = &vkCommand{"vkSetPrivateDataEXT", 5, true, nil}

// SignalSemaphore: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSignalSemaphore.html
func SignalSemaphore(device Device, signalInfo *SemaphoreSignalInfo) (r error) {
	// Parameter is a singular input, requires translation - signalInfo
	var pSignalInfo *_vkSemaphoreSignalInfo
	if signalInfo != nil {
		pSignalInfo = signalInfo.Vulkanize()
	}

	var rsys uintptr

	if vkSignalSemaphore.fnHandle == nil {
		vkSignalSemaphore.fnHandle = dlHandle.NewProc("vkSignalSemaphore")
	}
	rsys, _, _ = syscall.SyscallN(vkSignalSemaphore.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pSignalInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkSignalSemaphore = &vkCommand{"vkSignalSemaphore", 2, true, nil}
var SignalSemaphoreKHR = SignalSemaphore

// SubmitDebugUtilsMessageEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSubmitDebugUtilsMessageEXT.html
func SubmitDebugUtilsMessageEXT(instance Instance, messageSeverity DebugUtilsMessageSeverityFlagBitsEXT, messageTypes DebugUtilsMessageTypeFlagsEXT, callbackData *DebugUtilsMessengerCallbackDataEXT) {
	// Parameter is a singular input, requires translation - callbackData
	var pCallbackData *_vkDebugUtilsMessengerCallbackDataEXT
	if callbackData != nil {
		pCallbackData = callbackData.Vulkanize()
	}

	if vkSubmitDebugUtilsMessageEXT.fnHandle == nil {
		vkSubmitDebugUtilsMessageEXT.fnHandle = dlHandle.NewProc("vkSubmitDebugUtilsMessageEXT")
	}
	syscall.SyscallN(vkSubmitDebugUtilsMessageEXT.fnHandle.Addr(), uintptr(instance), uintptr(messageSeverity), uintptr(messageTypes), uintptr(unsafe.Pointer(pCallbackData)))

}

var vkSubmitDebugUtilsMessageEXT = &vkCommand{"vkSubmitDebugUtilsMessageEXT", 4, true, nil}

// TrimCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkTrimCommandPool.html
func TrimCommandPool(device Device, commandPool CommandPool, flags CommandPoolTrimFlags) {

	if vkTrimCommandPool.fnHandle == nil {
		vkTrimCommandPool.fnHandle = dlHandle.NewProc("vkTrimCommandPool")
	}
	syscall.SyscallN(vkTrimCommandPool.fnHandle.Addr(), uintptr(device), uintptr(commandPool), uintptr(flags))

}

var vkTrimCommandPool = &vkCommand{"vkTrimCommandPool", 3, true, nil}
var TrimCommandPoolKHR = TrimCommandPool

// UninitializePerformanceApiINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUninitializePerformanceApiINTEL.html
func UninitializePerformanceApiINTEL(device Device) {

	if vkUninitializePerformanceApiINTEL.fnHandle == nil {
		vkUninitializePerformanceApiINTEL.fnHandle = dlHandle.NewProc("vkUninitializePerformanceApiINTEL")
	}
	syscall.SyscallN(vkUninitializePerformanceApiINTEL.fnHandle.Addr(), uintptr(device))

}

var vkUninitializePerformanceApiINTEL = &vkCommand{"vkUninitializePerformanceApiINTEL", 1, true, nil}

// UnmapMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUnmapMemory.html
func UnmapMemory(device Device, memory DeviceMemory) {

	if vkUnmapMemory.fnHandle == nil {
		vkUnmapMemory.fnHandle = dlHandle.NewProc("vkUnmapMemory")
	}
	syscall.SyscallN(vkUnmapMemory.fnHandle.Addr(), uintptr(device), uintptr(memory))

}

var vkUnmapMemory = &vkCommand{"vkUnmapMemory", 2, true, nil}

// UpdateDescriptorSetWithTemplate: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateDescriptorSetWithTemplate.html
func UpdateDescriptorSetWithTemplate(device Device, descriptorSet DescriptorSet, descriptorUpdateTemplate DescriptorUpdateTemplate, data *byte) {
	// Parameter is a singular input, pass direct - data
	var pData unsafe.Pointer
	if data != nil {
		pData = unsafe.Pointer(data)
	}

	if vkUpdateDescriptorSetWithTemplate.fnHandle == nil {
		vkUpdateDescriptorSetWithTemplate.fnHandle = dlHandle.NewProc("vkUpdateDescriptorSetWithTemplate")
	}
	syscall.SyscallN(vkUpdateDescriptorSetWithTemplate.fnHandle.Addr(), uintptr(device), uintptr(descriptorSet), uintptr(descriptorUpdateTemplate), uintptr(unsafe.Pointer(pData)))

}

var vkUpdateDescriptorSetWithTemplate = &vkCommand{"vkUpdateDescriptorSetWithTemplate", 4, true, nil}
var UpdateDescriptorSetWithTemplateKHR = UpdateDescriptorSetWithTemplate

// UpdateDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateDescriptorSets.html
func UpdateDescriptorSets(device Device, descriptorWrites []WriteDescriptorSet, descriptorCopies []CopyDescriptorSet) {
	descriptorWriteCount := len(descriptorWrites)
	// descriptorWrites is an input slice that requires translation to an internal type
	var pDescriptorWrites unsafe.Pointer
	if len(descriptorWrites) > 0 {
		sl_descriptorWrites := make([]_vkWriteDescriptorSet, descriptorWriteCount)
		for i, v := range descriptorWrites {
			sl_descriptorWrites[i] = *(v.Vulkanize())
		}
		pDescriptorWrites = unsafe.Pointer(&sl_descriptorWrites[0])
	}

	descriptorCopyCount := len(descriptorCopies)
	// descriptorCopies is an input slice that requires translation to an internal type
	var pDescriptorCopies unsafe.Pointer
	if len(descriptorCopies) > 0 {
		sl_descriptorCopies := make([]_vkCopyDescriptorSet, descriptorCopyCount)
		for i, v := range descriptorCopies {
			sl_descriptorCopies[i] = *(v.Vulkanize())
		}
		pDescriptorCopies = unsafe.Pointer(&sl_descriptorCopies[0])
	}

	if vkUpdateDescriptorSets.fnHandle == nil {
		vkUpdateDescriptorSets.fnHandle = dlHandle.NewProc("vkUpdateDescriptorSets")
	}
	syscall.SyscallN(vkUpdateDescriptorSets.fnHandle.Addr(), uintptr(device), uintptr(descriptorWriteCount), uintptr(unsafe.Pointer(pDescriptorWrites)), uintptr(descriptorCopyCount), uintptr(unsafe.Pointer(pDescriptorCopies)))

}

var vkUpdateDescriptorSets = &vkCommand{"vkUpdateDescriptorSets", 5, true, nil}

// WaitForFences: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html
func WaitForFences(device Device, fences []Fence, waitAll bool, timeout uint64) (r error) {
	fenceCount := len(fences)
	// fences is an input slice of values that do not need translation used
	var pFences unsafe.Pointer
	if fences != nil {
		pFences = unsafe.Pointer(&fences[0])
	}

	waitAll_Bool32 := translateInternal_Bool32(waitAll)
	var rsys uintptr

	if vkWaitForFences.fnHandle == nil {
		vkWaitForFences.fnHandle = dlHandle.NewProc("vkWaitForFences")
	}
	rsys, _, _ = syscall.SyscallN(vkWaitForFences.fnHandle.Addr(), uintptr(device), uintptr(fenceCount), uintptr(unsafe.Pointer(pFences)), uintptr(waitAll_Bool32), uintptr(timeout))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkWaitForFences = &vkCommand{"vkWaitForFences", 5, true, nil}

// WaitForPresentKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitForPresentKHR.html
func WaitForPresentKHR(device Device, swapchain SwapchainKHR, presentId uint64, timeout uint64) (r error) {
	var rsys uintptr

	if vkWaitForPresentKHR.fnHandle == nil {
		vkWaitForPresentKHR.fnHandle = dlHandle.NewProc("vkWaitForPresentKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkWaitForPresentKHR.fnHandle.Addr(), uintptr(device), uintptr(swapchain), uintptr(presentId), uintptr(timeout))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkWaitForPresentKHR = &vkCommand{"vkWaitForPresentKHR", 4, true, nil}

// WaitSemaphores: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitSemaphores.html
func WaitSemaphores(device Device, waitInfo *SemaphoreWaitInfo, timeout uint64) (r error) {
	// Parameter is a singular input, requires translation - waitInfo
	var pWaitInfo *_vkSemaphoreWaitInfo
	if waitInfo != nil {
		pWaitInfo = waitInfo.Vulkanize()
	}

	var rsys uintptr

	if vkWaitSemaphores.fnHandle == nil {
		vkWaitSemaphores.fnHandle = dlHandle.NewProc("vkWaitSemaphores")
	}
	rsys, _, _ = syscall.SyscallN(vkWaitSemaphores.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pWaitInfo)), uintptr(timeout))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkWaitSemaphores = &vkCommand{"vkWaitSemaphores", 3, true, nil}
var WaitSemaphoresKHR = WaitSemaphores

// WriteAccelerationStructuresPropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWriteAccelerationStructuresPropertiesKHR.html
func WriteAccelerationStructuresPropertiesKHR(device Device, accelerationStructures []AccelerationStructureKHR, queryType QueryType, data []byte, stride uintptr) (r error) {
	accelerationStructureCount := len(accelerationStructures)
	// accelerationStructures is an input slice of values that do not need translation used
	var pAccelerationStructures unsafe.Pointer
	if accelerationStructures != nil {
		pAccelerationStructures = unsafe.Pointer(&accelerationStructures[0])
	}

	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	var rsys uintptr

	if vkWriteAccelerationStructuresPropertiesKHR.fnHandle == nil {
		vkWriteAccelerationStructuresPropertiesKHR.fnHandle = dlHandle.NewProc("vkWriteAccelerationStructuresPropertiesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkWriteAccelerationStructuresPropertiesKHR.fnHandle.Addr(), uintptr(device), uintptr(accelerationStructureCount), uintptr(unsafe.Pointer(pAccelerationStructures)), uintptr(queryType), uintptr(dataSize), uintptr(unsafe.Pointer(pData)), uintptr(stride))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkWriteAccelerationStructuresPropertiesKHR = &vkCommand{"vkWriteAccelerationStructuresPropertiesKHR", 7, true, nil}
