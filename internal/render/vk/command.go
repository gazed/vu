// Code generated by go-vk from vk.xml at 2024-09-12 10:06:36.5561894 -0400 EDT m=+1.547925901. DO NOT EDIT.

package vk

import "unsafe"

import "syscall"

// AcquireDrmDisplayEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireDrmDisplayEXT.html
func AcquireDrmDisplayEXT(physicalDevice PhysicalDevice, drmFd int32, display DisplayKHR) (r error) {

	r = Result(execTrampoline(vkAcquireDrmDisplayEXT, uintptr(physicalDevice), uintptr(drmFd), uintptr(display)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAcquireDrmDisplayEXT = &vkCommand{"vkAcquireDrmDisplayEXT", 3, true, nil}

// AcquireNextImage2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImage2KHR.html
func AcquireNextImage2KHR(device Device, acquireInfo *AcquireNextImageInfoKHR) (imageIndex uint32, r error) {
	// Parameter is a singular input, requires translation - acquireInfo
	var pAcquireInfo *_vkAcquireNextImageInfoKHR
	if acquireInfo != nil {
		pAcquireInfo = acquireInfo.Vulkanize()
	}

	// imageIndex is a binding-allocated single return value and will be populated by Vulkan
	ptr_pImageIndex := &imageIndex

	r = Result(execTrampoline(vkAcquireNextImage2KHR, uintptr(device), uintptr(unsafe.Pointer(pAcquireInfo)), uintptr(unsafe.Pointer(ptr_pImageIndex))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAcquireNextImage2KHR = &vkCommand{"vkAcquireNextImage2KHR", 3, true, nil}

// AcquireNextImageKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html
func AcquireNextImageKHR(device Device, swapchain SwapchainKHR, timeout uint64, semaphore Semaphore, fence Fence) (imageIndex uint32, r error) {
	// imageIndex is a binding-allocated single return value and will be populated by Vulkan
	ptr_pImageIndex := &imageIndex

	r = Result(execTrampoline(vkAcquireNextImageKHR, uintptr(device), uintptr(swapchain), uintptr(timeout), uintptr(semaphore), uintptr(fence), uintptr(unsafe.Pointer(ptr_pImageIndex))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAcquireNextImageKHR = &vkCommand{"vkAcquireNextImageKHR", 6, true, nil}

// AcquirePerformanceConfigurationINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquirePerformanceConfigurationINTEL.html
func AcquirePerformanceConfigurationINTEL(device Device, acquireInfo *PerformanceConfigurationAcquireInfoINTEL) (configuration PerformanceConfigurationINTEL, r error) {
	// Parameter is a singular input, requires translation - acquireInfo
	var pAcquireInfo *_vkPerformanceConfigurationAcquireInfoINTEL
	if acquireInfo != nil {
		pAcquireInfo = acquireInfo.Vulkanize()
	}

	// configuration is a binding-allocated single return value and will be populated by Vulkan
	ptr_pConfiguration := &configuration

	r = Result(execTrampoline(vkAcquirePerformanceConfigurationINTEL, uintptr(device), uintptr(unsafe.Pointer(pAcquireInfo)), uintptr(unsafe.Pointer(ptr_pConfiguration))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAcquirePerformanceConfigurationINTEL = &vkCommand{"vkAcquirePerformanceConfigurationINTEL", 3, true, nil}

// AcquireProfilingLockKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireProfilingLockKHR.html
func AcquireProfilingLockKHR(device Device, info *AcquireProfilingLockInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkAcquireProfilingLockInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = Result(execTrampoline(vkAcquireProfilingLockKHR, uintptr(device), uintptr(unsafe.Pointer(pInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAcquireProfilingLockKHR = &vkCommand{"vkAcquireProfilingLockKHR", 2, true, nil}

// AllocateCommandBuffers: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateCommandBuffers.html
func AllocateCommandBuffers(device Device, allocateInfo *CommandBufferAllocateInfo) (commandBuffers []CommandBuffer, r error) {
	// Parameter is a singular input, requires translation - allocateInfo
	var pAllocateInfo *_vkCommandBufferAllocateInfo
	if allocateInfo != nil {
		pAllocateInfo = allocateInfo.Vulkanize()
	}

	// Parameter is binding-allocated array populated by Vulkan; length is possibly embedded in a struct (pAllocateInfo->commandBufferCount) - commandBuffers
	commandBuffers = make([]CommandBuffer, pAllocateInfo.commandBufferCount)
	pCommandBuffers := &commandBuffers[0]

	r = Result(execTrampoline(vkAllocateCommandBuffers, uintptr(device), uintptr(unsafe.Pointer(pAllocateInfo)), uintptr(unsafe.Pointer(pCommandBuffers))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAllocateCommandBuffers = &vkCommand{"vkAllocateCommandBuffers", 3, true, nil}

// AllocateDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateDescriptorSets.html
func AllocateDescriptorSets(device Device, allocateInfo *DescriptorSetAllocateInfo) (descriptorSets []DescriptorSet, r error) {
	// Parameter is a singular input, requires translation - allocateInfo
	var pAllocateInfo *_vkDescriptorSetAllocateInfo
	if allocateInfo != nil {
		pAllocateInfo = allocateInfo.Vulkanize()
	}

	// Parameter is binding-allocated array populated by Vulkan; length is possibly embedded in a struct (pAllocateInfo->descriptorSetCount) - descriptorSets
	descriptorSets = make([]DescriptorSet, pAllocateInfo.descriptorSetCount)
	pDescriptorSets := &descriptorSets[0]

	r = Result(execTrampoline(vkAllocateDescriptorSets, uintptr(device), uintptr(unsafe.Pointer(pAllocateInfo)), uintptr(unsafe.Pointer(pDescriptorSets))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAllocateDescriptorSets = &vkCommand{"vkAllocateDescriptorSets", 3, true, nil}

// AllocateMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateMemory.html
func AllocateMemory(device Device, allocateInfo *MemoryAllocateInfo, allocator *AllocationCallbacks) (memory DeviceMemory, r error) {
	// Parameter is a singular input, requires translation - allocateInfo
	var pAllocateInfo *_vkMemoryAllocateInfo
	if allocateInfo != nil {
		pAllocateInfo = allocateInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// memory is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMemory := &memory

	r = Result(execTrampoline(vkAllocateMemory, uintptr(device), uintptr(unsafe.Pointer(pAllocateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pMemory))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAllocateMemory = &vkCommand{"vkAllocateMemory", 4, true, nil}

// BeginCommandBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBeginCommandBuffer.html
func BeginCommandBuffer(commandBuffer CommandBuffer, beginInfo *CommandBufferBeginInfo) (r error) {
	// Parameter is a singular input, requires translation - beginInfo
	var pBeginInfo *_vkCommandBufferBeginInfo
	if beginInfo != nil {
		pBeginInfo = beginInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkBeginCommandBuffer, uintptr(commandBuffer), uintptr(unsafe.Pointer(pBeginInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBeginCommandBuffer = &vkCommand{"vkBeginCommandBuffer", 2, true, nil}

// BindAccelerationStructureMemoryNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindAccelerationStructureMemoryNV.html
func BindAccelerationStructureMemoryNV(device Device, bindInfos []BindAccelerationStructureMemoryInfoNV) (r error) {
	bindInfoCount := len(bindInfos)
	// bindInfos is an input slice that requires translation to an internal type
	var pBindInfos unsafe.Pointer
	if len(bindInfos) > 0 {
		sl_bindInfos := make([]_vkBindAccelerationStructureMemoryInfoNV, bindInfoCount)
		for i, v := range bindInfos {
			sl_bindInfos[i] = *(v.Vulkanize())
		}
		pBindInfos = unsafe.Pointer(&sl_bindInfos[0])
	}

	r = Result(execTrampoline(vkBindAccelerationStructureMemoryNV, uintptr(device), uintptr(bindInfoCount), uintptr(unsafe.Pointer(pBindInfos))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBindAccelerationStructureMemoryNV = &vkCommand{"vkBindAccelerationStructureMemoryNV", 3, true, nil}

// BindBufferMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindBufferMemory.html
func BindBufferMemory(device Device, buffer Buffer, memory DeviceMemory, memoryOffset DeviceSize) (r error) {

	r = Result(execTrampoline(vkBindBufferMemory, uintptr(device), uintptr(buffer), uintptr(memory), uintptr(memoryOffset)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBindBufferMemory = &vkCommand{"vkBindBufferMemory", 4, true, nil}

// BindBufferMemory2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindBufferMemory2.html
func BindBufferMemory2(device Device, bindInfos []BindBufferMemoryInfo) (r error) {
	bindInfoCount := len(bindInfos)
	// bindInfos is an input slice that requires translation to an internal type
	var pBindInfos unsafe.Pointer
	if len(bindInfos) > 0 {
		sl_bindInfos := make([]_vkBindBufferMemoryInfo, bindInfoCount)
		for i, v := range bindInfos {
			sl_bindInfos[i] = *(v.Vulkanize())
		}
		pBindInfos = unsafe.Pointer(&sl_bindInfos[0])
	}

	r = Result(execTrampoline(vkBindBufferMemory2, uintptr(device), uintptr(bindInfoCount), uintptr(unsafe.Pointer(pBindInfos))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBindBufferMemory2 = &vkCommand{"vkBindBufferMemory2", 3, true, nil}
var BindBufferMemory2KHR = BindBufferMemory2

// BindImageMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindImageMemory.html
func BindImageMemory(device Device, image Image, memory DeviceMemory, memoryOffset DeviceSize) (r error) {

	r = Result(execTrampoline(vkBindImageMemory, uintptr(device), uintptr(image), uintptr(memory), uintptr(memoryOffset)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBindImageMemory = &vkCommand{"vkBindImageMemory", 4, true, nil}

// BindImageMemory2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindImageMemory2.html
func BindImageMemory2(device Device, bindInfos []BindImageMemoryInfo) (r error) {
	bindInfoCount := len(bindInfos)
	// bindInfos is an input slice that requires translation to an internal type
	var pBindInfos unsafe.Pointer
	if len(bindInfos) > 0 {
		sl_bindInfos := make([]_vkBindImageMemoryInfo, bindInfoCount)
		for i, v := range bindInfos {
			sl_bindInfos[i] = *(v.Vulkanize())
		}
		pBindInfos = unsafe.Pointer(&sl_bindInfos[0])
	}

	r = Result(execTrampoline(vkBindImageMemory2, uintptr(device), uintptr(bindInfoCount), uintptr(unsafe.Pointer(pBindInfos))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBindImageMemory2 = &vkCommand{"vkBindImageMemory2", 3, true, nil}
var BindImageMemory2KHR = BindImageMemory2

// BindOpticalFlowSessionImageNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindOpticalFlowSessionImageNV.html
func BindOpticalFlowSessionImageNV(device Device, session OpticalFlowSessionNV, bindingPoint OpticalFlowSessionBindingPointNV, view ImageView, layout ImageLayout) (r error) {

	r = Result(execTrampoline(vkBindOpticalFlowSessionImageNV, uintptr(device), uintptr(session), uintptr(bindingPoint), uintptr(view), uintptr(layout)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBindOpticalFlowSessionImageNV = &vkCommand{"vkBindOpticalFlowSessionImageNV", 5, true, nil}

// BindVideoSessionMemoryKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindVideoSessionMemoryKHR.html
func BindVideoSessionMemoryKHR(device Device, videoSession VideoSessionKHR, bindSessionMemoryInfos []BindVideoSessionMemoryInfoKHR) (r error) {
	bindSessionMemoryInfoCount := len(bindSessionMemoryInfos)
	// bindSessionMemoryInfos is an input slice that requires translation to an internal type
	var pBindSessionMemoryInfos unsafe.Pointer
	if len(bindSessionMemoryInfos) > 0 {
		sl_bindSessionMemoryInfos := make([]_vkBindVideoSessionMemoryInfoKHR, bindSessionMemoryInfoCount)
		for i, v := range bindSessionMemoryInfos {
			sl_bindSessionMemoryInfos[i] = *(v.Vulkanize())
		}
		pBindSessionMemoryInfos = unsafe.Pointer(&sl_bindSessionMemoryInfos[0])
	}

	r = Result(execTrampoline(vkBindVideoSessionMemoryKHR, uintptr(device), uintptr(videoSession), uintptr(bindSessionMemoryInfoCount), uintptr(unsafe.Pointer(pBindSessionMemoryInfos))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBindVideoSessionMemoryKHR = &vkCommand{"vkBindVideoSessionMemoryKHR", 4, true, nil}

// BuildAccelerationStructuresKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBuildAccelerationStructuresKHR.html
func BuildAccelerationStructuresKHR(device Device, deferredOperation DeferredOperationKHR, infos []AccelerationStructureBuildGeometryInfoKHR, pBuildRangeInfos []*AccelerationStructureBuildRangeInfoKHR) (r error) {
	infoCount := len(infos)
	// infos is an input slice that requires translation to an internal type
	var pInfos unsafe.Pointer
	if len(infos) > 0 {
		sl_infos := make([]_vkAccelerationStructureBuildGeometryInfoKHR, infoCount)
		for i, v := range infos {
			sl_infos[i] = *(v.Vulkanize())
		}
		pInfos = unsafe.Pointer(&sl_infos[0])
	}

	// pBuildRangeInfos is an input slice of values that do not need translation used
	var ppBuildRangeInfos unsafe.Pointer
	if pBuildRangeInfos != nil {
		ppBuildRangeInfos = unsafe.Pointer(&pBuildRangeInfos[0])
	}

	r = Result(execTrampoline(vkBuildAccelerationStructuresKHR, uintptr(device), uintptr(deferredOperation), uintptr(infoCount), uintptr(unsafe.Pointer(pInfos)), uintptr(unsafe.Pointer(ppBuildRangeInfos))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBuildAccelerationStructuresKHR = &vkCommand{"vkBuildAccelerationStructuresKHR", 5, true, nil}

// BuildMicromapsEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBuildMicromapsEXT.html
func BuildMicromapsEXT(device Device, deferredOperation DeferredOperationKHR, infos []MicromapBuildInfoEXT) (r error) {
	infoCount := len(infos)
	// infos is an input slice that requires translation to an internal type
	var pInfos unsafe.Pointer
	if len(infos) > 0 {
		sl_infos := make([]_vkMicromapBuildInfoEXT, infoCount)
		for i, v := range infos {
			sl_infos[i] = *(v.Vulkanize())
		}
		pInfos = unsafe.Pointer(&sl_infos[0])
	}

	r = Result(execTrampoline(vkBuildMicromapsEXT, uintptr(device), uintptr(deferredOperation), uintptr(infoCount), uintptr(unsafe.Pointer(pInfos))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkBuildMicromapsEXT = &vkCommand{"vkBuildMicromapsEXT", 4, true, nil}

// CmdBeginConditionalRenderingEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginConditionalRenderingEXT.html
func CmdBeginConditionalRenderingEXT(commandBuffer CommandBuffer, conditionalRenderingBegin *ConditionalRenderingBeginInfoEXT) {
	// Parameter is a singular input, requires translation - conditionalRenderingBegin
	var pConditionalRenderingBegin *_vkConditionalRenderingBeginInfoEXT
	if conditionalRenderingBegin != nil {
		pConditionalRenderingBegin = conditionalRenderingBegin.Vulkanize()
	}

	execTrampoline(vkCmdBeginConditionalRenderingEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pConditionalRenderingBegin)))

}

var vkCmdBeginConditionalRenderingEXT = &vkCommand{"vkCmdBeginConditionalRenderingEXT", 2, true, nil}

// CmdBeginDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginDebugUtilsLabelEXT.html
func CmdBeginDebugUtilsLabelEXT(commandBuffer CommandBuffer, labelInfo *DebugUtilsLabelEXT) {
	// Parameter is a singular input, requires translation - labelInfo
	var pLabelInfo *_vkDebugUtilsLabelEXT
	if labelInfo != nil {
		pLabelInfo = labelInfo.Vulkanize()
	}

	execTrampoline(vkCmdBeginDebugUtilsLabelEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pLabelInfo)))

}

var vkCmdBeginDebugUtilsLabelEXT = &vkCommand{"vkCmdBeginDebugUtilsLabelEXT", 2, true, nil}

// CmdBeginQuery: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginQuery.html
func CmdBeginQuery(commandBuffer CommandBuffer, queryPool QueryPool, query uint32, flags QueryControlFlags) {

	execTrampoline(vkCmdBeginQuery, uintptr(commandBuffer), uintptr(queryPool), uintptr(query), uintptr(flags))

}

var vkCmdBeginQuery = &vkCommand{"vkCmdBeginQuery", 4, true, nil}

// CmdBeginQueryIndexedEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginQueryIndexedEXT.html
func CmdBeginQueryIndexedEXT(commandBuffer CommandBuffer, queryPool QueryPool, query uint32, flags QueryControlFlags, index uint32) {

	execTrampoline(vkCmdBeginQueryIndexedEXT, uintptr(commandBuffer), uintptr(queryPool), uintptr(query), uintptr(flags), uintptr(index))

}

var vkCmdBeginQueryIndexedEXT = &vkCommand{"vkCmdBeginQueryIndexedEXT", 5, true, nil}

// CmdBeginRenderPass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html
func CmdBeginRenderPass(commandBuffer CommandBuffer, renderPassBegin *RenderPassBeginInfo, contents SubpassContents) {
	// Parameter is a singular input, requires translation - renderPassBegin
	var pRenderPassBegin *_vkRenderPassBeginInfo
	if renderPassBegin != nil {
		pRenderPassBegin = renderPassBegin.Vulkanize()
	}

	execTrampoline(vkCmdBeginRenderPass, uintptr(commandBuffer), uintptr(unsafe.Pointer(pRenderPassBegin)), uintptr(contents))

}

var vkCmdBeginRenderPass = &vkCommand{"vkCmdBeginRenderPass", 3, true, nil}

// CmdBeginRenderPass2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass2.html
func CmdBeginRenderPass2(commandBuffer CommandBuffer, renderPassBegin *RenderPassBeginInfo, subpassBeginInfo *SubpassBeginInfo) {
	// Parameter is a singular input, requires translation - renderPassBegin
	var pRenderPassBegin *_vkRenderPassBeginInfo
	if renderPassBegin != nil {
		pRenderPassBegin = renderPassBegin.Vulkanize()
	}

	// Parameter is a singular input, requires translation - subpassBeginInfo
	var pSubpassBeginInfo *_vkSubpassBeginInfo
	if subpassBeginInfo != nil {
		pSubpassBeginInfo = subpassBeginInfo.Vulkanize()
	}

	execTrampoline(vkCmdBeginRenderPass2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pRenderPassBegin)), uintptr(unsafe.Pointer(pSubpassBeginInfo)))

}

var vkCmdBeginRenderPass2 = &vkCommand{"vkCmdBeginRenderPass2", 3, true, nil}
var CmdBeginRenderPass2KHR = CmdBeginRenderPass2

// CmdBeginRendering: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRendering.html
func CmdBeginRendering(commandBuffer CommandBuffer, renderingInfo *RenderingInfo) {
	// Parameter is a singular input, requires translation - renderingInfo
	var pRenderingInfo *_vkRenderingInfo
	if renderingInfo != nil {
		pRenderingInfo = renderingInfo.Vulkanize()
	}

	execTrampoline(vkCmdBeginRendering, uintptr(commandBuffer), uintptr(unsafe.Pointer(pRenderingInfo)))

}

var vkCmdBeginRendering = &vkCommand{"vkCmdBeginRendering", 2, true, nil}
var CmdBeginRenderingKHR = CmdBeginRendering

// CmdBeginTransformFeedbackEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginTransformFeedbackEXT.html
func CmdBeginTransformFeedbackEXT(commandBuffer CommandBuffer, firstCounterBuffer uint32, counterBuffers []Buffer, counterBufferOffsets []DeviceSize) {
	counterBufferCount := len(counterBuffers)
	// counterBuffers is an input slice of values that do not need translation used
	var pCounterBuffers unsafe.Pointer
	if counterBuffers != nil {
		pCounterBuffers = unsafe.Pointer(&counterBuffers[0])
	}

	// counterBufferOffsets is an input slice of values that do not need translation used
	var pCounterBufferOffsets unsafe.Pointer
	if counterBufferOffsets != nil {
		pCounterBufferOffsets = unsafe.Pointer(&counterBufferOffsets[0])
	}

	execTrampoline(vkCmdBeginTransformFeedbackEXT, uintptr(commandBuffer), uintptr(firstCounterBuffer), uintptr(counterBufferCount), uintptr(unsafe.Pointer(pCounterBuffers)), uintptr(unsafe.Pointer(pCounterBufferOffsets)))

}

var vkCmdBeginTransformFeedbackEXT = &vkCommand{"vkCmdBeginTransformFeedbackEXT", 5, true, nil}

// CmdBeginVideoCodingKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginVideoCodingKHR.html
func CmdBeginVideoCodingKHR(commandBuffer CommandBuffer, beginInfo *VideoBeginCodingInfoKHR) {
	// Parameter is a singular input, requires translation - beginInfo
	var pBeginInfo *_vkVideoBeginCodingInfoKHR
	if beginInfo != nil {
		pBeginInfo = beginInfo.Vulkanize()
	}

	execTrampoline(vkCmdBeginVideoCodingKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pBeginInfo)))

}

var vkCmdBeginVideoCodingKHR = &vkCommand{"vkCmdBeginVideoCodingKHR", 2, true, nil}

// CmdBindDescriptorBufferEmbeddedSamplers2EXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorBufferEmbeddedSamplers2EXT.html
func CmdBindDescriptorBufferEmbeddedSamplers2EXT(commandBuffer CommandBuffer, bindDescriptorBufferEmbeddedSamplersInfo *BindDescriptorBufferEmbeddedSamplersInfoEXT) {
	// Parameter is a singular input, requires translation - bindDescriptorBufferEmbeddedSamplersInfo
	var pBindDescriptorBufferEmbeddedSamplersInfo *_vkBindDescriptorBufferEmbeddedSamplersInfoEXT
	if bindDescriptorBufferEmbeddedSamplersInfo != nil {
		pBindDescriptorBufferEmbeddedSamplersInfo = bindDescriptorBufferEmbeddedSamplersInfo.Vulkanize()
	}

	execTrampoline(vkCmdBindDescriptorBufferEmbeddedSamplers2EXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pBindDescriptorBufferEmbeddedSamplersInfo)))

}

var vkCmdBindDescriptorBufferEmbeddedSamplers2EXT = &vkCommand{"vkCmdBindDescriptorBufferEmbeddedSamplers2EXT", 2, true, nil}

// CmdBindDescriptorBufferEmbeddedSamplersEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorBufferEmbeddedSamplersEXT.html
func CmdBindDescriptorBufferEmbeddedSamplersEXT(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, layout PipelineLayout, set uint32) {

	execTrampoline(vkCmdBindDescriptorBufferEmbeddedSamplersEXT, uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(layout), uintptr(set))

}

var vkCmdBindDescriptorBufferEmbeddedSamplersEXT = &vkCommand{"vkCmdBindDescriptorBufferEmbeddedSamplersEXT", 4, true, nil}

// CmdBindDescriptorBuffersEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorBuffersEXT.html
func CmdBindDescriptorBuffersEXT(commandBuffer CommandBuffer, bindingInfos []DescriptorBufferBindingInfoEXT) {
	bufferCount := len(bindingInfos)
	// bindingInfos is an input slice that requires translation to an internal type
	var pBindingInfos unsafe.Pointer
	if len(bindingInfos) > 0 {
		sl_bindingInfos := make([]_vkDescriptorBufferBindingInfoEXT, bufferCount)
		for i, v := range bindingInfos {
			sl_bindingInfos[i] = *(v.Vulkanize())
		}
		pBindingInfos = unsafe.Pointer(&sl_bindingInfos[0])
	}

	execTrampoline(vkCmdBindDescriptorBuffersEXT, uintptr(commandBuffer), uintptr(bufferCount), uintptr(unsafe.Pointer(pBindingInfos)))

}

var vkCmdBindDescriptorBuffersEXT = &vkCommand{"vkCmdBindDescriptorBuffersEXT", 3, true, nil}

// CmdBindDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorSets.html
func CmdBindDescriptorSets(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, layout PipelineLayout, firstSet uint32, descriptorSets []DescriptorSet, dynamicOffsets []uint32) {
	descriptorSetCount := len(descriptorSets)
	// descriptorSets is an input slice of values that do not need translation used
	var pDescriptorSets unsafe.Pointer
	if descriptorSets != nil {
		pDescriptorSets = unsafe.Pointer(&descriptorSets[0])
	}

	dynamicOffsetCount := len(dynamicOffsets)
	// dynamicOffsets is an input slice of values that do not need translation used
	var pDynamicOffsets unsafe.Pointer
	if dynamicOffsets != nil {
		pDynamicOffsets = unsafe.Pointer(&dynamicOffsets[0])
	}

	execTrampoline(vkCmdBindDescriptorSets, uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(layout), uintptr(firstSet), uintptr(descriptorSetCount), uintptr(unsafe.Pointer(pDescriptorSets)), uintptr(dynamicOffsetCount), uintptr(unsafe.Pointer(pDynamicOffsets)))

}

var vkCmdBindDescriptorSets = &vkCommand{"vkCmdBindDescriptorSets", 8, true, nil}

// CmdBindDescriptorSets2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorSets2KHR.html
func CmdBindDescriptorSets2KHR(commandBuffer CommandBuffer, bindDescriptorSetsInfo *BindDescriptorSetsInfoKHR) {
	// Parameter is a singular input, requires translation - bindDescriptorSetsInfo
	var pBindDescriptorSetsInfo *_vkBindDescriptorSetsInfoKHR
	if bindDescriptorSetsInfo != nil {
		pBindDescriptorSetsInfo = bindDescriptorSetsInfo.Vulkanize()
	}

	execTrampoline(vkCmdBindDescriptorSets2KHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pBindDescriptorSetsInfo)))

}

var vkCmdBindDescriptorSets2KHR = &vkCommand{"vkCmdBindDescriptorSets2KHR", 2, true, nil}

// CmdBindIndexBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindIndexBuffer.html
func CmdBindIndexBuffer(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, indexType IndexType) {

	execTrampoline(vkCmdBindIndexBuffer, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(indexType))

}

var vkCmdBindIndexBuffer = &vkCommand{"vkCmdBindIndexBuffer", 4, true, nil}

// CmdBindIndexBuffer2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindIndexBuffer2KHR.html
func CmdBindIndexBuffer2KHR(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, size DeviceSize, indexType IndexType) {

	execTrampoline(vkCmdBindIndexBuffer2KHR, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(size), uintptr(indexType))

}

var vkCmdBindIndexBuffer2KHR = &vkCommand{"vkCmdBindIndexBuffer2KHR", 5, true, nil}

// CmdBindInvocationMaskHUAWEI: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindInvocationMaskHUAWEI.html
func CmdBindInvocationMaskHUAWEI(commandBuffer CommandBuffer, imageView ImageView, imageLayout ImageLayout) {

	execTrampoline(vkCmdBindInvocationMaskHUAWEI, uintptr(commandBuffer), uintptr(imageView), uintptr(imageLayout))

}

var vkCmdBindInvocationMaskHUAWEI = &vkCommand{"vkCmdBindInvocationMaskHUAWEI", 3, true, nil}

// CmdBindPipeline: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindPipeline.html
func CmdBindPipeline(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, pipeline Pipeline) {

	execTrampoline(vkCmdBindPipeline, uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(pipeline))

}

var vkCmdBindPipeline = &vkCommand{"vkCmdBindPipeline", 3, true, nil}

// CmdBindPipelineShaderGroupNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindPipelineShaderGroupNV.html
func CmdBindPipelineShaderGroupNV(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, pipeline Pipeline, groupIndex uint32) {

	execTrampoline(vkCmdBindPipelineShaderGroupNV, uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(pipeline), uintptr(groupIndex))

}

var vkCmdBindPipelineShaderGroupNV = &vkCommand{"vkCmdBindPipelineShaderGroupNV", 4, true, nil}

// CmdBindShadersEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindShadersEXT.html
func CmdBindShadersEXT(commandBuffer CommandBuffer, stages []ShaderStageFlagBits, shaders []ShaderEXT) {
	stageCount := len(stages)
	// stages is an input slice of values that do not need translation used
	var pStages unsafe.Pointer
	if stages != nil {
		pStages = unsafe.Pointer(&stages[0])
	}

	// shaders is an input slice of values that do not need translation used
	var pShaders unsafe.Pointer
	if shaders != nil {
		pShaders = unsafe.Pointer(&shaders[0])
	}

	execTrampoline(vkCmdBindShadersEXT, uintptr(commandBuffer), uintptr(stageCount), uintptr(unsafe.Pointer(pStages)), uintptr(unsafe.Pointer(pShaders)))

}

var vkCmdBindShadersEXT = &vkCommand{"vkCmdBindShadersEXT", 4, true, nil}

// CmdBindShadingRateImageNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindShadingRateImageNV.html
func CmdBindShadingRateImageNV(commandBuffer CommandBuffer, imageView ImageView, imageLayout ImageLayout) {

	execTrampoline(vkCmdBindShadingRateImageNV, uintptr(commandBuffer), uintptr(imageView), uintptr(imageLayout))

}

var vkCmdBindShadingRateImageNV = &vkCommand{"vkCmdBindShadingRateImageNV", 3, true, nil}

// CmdBindTransformFeedbackBuffersEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindTransformFeedbackBuffersEXT.html
func CmdBindTransformFeedbackBuffersEXT(commandBuffer CommandBuffer, firstBinding uint32, buffers []Buffer, offsets []DeviceSize, sizes []DeviceSize) {
	bindingCount := len(buffers)
	// buffers is an input slice of values that do not need translation used
	var pBuffers unsafe.Pointer
	if buffers != nil {
		pBuffers = unsafe.Pointer(&buffers[0])
	}

	// offsets is an input slice of values that do not need translation used
	var pOffsets unsafe.Pointer
	if offsets != nil {
		pOffsets = unsafe.Pointer(&offsets[0])
	}

	// sizes is an input slice of values that do not need translation used
	var pSizes unsafe.Pointer
	if sizes != nil {
		pSizes = unsafe.Pointer(&sizes[0])
	}

	execTrampoline(vkCmdBindTransformFeedbackBuffersEXT, uintptr(commandBuffer), uintptr(firstBinding), uintptr(bindingCount), uintptr(unsafe.Pointer(pBuffers)), uintptr(unsafe.Pointer(pOffsets)), uintptr(unsafe.Pointer(pSizes)))

}

var vkCmdBindTransformFeedbackBuffersEXT = &vkCommand{"vkCmdBindTransformFeedbackBuffersEXT", 6, true, nil}

// CmdBindVertexBuffers: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers.html
func CmdBindVertexBuffers(commandBuffer CommandBuffer, firstBinding uint32, buffers []Buffer, offsets []DeviceSize) {
	bindingCount := len(buffers)
	// buffers is an input slice of values that do not need translation used
	var pBuffers unsafe.Pointer
	if buffers != nil {
		pBuffers = unsafe.Pointer(&buffers[0])
	}

	// offsets is an input slice of values that do not need translation used
	var pOffsets unsafe.Pointer
	if offsets != nil {
		pOffsets = unsafe.Pointer(&offsets[0])
	}

	execTrampoline(vkCmdBindVertexBuffers, uintptr(commandBuffer), uintptr(firstBinding), uintptr(bindingCount), uintptr(unsafe.Pointer(pBuffers)), uintptr(unsafe.Pointer(pOffsets)))

}

var vkCmdBindVertexBuffers = &vkCommand{"vkCmdBindVertexBuffers", 5, true, nil}

// CmdBindVertexBuffers2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers2.html
func CmdBindVertexBuffers2(commandBuffer CommandBuffer, firstBinding uint32, buffers []Buffer, offsets []DeviceSize, sizes []DeviceSize, strides []DeviceSize) {
	bindingCount := len(buffers)
	// buffers is an input slice of values that do not need translation used
	var pBuffers unsafe.Pointer
	if buffers != nil {
		pBuffers = unsafe.Pointer(&buffers[0])
	}

	// offsets is an input slice of values that do not need translation used
	var pOffsets unsafe.Pointer
	if offsets != nil {
		pOffsets = unsafe.Pointer(&offsets[0])
	}

	// sizes is an input slice of values that do not need translation used
	var pSizes unsafe.Pointer
	if sizes != nil {
		pSizes = unsafe.Pointer(&sizes[0])
	}

	// strides is an input slice of values that do not need translation used
	var pStrides unsafe.Pointer
	if strides != nil {
		pStrides = unsafe.Pointer(&strides[0])
	}

	execTrampoline(vkCmdBindVertexBuffers2, uintptr(commandBuffer), uintptr(firstBinding), uintptr(bindingCount), uintptr(unsafe.Pointer(pBuffers)), uintptr(unsafe.Pointer(pOffsets)), uintptr(unsafe.Pointer(pSizes)), uintptr(unsafe.Pointer(pStrides)))

}

var vkCmdBindVertexBuffers2 = &vkCommand{"vkCmdBindVertexBuffers2", 7, true, nil}
var CmdBindVertexBuffers2EXT = CmdBindVertexBuffers2

// CmdBlitImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage.html
func CmdBlitImage(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageBlit, filter Filter) {
	regionCount := len(regions)
	// regions is an input slice that requires translation to an internal type
	var pRegions unsafe.Pointer
	if len(regions) > 0 {
		sl_regions := make([]_vkImageBlit, regionCount)
		for i, v := range regions {
			sl_regions[i] = *(v.Vulkanize())
		}
		pRegions = unsafe.Pointer(&sl_regions[0])
	}

	execTrampoline(vkCmdBlitImage, uintptr(commandBuffer), uintptr(srcImage), uintptr(srcImageLayout), uintptr(dstImage), uintptr(dstImageLayout), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)), uintptr(filter))

}

var vkCmdBlitImage = &vkCommand{"vkCmdBlitImage", 8, true, nil}

// CmdBlitImage2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage2.html
func CmdBlitImage2(commandBuffer CommandBuffer, blitImageInfo *BlitImageInfo2) {
	// Parameter is a singular input, requires translation - blitImageInfo
	var pBlitImageInfo *_vkBlitImageInfo2
	if blitImageInfo != nil {
		pBlitImageInfo = blitImageInfo.Vulkanize()
	}

	execTrampoline(vkCmdBlitImage2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pBlitImageInfo)))

}

var vkCmdBlitImage2 = &vkCommand{"vkCmdBlitImage2", 2, true, nil}
var CmdBlitImage2KHR = CmdBlitImage2

// CmdBuildAccelerationStructureNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBuildAccelerationStructureNV.html
func CmdBuildAccelerationStructureNV(commandBuffer CommandBuffer, info *AccelerationStructureInfoNV, instanceData Buffer, instanceOffset DeviceSize, update bool, dst AccelerationStructureNV, src AccelerationStructureNV, scratch Buffer, scratchOffset DeviceSize) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkAccelerationStructureInfoNV
	if info != nil {
		pInfo = info.Vulkanize()
	}

	update_Bool32 := translateInternal_Bool32(update)

	execTrampoline(vkCmdBuildAccelerationStructureNV, uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)), uintptr(instanceData), uintptr(instanceOffset), uintptr(update_Bool32), uintptr(dst), uintptr(src), uintptr(scratch), uintptr(scratchOffset))

}

var vkCmdBuildAccelerationStructureNV = &vkCommand{"vkCmdBuildAccelerationStructureNV", 9, true, nil}

// CmdBuildAccelerationStructuresIndirectKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBuildAccelerationStructuresIndirectKHR.html
func CmdBuildAccelerationStructuresIndirectKHR(commandBuffer CommandBuffer, infos []AccelerationStructureBuildGeometryInfoKHR, indirectDeviceAddresses []DeviceAddress, indirectStrides []uint32, pMaxPrimitiveCounts []*uint32) {
	infoCount := len(infos)
	// infos is an input slice that requires translation to an internal type
	var pInfos unsafe.Pointer
	if len(infos) > 0 {
		sl_infos := make([]_vkAccelerationStructureBuildGeometryInfoKHR, infoCount)
		for i, v := range infos {
			sl_infos[i] = *(v.Vulkanize())
		}
		pInfos = unsafe.Pointer(&sl_infos[0])
	}

	// indirectDeviceAddresses is an input slice of values that do not need translation used
	var pIndirectDeviceAddresses unsafe.Pointer
	if indirectDeviceAddresses != nil {
		pIndirectDeviceAddresses = unsafe.Pointer(&indirectDeviceAddresses[0])
	}

	// indirectStrides is an input slice of values that do not need translation used
	var pIndirectStrides unsafe.Pointer
	if indirectStrides != nil {
		pIndirectStrides = unsafe.Pointer(&indirectStrides[0])
	}

	// pMaxPrimitiveCounts is an input slice of values that do not need translation used
	var ppMaxPrimitiveCounts unsafe.Pointer
	if pMaxPrimitiveCounts != nil {
		ppMaxPrimitiveCounts = unsafe.Pointer(&pMaxPrimitiveCounts[0])
	}

	execTrampoline(vkCmdBuildAccelerationStructuresIndirectKHR, uintptr(commandBuffer), uintptr(infoCount), uintptr(unsafe.Pointer(pInfos)), uintptr(unsafe.Pointer(pIndirectDeviceAddresses)), uintptr(unsafe.Pointer(pIndirectStrides)), uintptr(unsafe.Pointer(ppMaxPrimitiveCounts)))

}

var vkCmdBuildAccelerationStructuresIndirectKHR = &vkCommand{"vkCmdBuildAccelerationStructuresIndirectKHR", 6, true, nil}

// CmdBuildAccelerationStructuresKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBuildAccelerationStructuresKHR.html
func CmdBuildAccelerationStructuresKHR(commandBuffer CommandBuffer, infos []AccelerationStructureBuildGeometryInfoKHR, pBuildRangeInfos []*AccelerationStructureBuildRangeInfoKHR) {
	infoCount := len(infos)
	// infos is an input slice that requires translation to an internal type
	var pInfos unsafe.Pointer
	if len(infos) > 0 {
		sl_infos := make([]_vkAccelerationStructureBuildGeometryInfoKHR, infoCount)
		for i, v := range infos {
			sl_infos[i] = *(v.Vulkanize())
		}
		pInfos = unsafe.Pointer(&sl_infos[0])
	}

	// pBuildRangeInfos is an input slice of values that do not need translation used
	var ppBuildRangeInfos unsafe.Pointer
	if pBuildRangeInfos != nil {
		ppBuildRangeInfos = unsafe.Pointer(&pBuildRangeInfos[0])
	}

	execTrampoline(vkCmdBuildAccelerationStructuresKHR, uintptr(commandBuffer), uintptr(infoCount), uintptr(unsafe.Pointer(pInfos)), uintptr(unsafe.Pointer(ppBuildRangeInfos)))

}

var vkCmdBuildAccelerationStructuresKHR = &vkCommand{"vkCmdBuildAccelerationStructuresKHR", 4, true, nil}

// CmdBuildMicromapsEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBuildMicromapsEXT.html
func CmdBuildMicromapsEXT(commandBuffer CommandBuffer, infos []MicromapBuildInfoEXT) {
	infoCount := len(infos)
	// infos is an input slice that requires translation to an internal type
	var pInfos unsafe.Pointer
	if len(infos) > 0 {
		sl_infos := make([]_vkMicromapBuildInfoEXT, infoCount)
		for i, v := range infos {
			sl_infos[i] = *(v.Vulkanize())
		}
		pInfos = unsafe.Pointer(&sl_infos[0])
	}

	execTrampoline(vkCmdBuildMicromapsEXT, uintptr(commandBuffer), uintptr(infoCount), uintptr(unsafe.Pointer(pInfos)))

}

var vkCmdBuildMicromapsEXT = &vkCommand{"vkCmdBuildMicromapsEXT", 3, true, nil}

// CmdClearAttachments: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdClearAttachments.html
func CmdClearAttachments(commandBuffer CommandBuffer, attachments []ClearAttachment, rects []ClearRect) {
	attachmentCount := len(attachments)
	// attachments is an input slice that requires translation to an internal type
	var pAttachments unsafe.Pointer
	if len(attachments) > 0 {
		sl_attachments := make([]_vkClearAttachment, attachmentCount)
		for i, v := range attachments {
			sl_attachments[i] = *(v.Vulkanize())
		}
		pAttachments = unsafe.Pointer(&sl_attachments[0])
	}

	rectCount := len(rects)
	// rects is an input slice that requires translation to an internal type
	var pRects unsafe.Pointer
	if len(rects) > 0 {
		sl_rects := make([]_vkClearRect, rectCount)
		for i, v := range rects {
			sl_rects[i] = *(v.Vulkanize())
		}
		pRects = unsafe.Pointer(&sl_rects[0])
	}

	execTrampoline(vkCmdClearAttachments, uintptr(commandBuffer), uintptr(attachmentCount), uintptr(unsafe.Pointer(pAttachments)), uintptr(rectCount), uintptr(unsafe.Pointer(pRects)))

}

var vkCmdClearAttachments = &vkCommand{"vkCmdClearAttachments", 5, true, nil}

// CmdClearColorImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdClearColorImage.html
func CmdClearColorImage(commandBuffer CommandBuffer, image Image, imageLayout ImageLayout, color *ClearColorValue, ranges []ImageSubresourceRange) {
	// Parameter is a singular input, requires translation - color
	var pColor *_vkClearColorValue
	if color != nil {
		pColor = color.Vulkanize()
	}

	rangeCount := len(ranges)
	// ranges is an input slice of values that do not need translation used
	var pRanges unsafe.Pointer
	if ranges != nil {
		pRanges = unsafe.Pointer(&ranges[0])
	}

	execTrampoline(vkCmdClearColorImage, uintptr(commandBuffer), uintptr(image), uintptr(imageLayout), uintptr(unsafe.Pointer(pColor)), uintptr(rangeCount), uintptr(unsafe.Pointer(pRanges)))

}

var vkCmdClearColorImage = &vkCommand{"vkCmdClearColorImage", 6, true, nil}

// CmdClearDepthStencilImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdClearDepthStencilImage.html
func CmdClearDepthStencilImage(commandBuffer CommandBuffer, image Image, imageLayout ImageLayout, depthStencil *ClearDepthStencilValue, ranges []ImageSubresourceRange) {
	// Parameter is a singular input, pass direct - depthStencil
	var pDepthStencil unsafe.Pointer
	if depthStencil != nil {
		pDepthStencil = unsafe.Pointer(depthStencil)
	}

	rangeCount := len(ranges)
	// ranges is an input slice of values that do not need translation used
	var pRanges unsafe.Pointer
	if ranges != nil {
		pRanges = unsafe.Pointer(&ranges[0])
	}

	execTrampoline(vkCmdClearDepthStencilImage, uintptr(commandBuffer), uintptr(image), uintptr(imageLayout), uintptr(unsafe.Pointer(pDepthStencil)), uintptr(rangeCount), uintptr(unsafe.Pointer(pRanges)))

}

var vkCmdClearDepthStencilImage = &vkCommand{"vkCmdClearDepthStencilImage", 6, true, nil}

// CmdControlVideoCodingKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdControlVideoCodingKHR.html
func CmdControlVideoCodingKHR(commandBuffer CommandBuffer, codingControlInfo *VideoCodingControlInfoKHR) {
	// Parameter is a singular input, requires translation - codingControlInfo
	var pCodingControlInfo *_vkVideoCodingControlInfoKHR
	if codingControlInfo != nil {
		pCodingControlInfo = codingControlInfo.Vulkanize()
	}

	execTrampoline(vkCmdControlVideoCodingKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pCodingControlInfo)))

}

var vkCmdControlVideoCodingKHR = &vkCommand{"vkCmdControlVideoCodingKHR", 2, true, nil}

// CmdCopyAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyAccelerationStructureKHR.html
func CmdCopyAccelerationStructureKHR(commandBuffer CommandBuffer, info *CopyAccelerationStructureInfoKHR) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyAccelerationStructureInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	execTrampoline(vkCmdCopyAccelerationStructureKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)))

}

var vkCmdCopyAccelerationStructureKHR = &vkCommand{"vkCmdCopyAccelerationStructureKHR", 2, true, nil}

// CmdCopyAccelerationStructureNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyAccelerationStructureNV.html
func CmdCopyAccelerationStructureNV(commandBuffer CommandBuffer, dst AccelerationStructureNV, src AccelerationStructureNV, mode CopyAccelerationStructureModeKHR) {

	execTrampoline(vkCmdCopyAccelerationStructureNV, uintptr(commandBuffer), uintptr(dst), uintptr(src), uintptr(mode))

}

var vkCmdCopyAccelerationStructureNV = &vkCommand{"vkCmdCopyAccelerationStructureNV", 4, true, nil}

// CmdCopyAccelerationStructureToMemoryKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyAccelerationStructureToMemoryKHR.html
func CmdCopyAccelerationStructureToMemoryKHR(commandBuffer CommandBuffer, info *CopyAccelerationStructureToMemoryInfoKHR) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyAccelerationStructureToMemoryInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	execTrampoline(vkCmdCopyAccelerationStructureToMemoryKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)))

}

var vkCmdCopyAccelerationStructureToMemoryKHR = &vkCommand{"vkCmdCopyAccelerationStructureToMemoryKHR", 2, true, nil}

// CmdCopyBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer.html
func CmdCopyBuffer(commandBuffer CommandBuffer, srcBuffer Buffer, dstBuffer Buffer, regions []BufferCopy) {
	regionCount := len(regions)
	// regions is an input slice of values that do not need translation used
	var pRegions unsafe.Pointer
	if regions != nil {
		pRegions = unsafe.Pointer(&regions[0])
	}

	execTrampoline(vkCmdCopyBuffer, uintptr(commandBuffer), uintptr(srcBuffer), uintptr(dstBuffer), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)))

}

var vkCmdCopyBuffer = &vkCommand{"vkCmdCopyBuffer", 5, true, nil}

// CmdCopyBuffer2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer2.html
func CmdCopyBuffer2(commandBuffer CommandBuffer, copyBufferInfo *CopyBufferInfo2) {
	// Parameter is a singular input, requires translation - copyBufferInfo
	var pCopyBufferInfo *_vkCopyBufferInfo2
	if copyBufferInfo != nil {
		pCopyBufferInfo = copyBufferInfo.Vulkanize()
	}

	execTrampoline(vkCmdCopyBuffer2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pCopyBufferInfo)))

}

var vkCmdCopyBuffer2 = &vkCommand{"vkCmdCopyBuffer2", 2, true, nil}
var CmdCopyBuffer2KHR = CmdCopyBuffer2

// CmdCopyBufferToImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage.html
func CmdCopyBufferToImage(commandBuffer CommandBuffer, srcBuffer Buffer, dstImage Image, dstImageLayout ImageLayout, regions []BufferImageCopy) {
	regionCount := len(regions)
	// regions is an input slice that requires translation to an internal type
	var pRegions unsafe.Pointer
	if len(regions) > 0 {
		sl_regions := make([]_vkBufferImageCopy, regionCount)
		for i, v := range regions {
			sl_regions[i] = *(v.Vulkanize())
		}
		pRegions = unsafe.Pointer(&sl_regions[0])
	}

	execTrampoline(vkCmdCopyBufferToImage, uintptr(commandBuffer), uintptr(srcBuffer), uintptr(dstImage), uintptr(dstImageLayout), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)))

}

var vkCmdCopyBufferToImage = &vkCommand{"vkCmdCopyBufferToImage", 6, true, nil}

// CmdCopyBufferToImage2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage2.html
func CmdCopyBufferToImage2(commandBuffer CommandBuffer, copyBufferToImageInfo *CopyBufferToImageInfo2) {
	// Parameter is a singular input, requires translation - copyBufferToImageInfo
	var pCopyBufferToImageInfo *_vkCopyBufferToImageInfo2
	if copyBufferToImageInfo != nil {
		pCopyBufferToImageInfo = copyBufferToImageInfo.Vulkanize()
	}

	execTrampoline(vkCmdCopyBufferToImage2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pCopyBufferToImageInfo)))

}

var vkCmdCopyBufferToImage2 = &vkCommand{"vkCmdCopyBufferToImage2", 2, true, nil}
var CmdCopyBufferToImage2KHR = CmdCopyBufferToImage2

// CmdCopyImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage.html
func CmdCopyImage(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageCopy) {
	regionCount := len(regions)
	// regions is an input slice that requires translation to an internal type
	var pRegions unsafe.Pointer
	if len(regions) > 0 {
		sl_regions := make([]_vkImageCopy, regionCount)
		for i, v := range regions {
			sl_regions[i] = *(v.Vulkanize())
		}
		pRegions = unsafe.Pointer(&sl_regions[0])
	}

	execTrampoline(vkCmdCopyImage, uintptr(commandBuffer), uintptr(srcImage), uintptr(srcImageLayout), uintptr(dstImage), uintptr(dstImageLayout), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)))

}

var vkCmdCopyImage = &vkCommand{"vkCmdCopyImage", 7, true, nil}

// CmdCopyImage2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage2.html
func CmdCopyImage2(commandBuffer CommandBuffer, copyImageInfo *CopyImageInfo2) {
	// Parameter is a singular input, requires translation - copyImageInfo
	var pCopyImageInfo *_vkCopyImageInfo2
	if copyImageInfo != nil {
		pCopyImageInfo = copyImageInfo.Vulkanize()
	}

	execTrampoline(vkCmdCopyImage2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pCopyImageInfo)))

}

var vkCmdCopyImage2 = &vkCommand{"vkCmdCopyImage2", 2, true, nil}
var CmdCopyImage2KHR = CmdCopyImage2

// CmdCopyImageToBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer.html
func CmdCopyImageToBuffer(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstBuffer Buffer, regions []BufferImageCopy) {
	regionCount := len(regions)
	// regions is an input slice that requires translation to an internal type
	var pRegions unsafe.Pointer
	if len(regions) > 0 {
		sl_regions := make([]_vkBufferImageCopy, regionCount)
		for i, v := range regions {
			sl_regions[i] = *(v.Vulkanize())
		}
		pRegions = unsafe.Pointer(&sl_regions[0])
	}

	execTrampoline(vkCmdCopyImageToBuffer, uintptr(commandBuffer), uintptr(srcImage), uintptr(srcImageLayout), uintptr(dstBuffer), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)))

}

var vkCmdCopyImageToBuffer = &vkCommand{"vkCmdCopyImageToBuffer", 6, true, nil}

// CmdCopyImageToBuffer2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer2.html
func CmdCopyImageToBuffer2(commandBuffer CommandBuffer, copyImageToBufferInfo *CopyImageToBufferInfo2) {
	// Parameter is a singular input, requires translation - copyImageToBufferInfo
	var pCopyImageToBufferInfo *_vkCopyImageToBufferInfo2
	if copyImageToBufferInfo != nil {
		pCopyImageToBufferInfo = copyImageToBufferInfo.Vulkanize()
	}

	execTrampoline(vkCmdCopyImageToBuffer2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pCopyImageToBufferInfo)))

}

var vkCmdCopyImageToBuffer2 = &vkCommand{"vkCmdCopyImageToBuffer2", 2, true, nil}
var CmdCopyImageToBuffer2KHR = CmdCopyImageToBuffer2

// CmdCopyMemoryIndirectNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryIndirectNV.html
func CmdCopyMemoryIndirectNV(commandBuffer CommandBuffer, copyBufferAddress DeviceAddress, copyCount uint32, stride uint32) {

	execTrampoline(vkCmdCopyMemoryIndirectNV, uintptr(commandBuffer), uintptr(copyBufferAddress), uintptr(copyCount), uintptr(stride))

}

var vkCmdCopyMemoryIndirectNV = &vkCommand{"vkCmdCopyMemoryIndirectNV", 4, true, nil}

// CmdCopyMemoryToAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryToAccelerationStructureKHR.html
func CmdCopyMemoryToAccelerationStructureKHR(commandBuffer CommandBuffer, info *CopyMemoryToAccelerationStructureInfoKHR) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMemoryToAccelerationStructureInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	execTrampoline(vkCmdCopyMemoryToAccelerationStructureKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)))

}

var vkCmdCopyMemoryToAccelerationStructureKHR = &vkCommand{"vkCmdCopyMemoryToAccelerationStructureKHR", 2, true, nil}

// CmdCopyMemoryToImageIndirectNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryToImageIndirectNV.html
func CmdCopyMemoryToImageIndirectNV(commandBuffer CommandBuffer, copyBufferAddress DeviceAddress, stride uint32, dstImage Image, dstImageLayout ImageLayout, imageSubresources []ImageSubresourceLayers) {
	copyCount := len(imageSubresources)
	// imageSubresources is an input slice of values that do not need translation used
	var pImageSubresources unsafe.Pointer
	if imageSubresources != nil {
		pImageSubresources = unsafe.Pointer(&imageSubresources[0])
	}

	execTrampoline(vkCmdCopyMemoryToImageIndirectNV, uintptr(commandBuffer), uintptr(copyBufferAddress), uintptr(copyCount), uintptr(stride), uintptr(dstImage), uintptr(dstImageLayout), uintptr(unsafe.Pointer(pImageSubresources)))

}

var vkCmdCopyMemoryToImageIndirectNV = &vkCommand{"vkCmdCopyMemoryToImageIndirectNV", 7, true, nil}

// CmdCopyMemoryToMicromapEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryToMicromapEXT.html
func CmdCopyMemoryToMicromapEXT(commandBuffer CommandBuffer, info *CopyMemoryToMicromapInfoEXT) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMemoryToMicromapInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	execTrampoline(vkCmdCopyMemoryToMicromapEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)))

}

var vkCmdCopyMemoryToMicromapEXT = &vkCommand{"vkCmdCopyMemoryToMicromapEXT", 2, true, nil}

// CmdCopyMicromapEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMicromapEXT.html
func CmdCopyMicromapEXT(commandBuffer CommandBuffer, info *CopyMicromapInfoEXT) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMicromapInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	execTrampoline(vkCmdCopyMicromapEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)))

}

var vkCmdCopyMicromapEXT = &vkCommand{"vkCmdCopyMicromapEXT", 2, true, nil}

// CmdCopyMicromapToMemoryEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMicromapToMemoryEXT.html
func CmdCopyMicromapToMemoryEXT(commandBuffer CommandBuffer, info *CopyMicromapToMemoryInfoEXT) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMicromapToMemoryInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	execTrampoline(vkCmdCopyMicromapToMemoryEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)))

}

var vkCmdCopyMicromapToMemoryEXT = &vkCommand{"vkCmdCopyMicromapToMemoryEXT", 2, true, nil}

// CmdCopyQueryPoolResults: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyQueryPoolResults.html
func CmdCopyQueryPoolResults(commandBuffer CommandBuffer, queryPool QueryPool, firstQuery uint32, queryCount uint32, dstBuffer Buffer, dstOffset DeviceSize, stride DeviceSize, flags QueryResultFlags) {

	execTrampoline(vkCmdCopyQueryPoolResults, uintptr(commandBuffer), uintptr(queryPool), uintptr(firstQuery), uintptr(queryCount), uintptr(dstBuffer), uintptr(dstOffset), uintptr(stride), uintptr(flags))

}

var vkCmdCopyQueryPoolResults = &vkCommand{"vkCmdCopyQueryPoolResults", 8, true, nil}

// CmdCuLaunchKernelNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCuLaunchKernelNVX.html
func CmdCuLaunchKernelNVX(commandBuffer CommandBuffer, launchInfo *CuLaunchInfoNVX) {
	// Parameter is a singular input, requires translation - launchInfo
	var pLaunchInfo *_vkCuLaunchInfoNVX
	if launchInfo != nil {
		pLaunchInfo = launchInfo.Vulkanize()
	}

	execTrampoline(vkCmdCuLaunchKernelNVX, uintptr(commandBuffer), uintptr(unsafe.Pointer(pLaunchInfo)))

}

var vkCmdCuLaunchKernelNVX = &vkCommand{"vkCmdCuLaunchKernelNVX", 2, true, nil}

// CmdCudaLaunchKernelNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCudaLaunchKernelNV.html
func CmdCudaLaunchKernelNV(commandBuffer CommandBuffer, launchInfo *CudaLaunchInfoNV) {
	// Parameter is a singular input, requires translation - launchInfo
	var pLaunchInfo *_vkCudaLaunchInfoNV
	if launchInfo != nil {
		pLaunchInfo = launchInfo.Vulkanize()
	}

	execTrampoline(vkCmdCudaLaunchKernelNV, uintptr(commandBuffer), uintptr(unsafe.Pointer(pLaunchInfo)))

}

var vkCmdCudaLaunchKernelNV = &vkCommand{"vkCmdCudaLaunchKernelNV", 2, true, nil}

// CmdDebugMarkerBeginEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDebugMarkerBeginEXT.html
func CmdDebugMarkerBeginEXT(commandBuffer CommandBuffer, markerInfo *DebugMarkerMarkerInfoEXT) {
	// Parameter is a singular input, requires translation - markerInfo
	var pMarkerInfo *_vkDebugMarkerMarkerInfoEXT
	if markerInfo != nil {
		pMarkerInfo = markerInfo.Vulkanize()
	}

	execTrampoline(vkCmdDebugMarkerBeginEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pMarkerInfo)))

}

var vkCmdDebugMarkerBeginEXT = &vkCommand{"vkCmdDebugMarkerBeginEXT", 2, true, nil}

// CmdDebugMarkerEndEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDebugMarkerEndEXT.html
func CmdDebugMarkerEndEXT(commandBuffer CommandBuffer) {

	execTrampoline(vkCmdDebugMarkerEndEXT, uintptr(commandBuffer))

}

var vkCmdDebugMarkerEndEXT = &vkCommand{"vkCmdDebugMarkerEndEXT", 1, true, nil}

// CmdDebugMarkerInsertEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDebugMarkerInsertEXT.html
func CmdDebugMarkerInsertEXT(commandBuffer CommandBuffer, markerInfo *DebugMarkerMarkerInfoEXT) {
	// Parameter is a singular input, requires translation - markerInfo
	var pMarkerInfo *_vkDebugMarkerMarkerInfoEXT
	if markerInfo != nil {
		pMarkerInfo = markerInfo.Vulkanize()
	}

	execTrampoline(vkCmdDebugMarkerInsertEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pMarkerInfo)))

}

var vkCmdDebugMarkerInsertEXT = &vkCommand{"vkCmdDebugMarkerInsertEXT", 2, true, nil}

// CmdDecodeVideoKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDecodeVideoKHR.html
func CmdDecodeVideoKHR(commandBuffer CommandBuffer, decodeInfo *VideoDecodeInfoKHR) {
	// Parameter is a singular input, requires translation - decodeInfo
	var pDecodeInfo *_vkVideoDecodeInfoKHR
	if decodeInfo != nil {
		pDecodeInfo = decodeInfo.Vulkanize()
	}

	execTrampoline(vkCmdDecodeVideoKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pDecodeInfo)))

}

var vkCmdDecodeVideoKHR = &vkCommand{"vkCmdDecodeVideoKHR", 2, true, nil}

// CmdDecompressMemoryIndirectCountNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDecompressMemoryIndirectCountNV.html
func CmdDecompressMemoryIndirectCountNV(commandBuffer CommandBuffer, indirectCommandsAddress DeviceAddress, indirectCommandsCountAddress DeviceAddress, stride uint32) {

	execTrampoline(vkCmdDecompressMemoryIndirectCountNV, uintptr(commandBuffer), uintptr(indirectCommandsAddress), uintptr(indirectCommandsCountAddress), uintptr(stride))

}

var vkCmdDecompressMemoryIndirectCountNV = &vkCommand{"vkCmdDecompressMemoryIndirectCountNV", 4, true, nil}

// CmdDecompressMemoryNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDecompressMemoryNV.html
func CmdDecompressMemoryNV(commandBuffer CommandBuffer, decompressMemoryRegions []DecompressMemoryRegionNV) {
	decompressRegionCount := len(decompressMemoryRegions)
	// decompressMemoryRegions is an input slice of values that do not need translation used
	var pDecompressMemoryRegions unsafe.Pointer
	if decompressMemoryRegions != nil {
		pDecompressMemoryRegions = unsafe.Pointer(&decompressMemoryRegions[0])
	}

	execTrampoline(vkCmdDecompressMemoryNV, uintptr(commandBuffer), uintptr(decompressRegionCount), uintptr(unsafe.Pointer(pDecompressMemoryRegions)))

}

var vkCmdDecompressMemoryNV = &vkCommand{"vkCmdDecompressMemoryNV", 3, true, nil}

// CmdDispatch: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatch.html
func CmdDispatch(commandBuffer CommandBuffer, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {

	execTrampoline(vkCmdDispatch, uintptr(commandBuffer), uintptr(groupCountX), uintptr(groupCountY), uintptr(groupCountZ))

}

var vkCmdDispatch = &vkCommand{"vkCmdDispatch", 4, true, nil}

// CmdDispatchBase: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchBase.html
func CmdDispatchBase(commandBuffer CommandBuffer, baseGroupX uint32, baseGroupY uint32, baseGroupZ uint32, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {

	execTrampoline(vkCmdDispatchBase, uintptr(commandBuffer), uintptr(baseGroupX), uintptr(baseGroupY), uintptr(baseGroupZ), uintptr(groupCountX), uintptr(groupCountY), uintptr(groupCountZ))

}

var vkCmdDispatchBase = &vkCommand{"vkCmdDispatchBase", 7, true, nil}
var CmdDispatchBaseKHR = CmdDispatchBase

// CmdDispatchIndirect: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchIndirect.html
func CmdDispatchIndirect(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize) {

	execTrampoline(vkCmdDispatchIndirect, uintptr(commandBuffer), uintptr(buffer), uintptr(offset))

}

var vkCmdDispatchIndirect = &vkCommand{"vkCmdDispatchIndirect", 3, true, nil}

// CmdDraw: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDraw.html
func CmdDraw(commandBuffer CommandBuffer, vertexCount uint32, instanceCount uint32, firstVertex uint32, firstInstance uint32) {

	execTrampoline(vkCmdDraw, uintptr(commandBuffer), uintptr(vertexCount), uintptr(instanceCount), uintptr(firstVertex), uintptr(firstInstance))

}

var vkCmdDraw = &vkCommand{"vkCmdDraw", 5, true, nil}

// CmdDrawClusterHUAWEI: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawClusterHUAWEI.html
func CmdDrawClusterHUAWEI(commandBuffer CommandBuffer, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {

	execTrampoline(vkCmdDrawClusterHUAWEI, uintptr(commandBuffer), uintptr(groupCountX), uintptr(groupCountY), uintptr(groupCountZ))

}

var vkCmdDrawClusterHUAWEI = &vkCommand{"vkCmdDrawClusterHUAWEI", 4, true, nil}

// CmdDrawClusterIndirectHUAWEI: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawClusterIndirectHUAWEI.html
func CmdDrawClusterIndirectHUAWEI(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize) {

	execTrampoline(vkCmdDrawClusterIndirectHUAWEI, uintptr(commandBuffer), uintptr(buffer), uintptr(offset))

}

var vkCmdDrawClusterIndirectHUAWEI = &vkCommand{"vkCmdDrawClusterIndirectHUAWEI", 3, true, nil}

// CmdDrawIndexed: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexed.html
func CmdDrawIndexed(commandBuffer CommandBuffer, indexCount uint32, instanceCount uint32, firstIndex uint32, vertexOffset int32, firstInstance uint32) {

	execTrampoline(vkCmdDrawIndexed, uintptr(commandBuffer), uintptr(indexCount), uintptr(instanceCount), uintptr(firstIndex), uintptr(vertexOffset), uintptr(firstInstance))

}

var vkCmdDrawIndexed = &vkCommand{"vkCmdDrawIndexed", 6, true, nil}

// CmdDrawIndexedIndirect: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexedIndirect.html
func CmdDrawIndexedIndirect(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {

	execTrampoline(vkCmdDrawIndexedIndirect, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(drawCount), uintptr(stride))

}

var vkCmdDrawIndexedIndirect = &vkCommand{"vkCmdDrawIndexedIndirect", 5, true, nil}

// CmdDrawIndexedIndirectCount: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexedIndirectCount.html
func CmdDrawIndexedIndirectCount(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {

	execTrampoline(vkCmdDrawIndexedIndirectCount, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(countBuffer), uintptr(countBufferOffset), uintptr(maxDrawCount), uintptr(stride))

}

var vkCmdDrawIndexedIndirectCount = &vkCommand{"vkCmdDrawIndexedIndirectCount", 7, true, nil}
var CmdDrawIndexedIndirectCountAMD = CmdDrawIndexedIndirectCount

var CmdDrawIndexedIndirectCountKHR = CmdDrawIndexedIndirectCount

// CmdDrawIndirect: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirect.html
func CmdDrawIndirect(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {

	execTrampoline(vkCmdDrawIndirect, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(drawCount), uintptr(stride))

}

var vkCmdDrawIndirect = &vkCommand{"vkCmdDrawIndirect", 5, true, nil}

// CmdDrawIndirectByteCountEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirectByteCountEXT.html
func CmdDrawIndirectByteCountEXT(commandBuffer CommandBuffer, instanceCount uint32, firstInstance uint32, counterBuffer Buffer, counterBufferOffset DeviceSize, counterOffset uint32, vertexStride uint32) {

	execTrampoline(vkCmdDrawIndirectByteCountEXT, uintptr(commandBuffer), uintptr(instanceCount), uintptr(firstInstance), uintptr(counterBuffer), uintptr(counterBufferOffset), uintptr(counterOffset), uintptr(vertexStride))

}

var vkCmdDrawIndirectByteCountEXT = &vkCommand{"vkCmdDrawIndirectByteCountEXT", 7, true, nil}

// CmdDrawIndirectCount: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirectCount.html
func CmdDrawIndirectCount(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {

	execTrampoline(vkCmdDrawIndirectCount, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(countBuffer), uintptr(countBufferOffset), uintptr(maxDrawCount), uintptr(stride))

}

var vkCmdDrawIndirectCount = &vkCommand{"vkCmdDrawIndirectCount", 7, true, nil}
var CmdDrawIndirectCountAMD = CmdDrawIndirectCount

var CmdDrawIndirectCountKHR = CmdDrawIndirectCount

// CmdDrawMeshTasksEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksEXT.html
func CmdDrawMeshTasksEXT(commandBuffer CommandBuffer, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {

	execTrampoline(vkCmdDrawMeshTasksEXT, uintptr(commandBuffer), uintptr(groupCountX), uintptr(groupCountY), uintptr(groupCountZ))

}

var vkCmdDrawMeshTasksEXT = &vkCommand{"vkCmdDrawMeshTasksEXT", 4, true, nil}

// CmdDrawMeshTasksIndirectCountEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectCountEXT.html
func CmdDrawMeshTasksIndirectCountEXT(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {

	execTrampoline(vkCmdDrawMeshTasksIndirectCountEXT, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(countBuffer), uintptr(countBufferOffset), uintptr(maxDrawCount), uintptr(stride))

}

var vkCmdDrawMeshTasksIndirectCountEXT = &vkCommand{"vkCmdDrawMeshTasksIndirectCountEXT", 7, true, nil}

// CmdDrawMeshTasksIndirectCountNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectCountNV.html
func CmdDrawMeshTasksIndirectCountNV(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {

	execTrampoline(vkCmdDrawMeshTasksIndirectCountNV, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(countBuffer), uintptr(countBufferOffset), uintptr(maxDrawCount), uintptr(stride))

}

var vkCmdDrawMeshTasksIndirectCountNV = &vkCommand{"vkCmdDrawMeshTasksIndirectCountNV", 7, true, nil}

// CmdDrawMeshTasksIndirectEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectEXT.html
func CmdDrawMeshTasksIndirectEXT(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {

	execTrampoline(vkCmdDrawMeshTasksIndirectEXT, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(drawCount), uintptr(stride))

}

var vkCmdDrawMeshTasksIndirectEXT = &vkCommand{"vkCmdDrawMeshTasksIndirectEXT", 5, true, nil}

// CmdDrawMeshTasksIndirectNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectNV.html
func CmdDrawMeshTasksIndirectNV(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {

	execTrampoline(vkCmdDrawMeshTasksIndirectNV, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(drawCount), uintptr(stride))

}

var vkCmdDrawMeshTasksIndirectNV = &vkCommand{"vkCmdDrawMeshTasksIndirectNV", 5, true, nil}

// CmdDrawMeshTasksNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksNV.html
func CmdDrawMeshTasksNV(commandBuffer CommandBuffer, taskCount uint32, firstTask uint32) {

	execTrampoline(vkCmdDrawMeshTasksNV, uintptr(commandBuffer), uintptr(taskCount), uintptr(firstTask))

}

var vkCmdDrawMeshTasksNV = &vkCommand{"vkCmdDrawMeshTasksNV", 3, true, nil}

// CmdDrawMultiEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMultiEXT.html
func CmdDrawMultiEXT(commandBuffer CommandBuffer, vertexInfo []MultiDrawInfoEXT, instanceCount uint32, firstInstance uint32, stride uint32) {
	drawCount := len(vertexInfo)
	// vertexInfo is an input slice of values that do not need translation used
	var pVertexInfo unsafe.Pointer
	if vertexInfo != nil {
		pVertexInfo = unsafe.Pointer(&vertexInfo[0])
	}

	execTrampoline(vkCmdDrawMultiEXT, uintptr(commandBuffer), uintptr(drawCount), uintptr(unsafe.Pointer(pVertexInfo)), uintptr(instanceCount), uintptr(firstInstance), uintptr(stride))

}

var vkCmdDrawMultiEXT = &vkCommand{"vkCmdDrawMultiEXT", 6, true, nil}

// CmdDrawMultiIndexedEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMultiIndexedEXT.html
func CmdDrawMultiIndexedEXT(commandBuffer CommandBuffer, indexInfo []MultiDrawIndexedInfoEXT, instanceCount uint32, firstInstance uint32, stride uint32, vertexOffset *int32) {
	drawCount := len(indexInfo)
	// indexInfo is an input slice of values that do not need translation used
	var pIndexInfo unsafe.Pointer
	if indexInfo != nil {
		pIndexInfo = unsafe.Pointer(&indexInfo[0])
	}

	// Parameter is a singular input, pass direct - vertexOffset
	var pVertexOffset unsafe.Pointer
	if vertexOffset != nil {
		pVertexOffset = unsafe.Pointer(vertexOffset)
	}

	execTrampoline(vkCmdDrawMultiIndexedEXT, uintptr(commandBuffer), uintptr(drawCount), uintptr(unsafe.Pointer(pIndexInfo)), uintptr(instanceCount), uintptr(firstInstance), uintptr(stride), uintptr(unsafe.Pointer(pVertexOffset)))

}

var vkCmdDrawMultiIndexedEXT = &vkCommand{"vkCmdDrawMultiIndexedEXT", 7, true, nil}

// CmdEncodeVideoKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEncodeVideoKHR.html
func CmdEncodeVideoKHR(commandBuffer CommandBuffer, encodeInfo *VideoEncodeInfoKHR) {
	// Parameter is a singular input, requires translation - encodeInfo
	var pEncodeInfo *_vkVideoEncodeInfoKHR
	if encodeInfo != nil {
		pEncodeInfo = encodeInfo.Vulkanize()
	}

	execTrampoline(vkCmdEncodeVideoKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pEncodeInfo)))

}

var vkCmdEncodeVideoKHR = &vkCommand{"vkCmdEncodeVideoKHR", 2, true, nil}

// CmdEndConditionalRenderingEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndConditionalRenderingEXT.html
func CmdEndConditionalRenderingEXT(commandBuffer CommandBuffer) {

	execTrampoline(vkCmdEndConditionalRenderingEXT, uintptr(commandBuffer))

}

var vkCmdEndConditionalRenderingEXT = &vkCommand{"vkCmdEndConditionalRenderingEXT", 1, true, nil}

// CmdEndDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndDebugUtilsLabelEXT.html
func CmdEndDebugUtilsLabelEXT(commandBuffer CommandBuffer) {

	execTrampoline(vkCmdEndDebugUtilsLabelEXT, uintptr(commandBuffer))

}

var vkCmdEndDebugUtilsLabelEXT = &vkCommand{"vkCmdEndDebugUtilsLabelEXT", 1, true, nil}

// CmdEndQuery: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndQuery.html
func CmdEndQuery(commandBuffer CommandBuffer, queryPool QueryPool, query uint32) {

	execTrampoline(vkCmdEndQuery, uintptr(commandBuffer), uintptr(queryPool), uintptr(query))

}

var vkCmdEndQuery = &vkCommand{"vkCmdEndQuery", 3, true, nil}

// CmdEndQueryIndexedEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndQueryIndexedEXT.html
func CmdEndQueryIndexedEXT(commandBuffer CommandBuffer, queryPool QueryPool, query uint32, index uint32) {

	execTrampoline(vkCmdEndQueryIndexedEXT, uintptr(commandBuffer), uintptr(queryPool), uintptr(query), uintptr(index))

}

var vkCmdEndQueryIndexedEXT = &vkCommand{"vkCmdEndQueryIndexedEXT", 4, true, nil}

// CmdEndRenderPass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderPass.html
func CmdEndRenderPass(commandBuffer CommandBuffer) {

	execTrampoline(vkCmdEndRenderPass, uintptr(commandBuffer))

}

var vkCmdEndRenderPass = &vkCommand{"vkCmdEndRenderPass", 1, true, nil}

// CmdEndRenderPass2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderPass2.html
func CmdEndRenderPass2(commandBuffer CommandBuffer, subpassEndInfo *SubpassEndInfo) {
	// Parameter is a singular input, requires translation - subpassEndInfo
	var pSubpassEndInfo *_vkSubpassEndInfo
	if subpassEndInfo != nil {
		pSubpassEndInfo = subpassEndInfo.Vulkanize()
	}

	execTrampoline(vkCmdEndRenderPass2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pSubpassEndInfo)))

}

var vkCmdEndRenderPass2 = &vkCommand{"vkCmdEndRenderPass2", 2, true, nil}
var CmdEndRenderPass2KHR = CmdEndRenderPass2

// CmdEndRendering: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRendering.html
func CmdEndRendering(commandBuffer CommandBuffer) {

	execTrampoline(vkCmdEndRendering, uintptr(commandBuffer))

}

var vkCmdEndRendering = &vkCommand{"vkCmdEndRendering", 1, true, nil}
var CmdEndRenderingKHR = CmdEndRendering

// CmdEndTransformFeedbackEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndTransformFeedbackEXT.html
func CmdEndTransformFeedbackEXT(commandBuffer CommandBuffer, firstCounterBuffer uint32, counterBuffers []Buffer, counterBufferOffsets []DeviceSize) {
	counterBufferCount := len(counterBuffers)
	// counterBuffers is an input slice of values that do not need translation used
	var pCounterBuffers unsafe.Pointer
	if counterBuffers != nil {
		pCounterBuffers = unsafe.Pointer(&counterBuffers[0])
	}

	// counterBufferOffsets is an input slice of values that do not need translation used
	var pCounterBufferOffsets unsafe.Pointer
	if counterBufferOffsets != nil {
		pCounterBufferOffsets = unsafe.Pointer(&counterBufferOffsets[0])
	}

	execTrampoline(vkCmdEndTransformFeedbackEXT, uintptr(commandBuffer), uintptr(firstCounterBuffer), uintptr(counterBufferCount), uintptr(unsafe.Pointer(pCounterBuffers)), uintptr(unsafe.Pointer(pCounterBufferOffsets)))

}

var vkCmdEndTransformFeedbackEXT = &vkCommand{"vkCmdEndTransformFeedbackEXT", 5, true, nil}

// CmdEndVideoCodingKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndVideoCodingKHR.html
func CmdEndVideoCodingKHR(commandBuffer CommandBuffer, endCodingInfo *VideoEndCodingInfoKHR) {
	// Parameter is a singular input, requires translation - endCodingInfo
	var pEndCodingInfo *_vkVideoEndCodingInfoKHR
	if endCodingInfo != nil {
		pEndCodingInfo = endCodingInfo.Vulkanize()
	}

	execTrampoline(vkCmdEndVideoCodingKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pEndCodingInfo)))

}

var vkCmdEndVideoCodingKHR = &vkCommand{"vkCmdEndVideoCodingKHR", 2, true, nil}

// CmdExecuteCommands: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdExecuteCommands.html
func CmdExecuteCommands(commandBuffer CommandBuffer, commandBuffers []CommandBuffer) {
	commandBufferCount := len(commandBuffers)
	// commandBuffers is an input slice of values that do not need translation used
	var pCommandBuffers unsafe.Pointer
	if commandBuffers != nil {
		pCommandBuffers = unsafe.Pointer(&commandBuffers[0])
	}

	execTrampoline(vkCmdExecuteCommands, uintptr(commandBuffer), uintptr(commandBufferCount), uintptr(unsafe.Pointer(pCommandBuffers)))

}

var vkCmdExecuteCommands = &vkCommand{"vkCmdExecuteCommands", 3, true, nil}

// CmdExecuteGeneratedCommandsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdExecuteGeneratedCommandsNV.html
func CmdExecuteGeneratedCommandsNV(commandBuffer CommandBuffer, isPreprocessed bool, generatedCommandsInfo *GeneratedCommandsInfoNV) {
	isPreprocessed_Bool32 := translateInternal_Bool32(isPreprocessed)
	// Parameter is a singular input, requires translation - generatedCommandsInfo
	var pGeneratedCommandsInfo *_vkGeneratedCommandsInfoNV
	if generatedCommandsInfo != nil {
		pGeneratedCommandsInfo = generatedCommandsInfo.Vulkanize()
	}

	execTrampoline(vkCmdExecuteGeneratedCommandsNV, uintptr(commandBuffer), uintptr(isPreprocessed_Bool32), uintptr(unsafe.Pointer(pGeneratedCommandsInfo)))

}

var vkCmdExecuteGeneratedCommandsNV = &vkCommand{"vkCmdExecuteGeneratedCommandsNV", 3, true, nil}

// CmdFillBuffer: transfer support is only available when VK_KHR_maintenance1 is enabled, as documented in valid usage language in the specification
// See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdFillBuffer.html
func CmdFillBuffer(commandBuffer CommandBuffer, dstBuffer Buffer, dstOffset DeviceSize, size DeviceSize, data uint32) {

	execTrampoline(vkCmdFillBuffer, uintptr(commandBuffer), uintptr(dstBuffer), uintptr(dstOffset), uintptr(size), uintptr(data))

}

var vkCmdFillBuffer = &vkCommand{"vkCmdFillBuffer", 5, true, nil}

// CmdInsertDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdInsertDebugUtilsLabelEXT.html
func CmdInsertDebugUtilsLabelEXT(commandBuffer CommandBuffer, labelInfo *DebugUtilsLabelEXT) {
	// Parameter is a singular input, requires translation - labelInfo
	var pLabelInfo *_vkDebugUtilsLabelEXT
	if labelInfo != nil {
		pLabelInfo = labelInfo.Vulkanize()
	}

	execTrampoline(vkCmdInsertDebugUtilsLabelEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pLabelInfo)))

}

var vkCmdInsertDebugUtilsLabelEXT = &vkCommand{"vkCmdInsertDebugUtilsLabelEXT", 2, true, nil}

// CmdNextSubpass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdNextSubpass.html
func CmdNextSubpass(commandBuffer CommandBuffer, contents SubpassContents) {

	execTrampoline(vkCmdNextSubpass, uintptr(commandBuffer), uintptr(contents))

}

var vkCmdNextSubpass = &vkCommand{"vkCmdNextSubpass", 2, true, nil}

// CmdNextSubpass2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdNextSubpass2.html
func CmdNextSubpass2(commandBuffer CommandBuffer, subpassBeginInfo *SubpassBeginInfo, subpassEndInfo *SubpassEndInfo) {
	// Parameter is a singular input, requires translation - subpassBeginInfo
	var pSubpassBeginInfo *_vkSubpassBeginInfo
	if subpassBeginInfo != nil {
		pSubpassBeginInfo = subpassBeginInfo.Vulkanize()
	}

	// Parameter is a singular input, requires translation - subpassEndInfo
	var pSubpassEndInfo *_vkSubpassEndInfo
	if subpassEndInfo != nil {
		pSubpassEndInfo = subpassEndInfo.Vulkanize()
	}

	execTrampoline(vkCmdNextSubpass2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pSubpassBeginInfo)), uintptr(unsafe.Pointer(pSubpassEndInfo)))

}

var vkCmdNextSubpass2 = &vkCommand{"vkCmdNextSubpass2", 3, true, nil}
var CmdNextSubpass2KHR = CmdNextSubpass2

// CmdOpticalFlowExecuteNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdOpticalFlowExecuteNV.html
func CmdOpticalFlowExecuteNV(commandBuffer CommandBuffer, session OpticalFlowSessionNV, executeInfo *OpticalFlowExecuteInfoNV) {
	// Parameter is a singular input, requires translation - executeInfo
	var pExecuteInfo *_vkOpticalFlowExecuteInfoNV
	if executeInfo != nil {
		pExecuteInfo = executeInfo.Vulkanize()
	}

	execTrampoline(vkCmdOpticalFlowExecuteNV, uintptr(commandBuffer), uintptr(session), uintptr(unsafe.Pointer(pExecuteInfo)))

}

var vkCmdOpticalFlowExecuteNV = &vkCommand{"vkCmdOpticalFlowExecuteNV", 3, true, nil}

// CmdPipelineBarrier: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier.html
func CmdPipelineBarrier(commandBuffer CommandBuffer, srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, dependencyFlags DependencyFlags, memoryBarriers []MemoryBarrier, bufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarriers []ImageMemoryBarrier) {
	memoryBarrierCount := len(memoryBarriers)
	// memoryBarriers is an input slice that requires translation to an internal type
	var pMemoryBarriers unsafe.Pointer
	if len(memoryBarriers) > 0 {
		sl_memoryBarriers := make([]_vkMemoryBarrier, memoryBarrierCount)
		for i, v := range memoryBarriers {
			sl_memoryBarriers[i] = *(v.Vulkanize())
		}
		pMemoryBarriers = unsafe.Pointer(&sl_memoryBarriers[0])
	}

	bufferMemoryBarrierCount := len(bufferMemoryBarriers)
	// bufferMemoryBarriers is an input slice that requires translation to an internal type
	var pBufferMemoryBarriers unsafe.Pointer
	if len(bufferMemoryBarriers) > 0 {
		sl_bufferMemoryBarriers := make([]_vkBufferMemoryBarrier, bufferMemoryBarrierCount)
		for i, v := range bufferMemoryBarriers {
			sl_bufferMemoryBarriers[i] = *(v.Vulkanize())
		}
		pBufferMemoryBarriers = unsafe.Pointer(&sl_bufferMemoryBarriers[0])
	}

	imageMemoryBarrierCount := len(imageMemoryBarriers)
	// imageMemoryBarriers is an input slice that requires translation to an internal type
	var pImageMemoryBarriers unsafe.Pointer
	if len(imageMemoryBarriers) > 0 {
		sl_imageMemoryBarriers := make([]_vkImageMemoryBarrier, imageMemoryBarrierCount)
		for i, v := range imageMemoryBarriers {
			sl_imageMemoryBarriers[i] = *(v.Vulkanize())
		}
		pImageMemoryBarriers = unsafe.Pointer(&sl_imageMemoryBarriers[0])
	}

	execTrampoline(vkCmdPipelineBarrier, uintptr(commandBuffer), uintptr(srcStageMask), uintptr(dstStageMask), uintptr(dependencyFlags), uintptr(memoryBarrierCount), uintptr(unsafe.Pointer(pMemoryBarriers)), uintptr(bufferMemoryBarrierCount), uintptr(unsafe.Pointer(pBufferMemoryBarriers)), uintptr(imageMemoryBarrierCount), uintptr(unsafe.Pointer(pImageMemoryBarriers)))

}

var vkCmdPipelineBarrier = &vkCommand{"vkCmdPipelineBarrier", 10, true, nil}

// CmdPipelineBarrier2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier2.html
func CmdPipelineBarrier2(commandBuffer CommandBuffer, dependencyInfo *DependencyInfo) {
	// Parameter is a singular input, requires translation - dependencyInfo
	var pDependencyInfo *_vkDependencyInfo
	if dependencyInfo != nil {
		pDependencyInfo = dependencyInfo.Vulkanize()
	}

	execTrampoline(vkCmdPipelineBarrier2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pDependencyInfo)))

}

var vkCmdPipelineBarrier2 = &vkCommand{"vkCmdPipelineBarrier2", 2, true, nil}
var CmdPipelineBarrier2KHR = CmdPipelineBarrier2

// CmdPreprocessGeneratedCommandsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPreprocessGeneratedCommandsNV.html
func CmdPreprocessGeneratedCommandsNV(commandBuffer CommandBuffer, generatedCommandsInfo *GeneratedCommandsInfoNV) {
	// Parameter is a singular input, requires translation - generatedCommandsInfo
	var pGeneratedCommandsInfo *_vkGeneratedCommandsInfoNV
	if generatedCommandsInfo != nil {
		pGeneratedCommandsInfo = generatedCommandsInfo.Vulkanize()
	}

	execTrampoline(vkCmdPreprocessGeneratedCommandsNV, uintptr(commandBuffer), uintptr(unsafe.Pointer(pGeneratedCommandsInfo)))

}

var vkCmdPreprocessGeneratedCommandsNV = &vkCommand{"vkCmdPreprocessGeneratedCommandsNV", 2, true, nil}

// CmdPushConstants: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushConstants.html
func CmdPushConstants(commandBuffer CommandBuffer, layout PipelineLayout, stageFlags ShaderStageFlags, offset uint32, values []byte) {
	size := len(values)
	// values is an input slice of values that do not need translation used
	var pValues unsafe.Pointer
	if values != nil {
		pValues = unsafe.Pointer(&values[0])
	}

	execTrampoline(vkCmdPushConstants, uintptr(commandBuffer), uintptr(layout), uintptr(stageFlags), uintptr(offset), uintptr(size), uintptr(unsafe.Pointer(pValues)))

}

var vkCmdPushConstants = &vkCommand{"vkCmdPushConstants", 6, true, nil}

// CmdPushConstants2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushConstants2KHR.html
func CmdPushConstants2KHR(commandBuffer CommandBuffer, pushConstantsInfo *PushConstantsInfoKHR) {
	// Parameter is a singular input, requires translation - pushConstantsInfo
	var pPushConstantsInfo *_vkPushConstantsInfoKHR
	if pushConstantsInfo != nil {
		pPushConstantsInfo = pushConstantsInfo.Vulkanize()
	}

	execTrampoline(vkCmdPushConstants2KHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pPushConstantsInfo)))

}

var vkCmdPushConstants2KHR = &vkCommand{"vkCmdPushConstants2KHR", 2, true, nil}

// CmdPushDescriptorSet2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSet2KHR.html
func CmdPushDescriptorSet2KHR(commandBuffer CommandBuffer, pushDescriptorSetInfo *PushDescriptorSetInfoKHR) {
	// Parameter is a singular input, requires translation - pushDescriptorSetInfo
	var pPushDescriptorSetInfo *_vkPushDescriptorSetInfoKHR
	if pushDescriptorSetInfo != nil {
		pPushDescriptorSetInfo = pushDescriptorSetInfo.Vulkanize()
	}

	execTrampoline(vkCmdPushDescriptorSet2KHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pPushDescriptorSetInfo)))

}

var vkCmdPushDescriptorSet2KHR = &vkCommand{"vkCmdPushDescriptorSet2KHR", 2, true, nil}

// CmdPushDescriptorSetKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSetKHR.html
func CmdPushDescriptorSetKHR(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, layout PipelineLayout, set uint32, descriptorWrites []WriteDescriptorSet) {
	descriptorWriteCount := len(descriptorWrites)
	// descriptorWrites is an input slice that requires translation to an internal type
	var pDescriptorWrites unsafe.Pointer
	if len(descriptorWrites) > 0 {
		sl_descriptorWrites := make([]_vkWriteDescriptorSet, descriptorWriteCount)
		for i, v := range descriptorWrites {
			sl_descriptorWrites[i] = *(v.Vulkanize())
		}
		pDescriptorWrites = unsafe.Pointer(&sl_descriptorWrites[0])
	}

	execTrampoline(vkCmdPushDescriptorSetKHR, uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(layout), uintptr(set), uintptr(descriptorWriteCount), uintptr(unsafe.Pointer(pDescriptorWrites)))

}

var vkCmdPushDescriptorSetKHR = &vkCommand{"vkCmdPushDescriptorSetKHR", 6, true, nil}

// CmdPushDescriptorSetWithTemplate2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSetWithTemplate2KHR.html
func CmdPushDescriptorSetWithTemplate2KHR(commandBuffer CommandBuffer, pushDescriptorSetWithTemplateInfo *PushDescriptorSetWithTemplateInfoKHR) {
	// Parameter is a singular input, requires translation - pushDescriptorSetWithTemplateInfo
	var pPushDescriptorSetWithTemplateInfo *_vkPushDescriptorSetWithTemplateInfoKHR
	if pushDescriptorSetWithTemplateInfo != nil {
		pPushDescriptorSetWithTemplateInfo = pushDescriptorSetWithTemplateInfo.Vulkanize()
	}

	execTrampoline(vkCmdPushDescriptorSetWithTemplate2KHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pPushDescriptorSetWithTemplateInfo)))

}

var vkCmdPushDescriptorSetWithTemplate2KHR = &vkCommand{"vkCmdPushDescriptorSetWithTemplate2KHR", 2, true, nil}

// CmdPushDescriptorSetWithTemplateKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSetWithTemplateKHR.html
func CmdPushDescriptorSetWithTemplateKHR(commandBuffer CommandBuffer, descriptorUpdateTemplate DescriptorUpdateTemplate, layout PipelineLayout, set uint32, data *byte) {
	// Parameter is a singular input, pass direct - data
	var pData unsafe.Pointer
	if data != nil {
		pData = unsafe.Pointer(data)
	}

	execTrampoline(vkCmdPushDescriptorSetWithTemplateKHR, uintptr(commandBuffer), uintptr(descriptorUpdateTemplate), uintptr(layout), uintptr(set), uintptr(unsafe.Pointer(pData)))

}

var vkCmdPushDescriptorSetWithTemplateKHR = &vkCommand{"vkCmdPushDescriptorSetWithTemplateKHR", 5, true, nil}

// CmdRefreshObjectsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdRefreshObjectsKHR.html
func CmdRefreshObjectsKHR(commandBuffer CommandBuffer, refreshObjects *RefreshObjectListKHR) {
	// Parameter is a singular input, requires translation - refreshObjects
	var pRefreshObjects *_vkRefreshObjectListKHR
	if refreshObjects != nil {
		pRefreshObjects = refreshObjects.Vulkanize()
	}

	execTrampoline(vkCmdRefreshObjectsKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pRefreshObjects)))

}

var vkCmdRefreshObjectsKHR = &vkCommand{"vkCmdRefreshObjectsKHR", 2, true, nil}

// CmdResetEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent.html
func CmdResetEvent(commandBuffer CommandBuffer, event Event, stageMask PipelineStageFlags) {

	execTrampoline(vkCmdResetEvent, uintptr(commandBuffer), uintptr(event), uintptr(stageMask))

}

var vkCmdResetEvent = &vkCommand{"vkCmdResetEvent", 3, true, nil}

// CmdResetEvent2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent2.html
func CmdResetEvent2(commandBuffer CommandBuffer, event Event, stageMask PipelineStageFlags2) {

	execTrampoline(vkCmdResetEvent2, uintptr(commandBuffer), uintptr(event), uintptr(stageMask))

}

var vkCmdResetEvent2 = &vkCommand{"vkCmdResetEvent2", 3, true, nil}
var CmdResetEvent2KHR = CmdResetEvent2

// CmdResetQueryPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetQueryPool.html
func CmdResetQueryPool(commandBuffer CommandBuffer, queryPool QueryPool, firstQuery uint32, queryCount uint32) {

	execTrampoline(vkCmdResetQueryPool, uintptr(commandBuffer), uintptr(queryPool), uintptr(firstQuery), uintptr(queryCount))

}

var vkCmdResetQueryPool = &vkCommand{"vkCmdResetQueryPool", 4, true, nil}

// CmdResolveImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage.html
func CmdResolveImage(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageResolve) {
	regionCount := len(regions)
	// regions is an input slice that requires translation to an internal type
	var pRegions unsafe.Pointer
	if len(regions) > 0 {
		sl_regions := make([]_vkImageResolve, regionCount)
		for i, v := range regions {
			sl_regions[i] = *(v.Vulkanize())
		}
		pRegions = unsafe.Pointer(&sl_regions[0])
	}

	execTrampoline(vkCmdResolveImage, uintptr(commandBuffer), uintptr(srcImage), uintptr(srcImageLayout), uintptr(dstImage), uintptr(dstImageLayout), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)))

}

var vkCmdResolveImage = &vkCommand{"vkCmdResolveImage", 7, true, nil}

// CmdResolveImage2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage2.html
func CmdResolveImage2(commandBuffer CommandBuffer, resolveImageInfo *ResolveImageInfo2) {
	// Parameter is a singular input, requires translation - resolveImageInfo
	var pResolveImageInfo *_vkResolveImageInfo2
	if resolveImageInfo != nil {
		pResolveImageInfo = resolveImageInfo.Vulkanize()
	}

	execTrampoline(vkCmdResolveImage2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pResolveImageInfo)))

}

var vkCmdResolveImage2 = &vkCommand{"vkCmdResolveImage2", 2, true, nil}
var CmdResolveImage2KHR = CmdResolveImage2

// CmdSetAlphaToCoverageEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetAlphaToCoverageEnableEXT.html
func CmdSetAlphaToCoverageEnableEXT(commandBuffer CommandBuffer, alphaToCoverageEnable bool) {
	alphaToCoverageEnable_Bool32 := translateInternal_Bool32(alphaToCoverageEnable)

	execTrampoline(vkCmdSetAlphaToCoverageEnableEXT, uintptr(commandBuffer), uintptr(alphaToCoverageEnable_Bool32))

}

var vkCmdSetAlphaToCoverageEnableEXT = &vkCommand{"vkCmdSetAlphaToCoverageEnableEXT", 2, true, nil}

// CmdSetAlphaToOneEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetAlphaToOneEnableEXT.html
func CmdSetAlphaToOneEnableEXT(commandBuffer CommandBuffer, alphaToOneEnable bool) {
	alphaToOneEnable_Bool32 := translateInternal_Bool32(alphaToOneEnable)

	execTrampoline(vkCmdSetAlphaToOneEnableEXT, uintptr(commandBuffer), uintptr(alphaToOneEnable_Bool32))

}

var vkCmdSetAlphaToOneEnableEXT = &vkCommand{"vkCmdSetAlphaToOneEnableEXT", 2, true, nil}

// CmdSetAttachmentFeedbackLoopEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetAttachmentFeedbackLoopEnableEXT.html
func CmdSetAttachmentFeedbackLoopEnableEXT(commandBuffer CommandBuffer, aspectMask ImageAspectFlags) {

	execTrampoline(vkCmdSetAttachmentFeedbackLoopEnableEXT, uintptr(commandBuffer), uintptr(aspectMask))

}

var vkCmdSetAttachmentFeedbackLoopEnableEXT = &vkCommand{"vkCmdSetAttachmentFeedbackLoopEnableEXT", 2, true, nil}

// CmdSetBlendConstants: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetBlendConstants.html
func CmdSetBlendConstants(commandBuffer CommandBuffer, blendConstants float32) {

	execTrampoline(vkCmdSetBlendConstants, uintptr(commandBuffer), uintptr(blendConstants))

}

var vkCmdSetBlendConstants = &vkCommand{"vkCmdSetBlendConstants", 2, true, nil}

// CmdSetCheckpointNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCheckpointNV.html
func CmdSetCheckpointNV(commandBuffer CommandBuffer, checkpointMarker *byte) {
	// Parameter is a singular input, pass direct - checkpointMarker
	var pCheckpointMarker unsafe.Pointer
	if checkpointMarker != nil {
		pCheckpointMarker = unsafe.Pointer(checkpointMarker)
	}

	execTrampoline(vkCmdSetCheckpointNV, uintptr(commandBuffer), uintptr(unsafe.Pointer(pCheckpointMarker)))

}

var vkCmdSetCheckpointNV = &vkCommand{"vkCmdSetCheckpointNV", 2, true, nil}

// CmdSetCoarseSampleOrderNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoarseSampleOrderNV.html
func CmdSetCoarseSampleOrderNV(commandBuffer CommandBuffer, sampleOrderType CoarseSampleOrderTypeNV, customSampleOrders []CoarseSampleOrderCustomNV) {
	customSampleOrderCount := len(customSampleOrders)
	// customSampleOrders is an input slice that requires translation to an internal type
	var pCustomSampleOrders unsafe.Pointer
	if len(customSampleOrders) > 0 {
		sl_customSampleOrders := make([]_vkCoarseSampleOrderCustomNV, customSampleOrderCount)
		for i, v := range customSampleOrders {
			sl_customSampleOrders[i] = *(v.Vulkanize())
		}
		pCustomSampleOrders = unsafe.Pointer(&sl_customSampleOrders[0])
	}

	execTrampoline(vkCmdSetCoarseSampleOrderNV, uintptr(commandBuffer), uintptr(sampleOrderType), uintptr(customSampleOrderCount), uintptr(unsafe.Pointer(pCustomSampleOrders)))

}

var vkCmdSetCoarseSampleOrderNV = &vkCommand{"vkCmdSetCoarseSampleOrderNV", 4, true, nil}

// CmdSetColorBlendAdvancedEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorBlendAdvancedEXT.html
func CmdSetColorBlendAdvancedEXT(commandBuffer CommandBuffer, firstAttachment uint32, colorBlendAdvanced []ColorBlendAdvancedEXT) {
	attachmentCount := len(colorBlendAdvanced)
	// colorBlendAdvanced is an input slice that requires translation to an internal type
	var pColorBlendAdvanced unsafe.Pointer
	if len(colorBlendAdvanced) > 0 {
		sl_colorBlendAdvanced := make([]_vkColorBlendAdvancedEXT, attachmentCount)
		for i, v := range colorBlendAdvanced {
			sl_colorBlendAdvanced[i] = *(v.Vulkanize())
		}
		pColorBlendAdvanced = unsafe.Pointer(&sl_colorBlendAdvanced[0])
	}

	execTrampoline(vkCmdSetColorBlendAdvancedEXT, uintptr(commandBuffer), uintptr(firstAttachment), uintptr(attachmentCount), uintptr(unsafe.Pointer(pColorBlendAdvanced)))

}

var vkCmdSetColorBlendAdvancedEXT = &vkCommand{"vkCmdSetColorBlendAdvancedEXT", 4, true, nil}

// CmdSetColorBlendEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorBlendEnableEXT.html
func CmdSetColorBlendEnableEXT(commandBuffer CommandBuffer, firstAttachment uint32, colorBlendEnables []bool) {
	attachmentCount := len(colorBlendEnables)
	// colorBlendEnables is an input slice that requires translation to an internal type
	var pColorBlendEnables unsafe.Pointer
	if len(colorBlendEnables) > 0 {
		sl_colorBlendEnables := make([]Bool32, attachmentCount)
		for i, v := range colorBlendEnables {
			sl_colorBlendEnables[i] = translateInternal_Bool32(v)
		}
		pColorBlendEnables = unsafe.Pointer(&sl_colorBlendEnables[0])
	}

	execTrampoline(vkCmdSetColorBlendEnableEXT, uintptr(commandBuffer), uintptr(firstAttachment), uintptr(attachmentCount), uintptr(unsafe.Pointer(pColorBlendEnables)))

}

var vkCmdSetColorBlendEnableEXT = &vkCommand{"vkCmdSetColorBlendEnableEXT", 4, true, nil}

// CmdSetColorBlendEquationEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorBlendEquationEXT.html
func CmdSetColorBlendEquationEXT(commandBuffer CommandBuffer, firstAttachment uint32, colorBlendEquations []ColorBlendEquationEXT) {
	attachmentCount := len(colorBlendEquations)
	// colorBlendEquations is an input slice of values that do not need translation used
	var pColorBlendEquations unsafe.Pointer
	if colorBlendEquations != nil {
		pColorBlendEquations = unsafe.Pointer(&colorBlendEquations[0])
	}

	execTrampoline(vkCmdSetColorBlendEquationEXT, uintptr(commandBuffer), uintptr(firstAttachment), uintptr(attachmentCount), uintptr(unsafe.Pointer(pColorBlendEquations)))

}

var vkCmdSetColorBlendEquationEXT = &vkCommand{"vkCmdSetColorBlendEquationEXT", 4, true, nil}

// CmdSetColorWriteEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorWriteEnableEXT.html
func CmdSetColorWriteEnableEXT(commandBuffer CommandBuffer, colorWriteEnables []bool) {
	attachmentCount := len(colorWriteEnables)
	// colorWriteEnables is an input slice that requires translation to an internal type
	var pColorWriteEnables unsafe.Pointer
	if len(colorWriteEnables) > 0 {
		sl_colorWriteEnables := make([]Bool32, attachmentCount)
		for i, v := range colorWriteEnables {
			sl_colorWriteEnables[i] = translateInternal_Bool32(v)
		}
		pColorWriteEnables = unsafe.Pointer(&sl_colorWriteEnables[0])
	}

	execTrampoline(vkCmdSetColorWriteEnableEXT, uintptr(commandBuffer), uintptr(attachmentCount), uintptr(unsafe.Pointer(pColorWriteEnables)))

}

var vkCmdSetColorWriteEnableEXT = &vkCommand{"vkCmdSetColorWriteEnableEXT", 3, true, nil}

// CmdSetColorWriteMaskEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorWriteMaskEXT.html
func CmdSetColorWriteMaskEXT(commandBuffer CommandBuffer, firstAttachment uint32, colorWriteMasks []ColorComponentFlags) {
	attachmentCount := len(colorWriteMasks)
	// colorWriteMasks is an input slice of values that do not need translation used
	var pColorWriteMasks unsafe.Pointer
	if colorWriteMasks != nil {
		pColorWriteMasks = unsafe.Pointer(&colorWriteMasks[0])
	}

	execTrampoline(vkCmdSetColorWriteMaskEXT, uintptr(commandBuffer), uintptr(firstAttachment), uintptr(attachmentCount), uintptr(unsafe.Pointer(pColorWriteMasks)))

}

var vkCmdSetColorWriteMaskEXT = &vkCommand{"vkCmdSetColorWriteMaskEXT", 4, true, nil}

// CmdSetConservativeRasterizationModeEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetConservativeRasterizationModeEXT.html
func CmdSetConservativeRasterizationModeEXT(commandBuffer CommandBuffer, conservativeRasterizationMode ConservativeRasterizationModeEXT) {

	execTrampoline(vkCmdSetConservativeRasterizationModeEXT, uintptr(commandBuffer), uintptr(conservativeRasterizationMode))

}

var vkCmdSetConservativeRasterizationModeEXT = &vkCommand{"vkCmdSetConservativeRasterizationModeEXT", 2, true, nil}

// CmdSetCoverageModulationModeNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageModulationModeNV.html
func CmdSetCoverageModulationModeNV(commandBuffer CommandBuffer, coverageModulationMode CoverageModulationModeNV) {

	execTrampoline(vkCmdSetCoverageModulationModeNV, uintptr(commandBuffer), uintptr(coverageModulationMode))

}

var vkCmdSetCoverageModulationModeNV = &vkCommand{"vkCmdSetCoverageModulationModeNV", 2, true, nil}

// CmdSetCoverageModulationTableEnableNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageModulationTableEnableNV.html
func CmdSetCoverageModulationTableEnableNV(commandBuffer CommandBuffer, coverageModulationTableEnable bool) {
	coverageModulationTableEnable_Bool32 := translateInternal_Bool32(coverageModulationTableEnable)

	execTrampoline(vkCmdSetCoverageModulationTableEnableNV, uintptr(commandBuffer), uintptr(coverageModulationTableEnable_Bool32))

}

var vkCmdSetCoverageModulationTableEnableNV = &vkCommand{"vkCmdSetCoverageModulationTableEnableNV", 2, true, nil}

// CmdSetCoverageModulationTableNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageModulationTableNV.html
func CmdSetCoverageModulationTableNV(commandBuffer CommandBuffer, coverageModulationTable []float32) {
	coverageModulationTableCount := len(coverageModulationTable)
	// coverageModulationTable is an input slice of values that do not need translation used
	var pCoverageModulationTable unsafe.Pointer
	if coverageModulationTable != nil {
		pCoverageModulationTable = unsafe.Pointer(&coverageModulationTable[0])
	}

	execTrampoline(vkCmdSetCoverageModulationTableNV, uintptr(commandBuffer), uintptr(coverageModulationTableCount), uintptr(unsafe.Pointer(pCoverageModulationTable)))

}

var vkCmdSetCoverageModulationTableNV = &vkCommand{"vkCmdSetCoverageModulationTableNV", 3, true, nil}

// CmdSetCoverageReductionModeNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageReductionModeNV.html
func CmdSetCoverageReductionModeNV(commandBuffer CommandBuffer, coverageReductionMode CoverageReductionModeNV) {

	execTrampoline(vkCmdSetCoverageReductionModeNV, uintptr(commandBuffer), uintptr(coverageReductionMode))

}

var vkCmdSetCoverageReductionModeNV = &vkCommand{"vkCmdSetCoverageReductionModeNV", 2, true, nil}

// CmdSetCoverageToColorEnableNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageToColorEnableNV.html
func CmdSetCoverageToColorEnableNV(commandBuffer CommandBuffer, coverageToColorEnable bool) {
	coverageToColorEnable_Bool32 := translateInternal_Bool32(coverageToColorEnable)

	execTrampoline(vkCmdSetCoverageToColorEnableNV, uintptr(commandBuffer), uintptr(coverageToColorEnable_Bool32))

}

var vkCmdSetCoverageToColorEnableNV = &vkCommand{"vkCmdSetCoverageToColorEnableNV", 2, true, nil}

// CmdSetCoverageToColorLocationNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageToColorLocationNV.html
func CmdSetCoverageToColorLocationNV(commandBuffer CommandBuffer, coverageToColorLocation uint32) {

	execTrampoline(vkCmdSetCoverageToColorLocationNV, uintptr(commandBuffer), uintptr(coverageToColorLocation))

}

var vkCmdSetCoverageToColorLocationNV = &vkCommand{"vkCmdSetCoverageToColorLocationNV", 2, true, nil}

// CmdSetCullMode: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCullMode.html
func CmdSetCullMode(commandBuffer CommandBuffer, cullMode CullModeFlags) {

	execTrampoline(vkCmdSetCullMode, uintptr(commandBuffer), uintptr(cullMode))

}

var vkCmdSetCullMode = &vkCommand{"vkCmdSetCullMode", 2, true, nil}
var CmdSetCullModeEXT = CmdSetCullMode

// CmdSetDepthBias: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBias.html
func CmdSetDepthBias(commandBuffer CommandBuffer, depthBiasConstantFactor float32, depthBiasClamp float32, depthBiasSlopeFactor float32) {

	execTrampoline(vkCmdSetDepthBias, uintptr(commandBuffer), uintptr(depthBiasConstantFactor), uintptr(depthBiasClamp), uintptr(depthBiasSlopeFactor))

}

var vkCmdSetDepthBias = &vkCommand{"vkCmdSetDepthBias", 4, true, nil}

// CmdSetDepthBias2EXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBias2EXT.html
func CmdSetDepthBias2EXT(commandBuffer CommandBuffer, depthBiasInfo *DepthBiasInfoEXT) {
	// Parameter is a singular input, requires translation - depthBiasInfo
	var pDepthBiasInfo *_vkDepthBiasInfoEXT
	if depthBiasInfo != nil {
		pDepthBiasInfo = depthBiasInfo.Vulkanize()
	}

	execTrampoline(vkCmdSetDepthBias2EXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pDepthBiasInfo)))

}

var vkCmdSetDepthBias2EXT = &vkCommand{"vkCmdSetDepthBias2EXT", 2, true, nil}

// CmdSetDepthBiasEnable: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBiasEnable.html
func CmdSetDepthBiasEnable(commandBuffer CommandBuffer, depthBiasEnable bool) {
	depthBiasEnable_Bool32 := translateInternal_Bool32(depthBiasEnable)

	execTrampoline(vkCmdSetDepthBiasEnable, uintptr(commandBuffer), uintptr(depthBiasEnable_Bool32))

}

var vkCmdSetDepthBiasEnable = &vkCommand{"vkCmdSetDepthBiasEnable", 2, true, nil}
var CmdSetDepthBiasEnableEXT = CmdSetDepthBiasEnable

// CmdSetDepthBounds: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBounds.html
func CmdSetDepthBounds(commandBuffer CommandBuffer, minDepthBounds float32, maxDepthBounds float32) {

	execTrampoline(vkCmdSetDepthBounds, uintptr(commandBuffer), uintptr(minDepthBounds), uintptr(maxDepthBounds))

}

var vkCmdSetDepthBounds = &vkCommand{"vkCmdSetDepthBounds", 3, true, nil}

// CmdSetDepthBoundsTestEnable: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBoundsTestEnable.html
func CmdSetDepthBoundsTestEnable(commandBuffer CommandBuffer, depthBoundsTestEnable bool) {
	depthBoundsTestEnable_Bool32 := translateInternal_Bool32(depthBoundsTestEnable)

	execTrampoline(vkCmdSetDepthBoundsTestEnable, uintptr(commandBuffer), uintptr(depthBoundsTestEnable_Bool32))

}

var vkCmdSetDepthBoundsTestEnable = &vkCommand{"vkCmdSetDepthBoundsTestEnable", 2, true, nil}
var CmdSetDepthBoundsTestEnableEXT = CmdSetDepthBoundsTestEnable

// CmdSetDepthClampEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthClampEnableEXT.html
func CmdSetDepthClampEnableEXT(commandBuffer CommandBuffer, depthClampEnable bool) {
	depthClampEnable_Bool32 := translateInternal_Bool32(depthClampEnable)

	execTrampoline(vkCmdSetDepthClampEnableEXT, uintptr(commandBuffer), uintptr(depthClampEnable_Bool32))

}

var vkCmdSetDepthClampEnableEXT = &vkCommand{"vkCmdSetDepthClampEnableEXT", 2, true, nil}

// CmdSetDepthClipEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthClipEnableEXT.html
func CmdSetDepthClipEnableEXT(commandBuffer CommandBuffer, depthClipEnable bool) {
	depthClipEnable_Bool32 := translateInternal_Bool32(depthClipEnable)

	execTrampoline(vkCmdSetDepthClipEnableEXT, uintptr(commandBuffer), uintptr(depthClipEnable_Bool32))

}

var vkCmdSetDepthClipEnableEXT = &vkCommand{"vkCmdSetDepthClipEnableEXT", 2, true, nil}

// CmdSetDepthClipNegativeOneToOneEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthClipNegativeOneToOneEXT.html
func CmdSetDepthClipNegativeOneToOneEXT(commandBuffer CommandBuffer, negativeOneToOne bool) {
	negativeOneToOne_Bool32 := translateInternal_Bool32(negativeOneToOne)

	execTrampoline(vkCmdSetDepthClipNegativeOneToOneEXT, uintptr(commandBuffer), uintptr(negativeOneToOne_Bool32))

}

var vkCmdSetDepthClipNegativeOneToOneEXT = &vkCommand{"vkCmdSetDepthClipNegativeOneToOneEXT", 2, true, nil}

// CmdSetDepthCompareOp: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthCompareOp.html
func CmdSetDepthCompareOp(commandBuffer CommandBuffer, depthCompareOp CompareOp) {

	execTrampoline(vkCmdSetDepthCompareOp, uintptr(commandBuffer), uintptr(depthCompareOp))

}

var vkCmdSetDepthCompareOp = &vkCommand{"vkCmdSetDepthCompareOp", 2, true, nil}
var CmdSetDepthCompareOpEXT = CmdSetDepthCompareOp

// CmdSetDepthTestEnable: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthTestEnable.html
func CmdSetDepthTestEnable(commandBuffer CommandBuffer, depthTestEnable bool) {
	depthTestEnable_Bool32 := translateInternal_Bool32(depthTestEnable)

	execTrampoline(vkCmdSetDepthTestEnable, uintptr(commandBuffer), uintptr(depthTestEnable_Bool32))

}

var vkCmdSetDepthTestEnable = &vkCommand{"vkCmdSetDepthTestEnable", 2, true, nil}
var CmdSetDepthTestEnableEXT = CmdSetDepthTestEnable

// CmdSetDepthWriteEnable: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthWriteEnable.html
func CmdSetDepthWriteEnable(commandBuffer CommandBuffer, depthWriteEnable bool) {
	depthWriteEnable_Bool32 := translateInternal_Bool32(depthWriteEnable)

	execTrampoline(vkCmdSetDepthWriteEnable, uintptr(commandBuffer), uintptr(depthWriteEnable_Bool32))

}

var vkCmdSetDepthWriteEnable = &vkCommand{"vkCmdSetDepthWriteEnable", 2, true, nil}
var CmdSetDepthWriteEnableEXT = CmdSetDepthWriteEnable

// CmdSetDescriptorBufferOffsets2EXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDescriptorBufferOffsets2EXT.html
func CmdSetDescriptorBufferOffsets2EXT(commandBuffer CommandBuffer, setDescriptorBufferOffsetsInfo *SetDescriptorBufferOffsetsInfoEXT) {
	// Parameter is a singular input, requires translation - setDescriptorBufferOffsetsInfo
	var pSetDescriptorBufferOffsetsInfo *_vkSetDescriptorBufferOffsetsInfoEXT
	if setDescriptorBufferOffsetsInfo != nil {
		pSetDescriptorBufferOffsetsInfo = setDescriptorBufferOffsetsInfo.Vulkanize()
	}

	execTrampoline(vkCmdSetDescriptorBufferOffsets2EXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pSetDescriptorBufferOffsetsInfo)))

}

var vkCmdSetDescriptorBufferOffsets2EXT = &vkCommand{"vkCmdSetDescriptorBufferOffsets2EXT", 2, true, nil}

// CmdSetDescriptorBufferOffsetsEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDescriptorBufferOffsetsEXT.html
func CmdSetDescriptorBufferOffsetsEXT(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, layout PipelineLayout, firstSet uint32, bufferIndices []uint32, offsets []DeviceSize) {
	setCount := len(bufferIndices)
	// bufferIndices is an input slice of values that do not need translation used
	var pBufferIndices unsafe.Pointer
	if bufferIndices != nil {
		pBufferIndices = unsafe.Pointer(&bufferIndices[0])
	}

	// offsets is an input slice of values that do not need translation used
	var pOffsets unsafe.Pointer
	if offsets != nil {
		pOffsets = unsafe.Pointer(&offsets[0])
	}

	execTrampoline(vkCmdSetDescriptorBufferOffsetsEXT, uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(layout), uintptr(firstSet), uintptr(setCount), uintptr(unsafe.Pointer(pBufferIndices)), uintptr(unsafe.Pointer(pOffsets)))

}

var vkCmdSetDescriptorBufferOffsetsEXT = &vkCommand{"vkCmdSetDescriptorBufferOffsetsEXT", 7, true, nil}

// CmdSetDeviceMask: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDeviceMask.html
func CmdSetDeviceMask(commandBuffer CommandBuffer, deviceMask uint32) {

	execTrampoline(vkCmdSetDeviceMask, uintptr(commandBuffer), uintptr(deviceMask))

}

var vkCmdSetDeviceMask = &vkCommand{"vkCmdSetDeviceMask", 2, true, nil}
var CmdSetDeviceMaskKHR = CmdSetDeviceMask

// CmdSetDiscardRectangleEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDiscardRectangleEXT.html
func CmdSetDiscardRectangleEXT(commandBuffer CommandBuffer, firstDiscardRectangle uint32, discardRectangles []Rect2D) {
	discardRectangleCount := len(discardRectangles)
	// discardRectangles is an input slice that requires translation to an internal type
	var pDiscardRectangles unsafe.Pointer
	if len(discardRectangles) > 0 {
		sl_discardRectangles := make([]_vkRect2D, discardRectangleCount)
		for i, v := range discardRectangles {
			sl_discardRectangles[i] = *(v.Vulkanize())
		}
		pDiscardRectangles = unsafe.Pointer(&sl_discardRectangles[0])
	}

	execTrampoline(vkCmdSetDiscardRectangleEXT, uintptr(commandBuffer), uintptr(firstDiscardRectangle), uintptr(discardRectangleCount), uintptr(unsafe.Pointer(pDiscardRectangles)))

}

var vkCmdSetDiscardRectangleEXT = &vkCommand{"vkCmdSetDiscardRectangleEXT", 4, true, nil}

// CmdSetDiscardRectangleEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDiscardRectangleEnableEXT.html
func CmdSetDiscardRectangleEnableEXT(commandBuffer CommandBuffer, discardRectangleEnable bool) {
	discardRectangleEnable_Bool32 := translateInternal_Bool32(discardRectangleEnable)

	execTrampoline(vkCmdSetDiscardRectangleEnableEXT, uintptr(commandBuffer), uintptr(discardRectangleEnable_Bool32))

}

var vkCmdSetDiscardRectangleEnableEXT = &vkCommand{"vkCmdSetDiscardRectangleEnableEXT", 2, true, nil}

// CmdSetDiscardRectangleModeEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDiscardRectangleModeEXT.html
func CmdSetDiscardRectangleModeEXT(commandBuffer CommandBuffer, discardRectangleMode DiscardRectangleModeEXT) {

	execTrampoline(vkCmdSetDiscardRectangleModeEXT, uintptr(commandBuffer), uintptr(discardRectangleMode))

}

var vkCmdSetDiscardRectangleModeEXT = &vkCommand{"vkCmdSetDiscardRectangleModeEXT", 2, true, nil}

// CmdSetEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent.html
func CmdSetEvent(commandBuffer CommandBuffer, event Event, stageMask PipelineStageFlags) {

	execTrampoline(vkCmdSetEvent, uintptr(commandBuffer), uintptr(event), uintptr(stageMask))

}

var vkCmdSetEvent = &vkCommand{"vkCmdSetEvent", 3, true, nil}

// CmdSetEvent2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent2.html
func CmdSetEvent2(commandBuffer CommandBuffer, event Event, dependencyInfo *DependencyInfo) {
	// Parameter is a singular input, requires translation - dependencyInfo
	var pDependencyInfo *_vkDependencyInfo
	if dependencyInfo != nil {
		pDependencyInfo = dependencyInfo.Vulkanize()
	}

	execTrampoline(vkCmdSetEvent2, uintptr(commandBuffer), uintptr(event), uintptr(unsafe.Pointer(pDependencyInfo)))

}

var vkCmdSetEvent2 = &vkCommand{"vkCmdSetEvent2", 3, true, nil}
var CmdSetEvent2KHR = CmdSetEvent2

// CmdSetExclusiveScissorEnableNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetExclusiveScissorEnableNV.html
func CmdSetExclusiveScissorEnableNV(commandBuffer CommandBuffer, firstExclusiveScissor uint32, exclusiveScissorEnables []bool) {
	exclusiveScissorCount := len(exclusiveScissorEnables)
	// exclusiveScissorEnables is an input slice that requires translation to an internal type
	var pExclusiveScissorEnables unsafe.Pointer
	if len(exclusiveScissorEnables) > 0 {
		sl_exclusiveScissorEnables := make([]Bool32, exclusiveScissorCount)
		for i, v := range exclusiveScissorEnables {
			sl_exclusiveScissorEnables[i] = translateInternal_Bool32(v)
		}
		pExclusiveScissorEnables = unsafe.Pointer(&sl_exclusiveScissorEnables[0])
	}

	execTrampoline(vkCmdSetExclusiveScissorEnableNV, uintptr(commandBuffer), uintptr(firstExclusiveScissor), uintptr(exclusiveScissorCount), uintptr(unsafe.Pointer(pExclusiveScissorEnables)))

}

var vkCmdSetExclusiveScissorEnableNV = &vkCommand{"vkCmdSetExclusiveScissorEnableNV", 4, true, nil}

// CmdSetExclusiveScissorNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetExclusiveScissorNV.html
func CmdSetExclusiveScissorNV(commandBuffer CommandBuffer, firstExclusiveScissor uint32, exclusiveScissors []Rect2D) {
	exclusiveScissorCount := len(exclusiveScissors)
	// exclusiveScissors is an input slice that requires translation to an internal type
	var pExclusiveScissors unsafe.Pointer
	if len(exclusiveScissors) > 0 {
		sl_exclusiveScissors := make([]_vkRect2D, exclusiveScissorCount)
		for i, v := range exclusiveScissors {
			sl_exclusiveScissors[i] = *(v.Vulkanize())
		}
		pExclusiveScissors = unsafe.Pointer(&sl_exclusiveScissors[0])
	}

	execTrampoline(vkCmdSetExclusiveScissorNV, uintptr(commandBuffer), uintptr(firstExclusiveScissor), uintptr(exclusiveScissorCount), uintptr(unsafe.Pointer(pExclusiveScissors)))

}

var vkCmdSetExclusiveScissorNV = &vkCommand{"vkCmdSetExclusiveScissorNV", 4, true, nil}

// CmdSetExtraPrimitiveOverestimationSizeEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetExtraPrimitiveOverestimationSizeEXT.html
func CmdSetExtraPrimitiveOverestimationSizeEXT(commandBuffer CommandBuffer, extraPrimitiveOverestimationSize float32) {

	execTrampoline(vkCmdSetExtraPrimitiveOverestimationSizeEXT, uintptr(commandBuffer), uintptr(extraPrimitiveOverestimationSize))

}

var vkCmdSetExtraPrimitiveOverestimationSizeEXT = &vkCommand{"vkCmdSetExtraPrimitiveOverestimationSizeEXT", 2, true, nil}

// CmdSetFragmentShadingRateEnumNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFragmentShadingRateEnumNV.html
func CmdSetFragmentShadingRateEnumNV(commandBuffer CommandBuffer, shadingRate FragmentShadingRateNV, combinerOps FragmentShadingRateCombinerOpKHR) {

	execTrampoline(vkCmdSetFragmentShadingRateEnumNV, uintptr(commandBuffer), uintptr(shadingRate), uintptr(combinerOps))

}

var vkCmdSetFragmentShadingRateEnumNV = &vkCommand{"vkCmdSetFragmentShadingRateEnumNV", 3, true, nil}

// CmdSetFragmentShadingRateKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFragmentShadingRateKHR.html
func CmdSetFragmentShadingRateKHR(commandBuffer CommandBuffer, fragmentSize *Extent2D, combinerOps FragmentShadingRateCombinerOpKHR) {
	// Parameter is a singular input, pass direct - fragmentSize
	var pFragmentSize unsafe.Pointer
	if fragmentSize != nil {
		pFragmentSize = unsafe.Pointer(fragmentSize)
	}

	execTrampoline(vkCmdSetFragmentShadingRateKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pFragmentSize)), uintptr(combinerOps))

}

var vkCmdSetFragmentShadingRateKHR = &vkCommand{"vkCmdSetFragmentShadingRateKHR", 3, true, nil}

// CmdSetFrontFace: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFrontFace.html
func CmdSetFrontFace(commandBuffer CommandBuffer, frontFace FrontFace) {

	execTrampoline(vkCmdSetFrontFace, uintptr(commandBuffer), uintptr(frontFace))

}

var vkCmdSetFrontFace = &vkCommand{"vkCmdSetFrontFace", 2, true, nil}
var CmdSetFrontFaceEXT = CmdSetFrontFace

// CmdSetLineRasterizationModeEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineRasterizationModeEXT.html
func CmdSetLineRasterizationModeEXT(commandBuffer CommandBuffer, lineRasterizationMode LineRasterizationModeEXT) {

	execTrampoline(vkCmdSetLineRasterizationModeEXT, uintptr(commandBuffer), uintptr(lineRasterizationMode))

}

var vkCmdSetLineRasterizationModeEXT = &vkCommand{"vkCmdSetLineRasterizationModeEXT", 2, true, nil}

// CmdSetLineStippleEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineStippleEXT.html
func CmdSetLineStippleEXT(commandBuffer CommandBuffer, lineStippleFactor uint32, lineStipplePattern uint16) {

	execTrampoline(vkCmdSetLineStippleEXT, uintptr(commandBuffer), uintptr(lineStippleFactor), uintptr(lineStipplePattern))

}

var vkCmdSetLineStippleEXT = &vkCommand{"vkCmdSetLineStippleEXT", 3, true, nil}

// CmdSetLineStippleEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineStippleEnableEXT.html
func CmdSetLineStippleEnableEXT(commandBuffer CommandBuffer, stippledLineEnable bool) {
	stippledLineEnable_Bool32 := translateInternal_Bool32(stippledLineEnable)

	execTrampoline(vkCmdSetLineStippleEnableEXT, uintptr(commandBuffer), uintptr(stippledLineEnable_Bool32))

}

var vkCmdSetLineStippleEnableEXT = &vkCommand{"vkCmdSetLineStippleEnableEXT", 2, true, nil}

// CmdSetLineWidth: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineWidth.html
func CmdSetLineWidth(commandBuffer CommandBuffer, lineWidth float32) {

	execTrampoline(vkCmdSetLineWidth, uintptr(commandBuffer), uintptr(lineWidth))

}

var vkCmdSetLineWidth = &vkCommand{"vkCmdSetLineWidth", 2, true, nil}

// CmdSetLogicOpEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLogicOpEXT.html
func CmdSetLogicOpEXT(commandBuffer CommandBuffer, logicOp LogicOp) {

	execTrampoline(vkCmdSetLogicOpEXT, uintptr(commandBuffer), uintptr(logicOp))

}

var vkCmdSetLogicOpEXT = &vkCommand{"vkCmdSetLogicOpEXT", 2, true, nil}

// CmdSetLogicOpEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLogicOpEnableEXT.html
func CmdSetLogicOpEnableEXT(commandBuffer CommandBuffer, logicOpEnable bool) {
	logicOpEnable_Bool32 := translateInternal_Bool32(logicOpEnable)

	execTrampoline(vkCmdSetLogicOpEnableEXT, uintptr(commandBuffer), uintptr(logicOpEnable_Bool32))

}

var vkCmdSetLogicOpEnableEXT = &vkCommand{"vkCmdSetLogicOpEnableEXT", 2, true, nil}

// CmdSetPatchControlPointsEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPatchControlPointsEXT.html
func CmdSetPatchControlPointsEXT(commandBuffer CommandBuffer, patchControlPoints uint32) {

	execTrampoline(vkCmdSetPatchControlPointsEXT, uintptr(commandBuffer), uintptr(patchControlPoints))

}

var vkCmdSetPatchControlPointsEXT = &vkCommand{"vkCmdSetPatchControlPointsEXT", 2, true, nil}

// CmdSetPerformanceMarkerINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPerformanceMarkerINTEL.html
func CmdSetPerformanceMarkerINTEL(commandBuffer CommandBuffer, markerInfo *PerformanceMarkerInfoINTEL) (r error) {
	// Parameter is a singular input, requires translation - markerInfo
	var pMarkerInfo *_vkPerformanceMarkerInfoINTEL
	if markerInfo != nil {
		pMarkerInfo = markerInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkCmdSetPerformanceMarkerINTEL, uintptr(commandBuffer), uintptr(unsafe.Pointer(pMarkerInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCmdSetPerformanceMarkerINTEL = &vkCommand{"vkCmdSetPerformanceMarkerINTEL", 2, true, nil}

// CmdSetPerformanceOverrideINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPerformanceOverrideINTEL.html
func CmdSetPerformanceOverrideINTEL(commandBuffer CommandBuffer, overrideInfo *PerformanceOverrideInfoINTEL) (r error) {
	// Parameter is a singular input, requires translation - overrideInfo
	var pOverrideInfo *_vkPerformanceOverrideInfoINTEL
	if overrideInfo != nil {
		pOverrideInfo = overrideInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkCmdSetPerformanceOverrideINTEL, uintptr(commandBuffer), uintptr(unsafe.Pointer(pOverrideInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCmdSetPerformanceOverrideINTEL = &vkCommand{"vkCmdSetPerformanceOverrideINTEL", 2, true, nil}

// CmdSetPerformanceStreamMarkerINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPerformanceStreamMarkerINTEL.html
func CmdSetPerformanceStreamMarkerINTEL(commandBuffer CommandBuffer, markerInfo *PerformanceStreamMarkerInfoINTEL) (r error) {
	// Parameter is a singular input, requires translation - markerInfo
	var pMarkerInfo *_vkPerformanceStreamMarkerInfoINTEL
	if markerInfo != nil {
		pMarkerInfo = markerInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkCmdSetPerformanceStreamMarkerINTEL, uintptr(commandBuffer), uintptr(unsafe.Pointer(pMarkerInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCmdSetPerformanceStreamMarkerINTEL = &vkCommand{"vkCmdSetPerformanceStreamMarkerINTEL", 2, true, nil}

// CmdSetPolygonModeEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPolygonModeEXT.html
func CmdSetPolygonModeEXT(commandBuffer CommandBuffer, polygonMode PolygonMode) {

	execTrampoline(vkCmdSetPolygonModeEXT, uintptr(commandBuffer), uintptr(polygonMode))

}

var vkCmdSetPolygonModeEXT = &vkCommand{"vkCmdSetPolygonModeEXT", 2, true, nil}

// CmdSetPrimitiveRestartEnable: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveRestartEnable.html
func CmdSetPrimitiveRestartEnable(commandBuffer CommandBuffer, primitiveRestartEnable bool) {
	primitiveRestartEnable_Bool32 := translateInternal_Bool32(primitiveRestartEnable)

	execTrampoline(vkCmdSetPrimitiveRestartEnable, uintptr(commandBuffer), uintptr(primitiveRestartEnable_Bool32))

}

var vkCmdSetPrimitiveRestartEnable = &vkCommand{"vkCmdSetPrimitiveRestartEnable", 2, true, nil}
var CmdSetPrimitiveRestartEnableEXT = CmdSetPrimitiveRestartEnable

// CmdSetPrimitiveTopology: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveTopology.html
func CmdSetPrimitiveTopology(commandBuffer CommandBuffer, primitiveTopology PrimitiveTopology) {

	execTrampoline(vkCmdSetPrimitiveTopology, uintptr(commandBuffer), uintptr(primitiveTopology))

}

var vkCmdSetPrimitiveTopology = &vkCommand{"vkCmdSetPrimitiveTopology", 2, true, nil}
var CmdSetPrimitiveTopologyEXT = CmdSetPrimitiveTopology

// CmdSetProvokingVertexModeEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetProvokingVertexModeEXT.html
func CmdSetProvokingVertexModeEXT(commandBuffer CommandBuffer, provokingVertexMode ProvokingVertexModeEXT) {

	execTrampoline(vkCmdSetProvokingVertexModeEXT, uintptr(commandBuffer), uintptr(provokingVertexMode))

}

var vkCmdSetProvokingVertexModeEXT = &vkCommand{"vkCmdSetProvokingVertexModeEXT", 2, true, nil}

// CmdSetRasterizationSamplesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizationSamplesEXT.html
func CmdSetRasterizationSamplesEXT(commandBuffer CommandBuffer, rasterizationSamples SampleCountFlagBits) {

	execTrampoline(vkCmdSetRasterizationSamplesEXT, uintptr(commandBuffer), uintptr(rasterizationSamples))

}

var vkCmdSetRasterizationSamplesEXT = &vkCommand{"vkCmdSetRasterizationSamplesEXT", 2, true, nil}

// CmdSetRasterizationStreamEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizationStreamEXT.html
func CmdSetRasterizationStreamEXT(commandBuffer CommandBuffer, rasterizationStream uint32) {

	execTrampoline(vkCmdSetRasterizationStreamEXT, uintptr(commandBuffer), uintptr(rasterizationStream))

}

var vkCmdSetRasterizationStreamEXT = &vkCommand{"vkCmdSetRasterizationStreamEXT", 2, true, nil}

// CmdSetRasterizerDiscardEnable: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizerDiscardEnable.html
func CmdSetRasterizerDiscardEnable(commandBuffer CommandBuffer, rasterizerDiscardEnable bool) {
	rasterizerDiscardEnable_Bool32 := translateInternal_Bool32(rasterizerDiscardEnable)

	execTrampoline(vkCmdSetRasterizerDiscardEnable, uintptr(commandBuffer), uintptr(rasterizerDiscardEnable_Bool32))

}

var vkCmdSetRasterizerDiscardEnable = &vkCommand{"vkCmdSetRasterizerDiscardEnable", 2, true, nil}
var CmdSetRasterizerDiscardEnableEXT = CmdSetRasterizerDiscardEnable

// CmdSetRayTracingPipelineStackSizeKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRayTracingPipelineStackSizeKHR.html
func CmdSetRayTracingPipelineStackSizeKHR(commandBuffer CommandBuffer, pipelineStackSize uint32) {

	execTrampoline(vkCmdSetRayTracingPipelineStackSizeKHR, uintptr(commandBuffer), uintptr(pipelineStackSize))

}

var vkCmdSetRayTracingPipelineStackSizeKHR = &vkCommand{"vkCmdSetRayTracingPipelineStackSizeKHR", 2, true, nil}

// CmdSetRepresentativeFragmentTestEnableNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRepresentativeFragmentTestEnableNV.html
func CmdSetRepresentativeFragmentTestEnableNV(commandBuffer CommandBuffer, representativeFragmentTestEnable bool) {
	representativeFragmentTestEnable_Bool32 := translateInternal_Bool32(representativeFragmentTestEnable)

	execTrampoline(vkCmdSetRepresentativeFragmentTestEnableNV, uintptr(commandBuffer), uintptr(representativeFragmentTestEnable_Bool32))

}

var vkCmdSetRepresentativeFragmentTestEnableNV = &vkCommand{"vkCmdSetRepresentativeFragmentTestEnableNV", 2, true, nil}

// CmdSetSampleLocationsEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetSampleLocationsEXT.html
func CmdSetSampleLocationsEXT(commandBuffer CommandBuffer, sampleLocationsInfo *SampleLocationsInfoEXT) {
	// Parameter is a singular input, requires translation - sampleLocationsInfo
	var pSampleLocationsInfo *_vkSampleLocationsInfoEXT
	if sampleLocationsInfo != nil {
		pSampleLocationsInfo = sampleLocationsInfo.Vulkanize()
	}

	execTrampoline(vkCmdSetSampleLocationsEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pSampleLocationsInfo)))

}

var vkCmdSetSampleLocationsEXT = &vkCommand{"vkCmdSetSampleLocationsEXT", 2, true, nil}

// CmdSetSampleLocationsEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetSampleLocationsEnableEXT.html
func CmdSetSampleLocationsEnableEXT(commandBuffer CommandBuffer, sampleLocationsEnable bool) {
	sampleLocationsEnable_Bool32 := translateInternal_Bool32(sampleLocationsEnable)

	execTrampoline(vkCmdSetSampleLocationsEnableEXT, uintptr(commandBuffer), uintptr(sampleLocationsEnable_Bool32))

}

var vkCmdSetSampleLocationsEnableEXT = &vkCommand{"vkCmdSetSampleLocationsEnableEXT", 2, true, nil}

// CmdSetSampleMaskEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetSampleMaskEXT.html
func CmdSetSampleMaskEXT(commandBuffer CommandBuffer, samples SampleCountFlagBits, sampleMask []SampleMask) {
	// sampleMask is an edge case input slice, with an alternative length encoding. Developer must provide the length themselves.
	// No handling for internal vs. external types at this time, the only case this appears as of 1.3.240 is a handle type with a bitfield length encoding
	var pSampleMask *SampleMask
	if sampleMask != nil {
		pSampleMask = &sampleMask[0]
	}

	execTrampoline(vkCmdSetSampleMaskEXT, uintptr(commandBuffer), uintptr(samples), uintptr(unsafe.Pointer(pSampleMask)))

}

var vkCmdSetSampleMaskEXT = &vkCommand{"vkCmdSetSampleMaskEXT", 3, true, nil}

// CmdSetScissor: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissor.html
func CmdSetScissor(commandBuffer CommandBuffer, firstScissor uint32, scissors []Rect2D) {
	scissorCount := len(scissors)
	// scissors is an input slice that requires translation to an internal type
	var pScissors unsafe.Pointer
	if len(scissors) > 0 {
		sl_scissors := make([]_vkRect2D, scissorCount)
		for i, v := range scissors {
			sl_scissors[i] = *(v.Vulkanize())
		}
		pScissors = unsafe.Pointer(&sl_scissors[0])
	}

	execTrampoline(vkCmdSetScissor, uintptr(commandBuffer), uintptr(firstScissor), uintptr(scissorCount), uintptr(unsafe.Pointer(pScissors)))

}

var vkCmdSetScissor = &vkCommand{"vkCmdSetScissor", 4, true, nil}

// CmdSetScissorWithCount: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissorWithCount.html
func CmdSetScissorWithCount(commandBuffer CommandBuffer, scissors []Rect2D) {
	scissorCount := len(scissors)
	// scissors is an input slice that requires translation to an internal type
	var pScissors unsafe.Pointer
	if len(scissors) > 0 {
		sl_scissors := make([]_vkRect2D, scissorCount)
		for i, v := range scissors {
			sl_scissors[i] = *(v.Vulkanize())
		}
		pScissors = unsafe.Pointer(&sl_scissors[0])
	}

	execTrampoline(vkCmdSetScissorWithCount, uintptr(commandBuffer), uintptr(scissorCount), uintptr(unsafe.Pointer(pScissors)))

}

var vkCmdSetScissorWithCount = &vkCommand{"vkCmdSetScissorWithCount", 3, true, nil}
var CmdSetScissorWithCountEXT = CmdSetScissorWithCount

// CmdSetShadingRateImageEnableNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetShadingRateImageEnableNV.html
func CmdSetShadingRateImageEnableNV(commandBuffer CommandBuffer, shadingRateImageEnable bool) {
	shadingRateImageEnable_Bool32 := translateInternal_Bool32(shadingRateImageEnable)

	execTrampoline(vkCmdSetShadingRateImageEnableNV, uintptr(commandBuffer), uintptr(shadingRateImageEnable_Bool32))

}

var vkCmdSetShadingRateImageEnableNV = &vkCommand{"vkCmdSetShadingRateImageEnableNV", 2, true, nil}

// CmdSetStencilCompareMask: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilCompareMask.html
func CmdSetStencilCompareMask(commandBuffer CommandBuffer, faceMask StencilFaceFlags, compareMask uint32) {

	execTrampoline(vkCmdSetStencilCompareMask, uintptr(commandBuffer), uintptr(faceMask), uintptr(compareMask))

}

var vkCmdSetStencilCompareMask = &vkCommand{"vkCmdSetStencilCompareMask", 3, true, nil}

// CmdSetStencilOp: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilOp.html
func CmdSetStencilOp(commandBuffer CommandBuffer, faceMask StencilFaceFlags, failOp StencilOp, passOp StencilOp, depthFailOp StencilOp, compareOp CompareOp) {

	execTrampoline(vkCmdSetStencilOp, uintptr(commandBuffer), uintptr(faceMask), uintptr(failOp), uintptr(passOp), uintptr(depthFailOp), uintptr(compareOp))

}

var vkCmdSetStencilOp = &vkCommand{"vkCmdSetStencilOp", 6, true, nil}
var CmdSetStencilOpEXT = CmdSetStencilOp

// CmdSetStencilReference: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilReference.html
func CmdSetStencilReference(commandBuffer CommandBuffer, faceMask StencilFaceFlags, reference uint32) {

	execTrampoline(vkCmdSetStencilReference, uintptr(commandBuffer), uintptr(faceMask), uintptr(reference))

}

var vkCmdSetStencilReference = &vkCommand{"vkCmdSetStencilReference", 3, true, nil}

// CmdSetStencilTestEnable: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilTestEnable.html
func CmdSetStencilTestEnable(commandBuffer CommandBuffer, stencilTestEnable bool) {
	stencilTestEnable_Bool32 := translateInternal_Bool32(stencilTestEnable)

	execTrampoline(vkCmdSetStencilTestEnable, uintptr(commandBuffer), uintptr(stencilTestEnable_Bool32))

}

var vkCmdSetStencilTestEnable = &vkCommand{"vkCmdSetStencilTestEnable", 2, true, nil}
var CmdSetStencilTestEnableEXT = CmdSetStencilTestEnable

// CmdSetStencilWriteMask: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilWriteMask.html
func CmdSetStencilWriteMask(commandBuffer CommandBuffer, faceMask StencilFaceFlags, writeMask uint32) {

	execTrampoline(vkCmdSetStencilWriteMask, uintptr(commandBuffer), uintptr(faceMask), uintptr(writeMask))

}

var vkCmdSetStencilWriteMask = &vkCommand{"vkCmdSetStencilWriteMask", 3, true, nil}

// CmdSetTessellationDomainOriginEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetTessellationDomainOriginEXT.html
func CmdSetTessellationDomainOriginEXT(commandBuffer CommandBuffer, domainOrigin TessellationDomainOrigin) {

	execTrampoline(vkCmdSetTessellationDomainOriginEXT, uintptr(commandBuffer), uintptr(domainOrigin))

}

var vkCmdSetTessellationDomainOriginEXT = &vkCommand{"vkCmdSetTessellationDomainOriginEXT", 2, true, nil}

// CmdSetVertexInputEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetVertexInputEXT.html
func CmdSetVertexInputEXT(commandBuffer CommandBuffer, vertexBindingDescriptions []VertexInputBindingDescription2EXT, vertexAttributeDescriptions []VertexInputAttributeDescription2EXT) {
	vertexBindingDescriptionCount := len(vertexBindingDescriptions)
	// vertexBindingDescriptions is an input slice that requires translation to an internal type
	var pVertexBindingDescriptions unsafe.Pointer
	if len(vertexBindingDescriptions) > 0 {
		sl_vertexBindingDescriptions := make([]_vkVertexInputBindingDescription2EXT, vertexBindingDescriptionCount)
		for i, v := range vertexBindingDescriptions {
			sl_vertexBindingDescriptions[i] = *(v.Vulkanize())
		}
		pVertexBindingDescriptions = unsafe.Pointer(&sl_vertexBindingDescriptions[0])
	}

	vertexAttributeDescriptionCount := len(vertexAttributeDescriptions)
	// vertexAttributeDescriptions is an input slice that requires translation to an internal type
	var pVertexAttributeDescriptions unsafe.Pointer
	if len(vertexAttributeDescriptions) > 0 {
		sl_vertexAttributeDescriptions := make([]_vkVertexInputAttributeDescription2EXT, vertexAttributeDescriptionCount)
		for i, v := range vertexAttributeDescriptions {
			sl_vertexAttributeDescriptions[i] = *(v.Vulkanize())
		}
		pVertexAttributeDescriptions = unsafe.Pointer(&sl_vertexAttributeDescriptions[0])
	}

	execTrampoline(vkCmdSetVertexInputEXT, uintptr(commandBuffer), uintptr(vertexBindingDescriptionCount), uintptr(unsafe.Pointer(pVertexBindingDescriptions)), uintptr(vertexAttributeDescriptionCount), uintptr(unsafe.Pointer(pVertexAttributeDescriptions)))

}

var vkCmdSetVertexInputEXT = &vkCommand{"vkCmdSetVertexInputEXT", 5, true, nil}

// CmdSetViewport: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewport.html
func CmdSetViewport(commandBuffer CommandBuffer, firstViewport uint32, viewports []Viewport) {
	viewportCount := len(viewports)
	// viewports is an input slice of values that do not need translation used
	var pViewports unsafe.Pointer
	if viewports != nil {
		pViewports = unsafe.Pointer(&viewports[0])
	}

	execTrampoline(vkCmdSetViewport, uintptr(commandBuffer), uintptr(firstViewport), uintptr(viewportCount), uintptr(unsafe.Pointer(pViewports)))

}

var vkCmdSetViewport = &vkCommand{"vkCmdSetViewport", 4, true, nil}

// CmdSetViewportShadingRatePaletteNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportShadingRatePaletteNV.html
func CmdSetViewportShadingRatePaletteNV(commandBuffer CommandBuffer, firstViewport uint32, shadingRatePalettes []ShadingRatePaletteNV) {
	viewportCount := len(shadingRatePalettes)
	// shadingRatePalettes is an input slice that requires translation to an internal type
	var pShadingRatePalettes unsafe.Pointer
	if len(shadingRatePalettes) > 0 {
		sl_shadingRatePalettes := make([]_vkShadingRatePaletteNV, viewportCount)
		for i, v := range shadingRatePalettes {
			sl_shadingRatePalettes[i] = *(v.Vulkanize())
		}
		pShadingRatePalettes = unsafe.Pointer(&sl_shadingRatePalettes[0])
	}

	execTrampoline(vkCmdSetViewportShadingRatePaletteNV, uintptr(commandBuffer), uintptr(firstViewport), uintptr(viewportCount), uintptr(unsafe.Pointer(pShadingRatePalettes)))

}

var vkCmdSetViewportShadingRatePaletteNV = &vkCommand{"vkCmdSetViewportShadingRatePaletteNV", 4, true, nil}

// CmdSetViewportSwizzleNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportSwizzleNV.html
func CmdSetViewportSwizzleNV(commandBuffer CommandBuffer, firstViewport uint32, viewportSwizzles []ViewportSwizzleNV) {
	viewportCount := len(viewportSwizzles)
	// viewportSwizzles is an input slice of values that do not need translation used
	var pViewportSwizzles unsafe.Pointer
	if viewportSwizzles != nil {
		pViewportSwizzles = unsafe.Pointer(&viewportSwizzles[0])
	}

	execTrampoline(vkCmdSetViewportSwizzleNV, uintptr(commandBuffer), uintptr(firstViewport), uintptr(viewportCount), uintptr(unsafe.Pointer(pViewportSwizzles)))

}

var vkCmdSetViewportSwizzleNV = &vkCommand{"vkCmdSetViewportSwizzleNV", 4, true, nil}

// CmdSetViewportWScalingEnableNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWScalingEnableNV.html
func CmdSetViewportWScalingEnableNV(commandBuffer CommandBuffer, viewportWScalingEnable bool) {
	viewportWScalingEnable_Bool32 := translateInternal_Bool32(viewportWScalingEnable)

	execTrampoline(vkCmdSetViewportWScalingEnableNV, uintptr(commandBuffer), uintptr(viewportWScalingEnable_Bool32))

}

var vkCmdSetViewportWScalingEnableNV = &vkCommand{"vkCmdSetViewportWScalingEnableNV", 2, true, nil}

// CmdSetViewportWScalingNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWScalingNV.html
func CmdSetViewportWScalingNV(commandBuffer CommandBuffer, firstViewport uint32, viewportWScalings []ViewportWScalingNV) {
	viewportCount := len(viewportWScalings)
	// viewportWScalings is an input slice of values that do not need translation used
	var pViewportWScalings unsafe.Pointer
	if viewportWScalings != nil {
		pViewportWScalings = unsafe.Pointer(&viewportWScalings[0])
	}

	execTrampoline(vkCmdSetViewportWScalingNV, uintptr(commandBuffer), uintptr(firstViewport), uintptr(viewportCount), uintptr(unsafe.Pointer(pViewportWScalings)))

}

var vkCmdSetViewportWScalingNV = &vkCommand{"vkCmdSetViewportWScalingNV", 4, true, nil}

// CmdSetViewportWithCount: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWithCount.html
func CmdSetViewportWithCount(commandBuffer CommandBuffer, viewports []Viewport) {
	viewportCount := len(viewports)
	// viewports is an input slice of values that do not need translation used
	var pViewports unsafe.Pointer
	if viewports != nil {
		pViewports = unsafe.Pointer(&viewports[0])
	}

	execTrampoline(vkCmdSetViewportWithCount, uintptr(commandBuffer), uintptr(viewportCount), uintptr(unsafe.Pointer(pViewports)))

}

var vkCmdSetViewportWithCount = &vkCommand{"vkCmdSetViewportWithCount", 3, true, nil}
var CmdSetViewportWithCountEXT = CmdSetViewportWithCount

// CmdSubpassShadingHUAWEI: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSubpassShadingHUAWEI.html
func CmdSubpassShadingHUAWEI(commandBuffer CommandBuffer) {

	execTrampoline(vkCmdSubpassShadingHUAWEI, uintptr(commandBuffer))

}

var vkCmdSubpassShadingHUAWEI = &vkCommand{"vkCmdSubpassShadingHUAWEI", 1, true, nil}

// CmdTraceRaysIndirect2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysIndirect2KHR.html
func CmdTraceRaysIndirect2KHR(commandBuffer CommandBuffer, indirectDeviceAddress DeviceAddress) {

	execTrampoline(vkCmdTraceRaysIndirect2KHR, uintptr(commandBuffer), uintptr(indirectDeviceAddress))

}

var vkCmdTraceRaysIndirect2KHR = &vkCommand{"vkCmdTraceRaysIndirect2KHR", 2, true, nil}

// CmdTraceRaysIndirectKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysIndirectKHR.html
func CmdTraceRaysIndirectKHR(commandBuffer CommandBuffer, raygenShaderBindingTable *StridedDeviceAddressRegionKHR, missShaderBindingTable *StridedDeviceAddressRegionKHR, hitShaderBindingTable *StridedDeviceAddressRegionKHR, callableShaderBindingTable *StridedDeviceAddressRegionKHR, indirectDeviceAddress DeviceAddress) {
	// Parameter is a singular input, pass direct - raygenShaderBindingTable
	var pRaygenShaderBindingTable unsafe.Pointer
	if raygenShaderBindingTable != nil {
		pRaygenShaderBindingTable = unsafe.Pointer(raygenShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - missShaderBindingTable
	var pMissShaderBindingTable unsafe.Pointer
	if missShaderBindingTable != nil {
		pMissShaderBindingTable = unsafe.Pointer(missShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - hitShaderBindingTable
	var pHitShaderBindingTable unsafe.Pointer
	if hitShaderBindingTable != nil {
		pHitShaderBindingTable = unsafe.Pointer(hitShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - callableShaderBindingTable
	var pCallableShaderBindingTable unsafe.Pointer
	if callableShaderBindingTable != nil {
		pCallableShaderBindingTable = unsafe.Pointer(callableShaderBindingTable)
	}

	execTrampoline(vkCmdTraceRaysIndirectKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pRaygenShaderBindingTable)), uintptr(unsafe.Pointer(pMissShaderBindingTable)), uintptr(unsafe.Pointer(pHitShaderBindingTable)), uintptr(unsafe.Pointer(pCallableShaderBindingTable)), uintptr(indirectDeviceAddress))

}

var vkCmdTraceRaysIndirectKHR = &vkCommand{"vkCmdTraceRaysIndirectKHR", 6, true, nil}

// CmdTraceRaysKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysKHR.html
func CmdTraceRaysKHR(commandBuffer CommandBuffer, raygenShaderBindingTable *StridedDeviceAddressRegionKHR, missShaderBindingTable *StridedDeviceAddressRegionKHR, hitShaderBindingTable *StridedDeviceAddressRegionKHR, callableShaderBindingTable *StridedDeviceAddressRegionKHR, width uint32, height uint32, depth uint32) {
	// Parameter is a singular input, pass direct - raygenShaderBindingTable
	var pRaygenShaderBindingTable unsafe.Pointer
	if raygenShaderBindingTable != nil {
		pRaygenShaderBindingTable = unsafe.Pointer(raygenShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - missShaderBindingTable
	var pMissShaderBindingTable unsafe.Pointer
	if missShaderBindingTable != nil {
		pMissShaderBindingTable = unsafe.Pointer(missShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - hitShaderBindingTable
	var pHitShaderBindingTable unsafe.Pointer
	if hitShaderBindingTable != nil {
		pHitShaderBindingTable = unsafe.Pointer(hitShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - callableShaderBindingTable
	var pCallableShaderBindingTable unsafe.Pointer
	if callableShaderBindingTable != nil {
		pCallableShaderBindingTable = unsafe.Pointer(callableShaderBindingTable)
	}

	execTrampoline(vkCmdTraceRaysKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pRaygenShaderBindingTable)), uintptr(unsafe.Pointer(pMissShaderBindingTable)), uintptr(unsafe.Pointer(pHitShaderBindingTable)), uintptr(unsafe.Pointer(pCallableShaderBindingTable)), uintptr(width), uintptr(height), uintptr(depth))

}

var vkCmdTraceRaysKHR = &vkCommand{"vkCmdTraceRaysKHR", 8, true, nil}

// CmdTraceRaysNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysNV.html
func CmdTraceRaysNV(commandBuffer CommandBuffer, raygenShaderBindingTableBuffer Buffer, raygenShaderBindingOffset DeviceSize, missShaderBindingTableBuffer Buffer, missShaderBindingOffset DeviceSize, missShaderBindingStride DeviceSize, hitShaderBindingTableBuffer Buffer, hitShaderBindingOffset DeviceSize, hitShaderBindingStride DeviceSize, callableShaderBindingTableBuffer Buffer, callableShaderBindingOffset DeviceSize, callableShaderBindingStride DeviceSize, width uint32, height uint32, depth uint32) {

	execTrampoline(vkCmdTraceRaysNV, uintptr(commandBuffer), uintptr(raygenShaderBindingTableBuffer), uintptr(raygenShaderBindingOffset), uintptr(missShaderBindingTableBuffer), uintptr(missShaderBindingOffset), uintptr(missShaderBindingStride), uintptr(hitShaderBindingTableBuffer), uintptr(hitShaderBindingOffset), uintptr(hitShaderBindingStride), uintptr(callableShaderBindingTableBuffer), uintptr(callableShaderBindingOffset), uintptr(callableShaderBindingStride), uintptr(width), uintptr(height), uintptr(depth))

}

var vkCmdTraceRaysNV = &vkCommand{"vkCmdTraceRaysNV", 15, true, nil}

// CmdUpdateBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdUpdateBuffer.html
func CmdUpdateBuffer(commandBuffer CommandBuffer, dstBuffer Buffer, dstOffset DeviceSize, data []byte) {
	dataSize := len(data)
	// data is an input slice of values that do not need translation used
	var pData unsafe.Pointer
	if data != nil {
		pData = unsafe.Pointer(&data[0])
	}

	execTrampoline(vkCmdUpdateBuffer, uintptr(commandBuffer), uintptr(dstBuffer), uintptr(dstOffset), uintptr(dataSize), uintptr(unsafe.Pointer(pData)))

}

var vkCmdUpdateBuffer = &vkCommand{"vkCmdUpdateBuffer", 5, true, nil}

// CmdUpdatePipelineIndirectBufferNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdUpdatePipelineIndirectBufferNV.html
func CmdUpdatePipelineIndirectBufferNV(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, pipeline Pipeline) {

	execTrampoline(vkCmdUpdatePipelineIndirectBufferNV, uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(pipeline))

}

var vkCmdUpdatePipelineIndirectBufferNV = &vkCommand{"vkCmdUpdatePipelineIndirectBufferNV", 3, true, nil}

// CmdWaitEvents: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents.html
func CmdWaitEvents(commandBuffer CommandBuffer, events []Event, srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, memoryBarriers []MemoryBarrier, bufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarriers []ImageMemoryBarrier) {
	eventCount := len(events)
	// events is an input slice of values that do not need translation used
	var pEvents unsafe.Pointer
	if events != nil {
		pEvents = unsafe.Pointer(&events[0])
	}

	memoryBarrierCount := len(memoryBarriers)
	// memoryBarriers is an input slice that requires translation to an internal type
	var pMemoryBarriers unsafe.Pointer
	if len(memoryBarriers) > 0 {
		sl_memoryBarriers := make([]_vkMemoryBarrier, memoryBarrierCount)
		for i, v := range memoryBarriers {
			sl_memoryBarriers[i] = *(v.Vulkanize())
		}
		pMemoryBarriers = unsafe.Pointer(&sl_memoryBarriers[0])
	}

	bufferMemoryBarrierCount := len(bufferMemoryBarriers)
	// bufferMemoryBarriers is an input slice that requires translation to an internal type
	var pBufferMemoryBarriers unsafe.Pointer
	if len(bufferMemoryBarriers) > 0 {
		sl_bufferMemoryBarriers := make([]_vkBufferMemoryBarrier, bufferMemoryBarrierCount)
		for i, v := range bufferMemoryBarriers {
			sl_bufferMemoryBarriers[i] = *(v.Vulkanize())
		}
		pBufferMemoryBarriers = unsafe.Pointer(&sl_bufferMemoryBarriers[0])
	}

	imageMemoryBarrierCount := len(imageMemoryBarriers)
	// imageMemoryBarriers is an input slice that requires translation to an internal type
	var pImageMemoryBarriers unsafe.Pointer
	if len(imageMemoryBarriers) > 0 {
		sl_imageMemoryBarriers := make([]_vkImageMemoryBarrier, imageMemoryBarrierCount)
		for i, v := range imageMemoryBarriers {
			sl_imageMemoryBarriers[i] = *(v.Vulkanize())
		}
		pImageMemoryBarriers = unsafe.Pointer(&sl_imageMemoryBarriers[0])
	}

	execTrampoline(vkCmdWaitEvents, uintptr(commandBuffer), uintptr(eventCount), uintptr(unsafe.Pointer(pEvents)), uintptr(srcStageMask), uintptr(dstStageMask), uintptr(memoryBarrierCount), uintptr(unsafe.Pointer(pMemoryBarriers)), uintptr(bufferMemoryBarrierCount), uintptr(unsafe.Pointer(pBufferMemoryBarriers)), uintptr(imageMemoryBarrierCount), uintptr(unsafe.Pointer(pImageMemoryBarriers)))

}

var vkCmdWaitEvents = &vkCommand{"vkCmdWaitEvents", 11, true, nil}

// CmdWaitEvents2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents2.html
func CmdWaitEvents2(commandBuffer CommandBuffer, events []Event, dependencyInfos []DependencyInfo) {
	eventCount := len(events)
	// events is an input slice of values that do not need translation used
	var pEvents unsafe.Pointer
	if events != nil {
		pEvents = unsafe.Pointer(&events[0])
	}

	// dependencyInfos is an input slice that requires translation to an internal type
	var pDependencyInfos unsafe.Pointer
	if len(dependencyInfos) > 0 {
		sl_dependencyInfos := make([]_vkDependencyInfo, eventCount)
		for i, v := range dependencyInfos {
			sl_dependencyInfos[i] = *(v.Vulkanize())
		}
		pDependencyInfos = unsafe.Pointer(&sl_dependencyInfos[0])
	}

	execTrampoline(vkCmdWaitEvents2, uintptr(commandBuffer), uintptr(eventCount), uintptr(unsafe.Pointer(pEvents)), uintptr(unsafe.Pointer(pDependencyInfos)))

}

var vkCmdWaitEvents2 = &vkCommand{"vkCmdWaitEvents2", 4, true, nil}
var CmdWaitEvents2KHR = CmdWaitEvents2

// CmdWriteAccelerationStructuresPropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteAccelerationStructuresPropertiesKHR.html
func CmdWriteAccelerationStructuresPropertiesKHR(commandBuffer CommandBuffer, accelerationStructures []AccelerationStructureKHR, queryType QueryType, queryPool QueryPool, firstQuery uint32) {
	accelerationStructureCount := len(accelerationStructures)
	// accelerationStructures is an input slice of values that do not need translation used
	var pAccelerationStructures unsafe.Pointer
	if accelerationStructures != nil {
		pAccelerationStructures = unsafe.Pointer(&accelerationStructures[0])
	}

	execTrampoline(vkCmdWriteAccelerationStructuresPropertiesKHR, uintptr(commandBuffer), uintptr(accelerationStructureCount), uintptr(unsafe.Pointer(pAccelerationStructures)), uintptr(queryType), uintptr(queryPool), uintptr(firstQuery))

}

var vkCmdWriteAccelerationStructuresPropertiesKHR = &vkCommand{"vkCmdWriteAccelerationStructuresPropertiesKHR", 6, true, nil}

// CmdWriteAccelerationStructuresPropertiesNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteAccelerationStructuresPropertiesNV.html
func CmdWriteAccelerationStructuresPropertiesNV(commandBuffer CommandBuffer, accelerationStructures []AccelerationStructureNV, queryType QueryType, queryPool QueryPool, firstQuery uint32) {
	accelerationStructureCount := len(accelerationStructures)
	// accelerationStructures is an input slice of values that do not need translation used
	var pAccelerationStructures unsafe.Pointer
	if accelerationStructures != nil {
		pAccelerationStructures = unsafe.Pointer(&accelerationStructures[0])
	}

	execTrampoline(vkCmdWriteAccelerationStructuresPropertiesNV, uintptr(commandBuffer), uintptr(accelerationStructureCount), uintptr(unsafe.Pointer(pAccelerationStructures)), uintptr(queryType), uintptr(queryPool), uintptr(firstQuery))

}

var vkCmdWriteAccelerationStructuresPropertiesNV = &vkCommand{"vkCmdWriteAccelerationStructuresPropertiesNV", 6, true, nil}

// CmdWriteBufferMarker2AMD: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteBufferMarker2AMD.html
func CmdWriteBufferMarker2AMD(commandBuffer CommandBuffer, stage PipelineStageFlags2, dstBuffer Buffer, dstOffset DeviceSize, marker uint32) {

	execTrampoline(vkCmdWriteBufferMarker2AMD, uintptr(commandBuffer), uintptr(stage), uintptr(dstBuffer), uintptr(dstOffset), uintptr(marker))

}

var vkCmdWriteBufferMarker2AMD = &vkCommand{"vkCmdWriteBufferMarker2AMD", 5, true, nil}

// CmdWriteBufferMarkerAMD: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteBufferMarkerAMD.html
func CmdWriteBufferMarkerAMD(commandBuffer CommandBuffer, pipelineStage PipelineStageFlagBits, dstBuffer Buffer, dstOffset DeviceSize, marker uint32) {

	execTrampoline(vkCmdWriteBufferMarkerAMD, uintptr(commandBuffer), uintptr(pipelineStage), uintptr(dstBuffer), uintptr(dstOffset), uintptr(marker))

}

var vkCmdWriteBufferMarkerAMD = &vkCommand{"vkCmdWriteBufferMarkerAMD", 5, true, nil}

// CmdWriteMicromapsPropertiesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteMicromapsPropertiesEXT.html
func CmdWriteMicromapsPropertiesEXT(commandBuffer CommandBuffer, micromaps []MicromapEXT, queryType QueryType, queryPool QueryPool, firstQuery uint32) {
	micromapCount := len(micromaps)
	// micromaps is an input slice of values that do not need translation used
	var pMicromaps unsafe.Pointer
	if micromaps != nil {
		pMicromaps = unsafe.Pointer(&micromaps[0])
	}

	execTrampoline(vkCmdWriteMicromapsPropertiesEXT, uintptr(commandBuffer), uintptr(micromapCount), uintptr(unsafe.Pointer(pMicromaps)), uintptr(queryType), uintptr(queryPool), uintptr(firstQuery))

}

var vkCmdWriteMicromapsPropertiesEXT = &vkCommand{"vkCmdWriteMicromapsPropertiesEXT", 6, true, nil}

// CmdWriteTimestamp: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp.html
func CmdWriteTimestamp(commandBuffer CommandBuffer, pipelineStage PipelineStageFlagBits, queryPool QueryPool, query uint32) {

	execTrampoline(vkCmdWriteTimestamp, uintptr(commandBuffer), uintptr(pipelineStage), uintptr(queryPool), uintptr(query))

}

var vkCmdWriteTimestamp = &vkCommand{"vkCmdWriteTimestamp", 4, true, nil}

// CmdWriteTimestamp2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp2.html
func CmdWriteTimestamp2(commandBuffer CommandBuffer, stage PipelineStageFlags2, queryPool QueryPool, query uint32) {

	execTrampoline(vkCmdWriteTimestamp2, uintptr(commandBuffer), uintptr(stage), uintptr(queryPool), uintptr(query))

}

var vkCmdWriteTimestamp2 = &vkCommand{"vkCmdWriteTimestamp2", 4, true, nil}
var CmdWriteTimestamp2KHR = CmdWriteTimestamp2

// CompileDeferredNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCompileDeferredNV.html
func CompileDeferredNV(device Device, pipeline Pipeline, shader uint32) (r error) {

	r = Result(execTrampoline(vkCompileDeferredNV, uintptr(device), uintptr(pipeline), uintptr(shader)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCompileDeferredNV = &vkCommand{"vkCompileDeferredNV", 3, true, nil}

// CopyAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyAccelerationStructureKHR.html
func CopyAccelerationStructureKHR(device Device, deferredOperation DeferredOperationKHR, info *CopyAccelerationStructureInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyAccelerationStructureInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = Result(execTrampoline(vkCopyAccelerationStructureKHR, uintptr(device), uintptr(deferredOperation), uintptr(unsafe.Pointer(pInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCopyAccelerationStructureKHR = &vkCommand{"vkCopyAccelerationStructureKHR", 3, true, nil}

// CopyAccelerationStructureToMemoryKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyAccelerationStructureToMemoryKHR.html
func CopyAccelerationStructureToMemoryKHR(device Device, deferredOperation DeferredOperationKHR, info *CopyAccelerationStructureToMemoryInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyAccelerationStructureToMemoryInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = Result(execTrampoline(vkCopyAccelerationStructureToMemoryKHR, uintptr(device), uintptr(deferredOperation), uintptr(unsafe.Pointer(pInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCopyAccelerationStructureToMemoryKHR = &vkCommand{"vkCopyAccelerationStructureToMemoryKHR", 3, true, nil}

// CopyImageToImageEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyImageToImageEXT.html
func CopyImageToImageEXT(device Device, copyImageToImageInfo *CopyImageToImageInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - copyImageToImageInfo
	var pCopyImageToImageInfo *_vkCopyImageToImageInfoEXT
	if copyImageToImageInfo != nil {
		pCopyImageToImageInfo = copyImageToImageInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkCopyImageToImageEXT, uintptr(device), uintptr(unsafe.Pointer(pCopyImageToImageInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCopyImageToImageEXT = &vkCommand{"vkCopyImageToImageEXT", 2, true, nil}

// CopyImageToMemoryEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyImageToMemoryEXT.html
func CopyImageToMemoryEXT(device Device, copyImageToMemoryInfo *CopyImageToMemoryInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - copyImageToMemoryInfo
	var pCopyImageToMemoryInfo *_vkCopyImageToMemoryInfoEXT
	if copyImageToMemoryInfo != nil {
		pCopyImageToMemoryInfo = copyImageToMemoryInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkCopyImageToMemoryEXT, uintptr(device), uintptr(unsafe.Pointer(pCopyImageToMemoryInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCopyImageToMemoryEXT = &vkCommand{"vkCopyImageToMemoryEXT", 2, true, nil}

// CopyMemoryToAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyMemoryToAccelerationStructureKHR.html
func CopyMemoryToAccelerationStructureKHR(device Device, deferredOperation DeferredOperationKHR, info *CopyMemoryToAccelerationStructureInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMemoryToAccelerationStructureInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = Result(execTrampoline(vkCopyMemoryToAccelerationStructureKHR, uintptr(device), uintptr(deferredOperation), uintptr(unsafe.Pointer(pInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCopyMemoryToAccelerationStructureKHR = &vkCommand{"vkCopyMemoryToAccelerationStructureKHR", 3, true, nil}

// CopyMemoryToImageEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyMemoryToImageEXT.html
func CopyMemoryToImageEXT(device Device, copyMemoryToImageInfo *CopyMemoryToImageInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - copyMemoryToImageInfo
	var pCopyMemoryToImageInfo *_vkCopyMemoryToImageInfoEXT
	if copyMemoryToImageInfo != nil {
		pCopyMemoryToImageInfo = copyMemoryToImageInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkCopyMemoryToImageEXT, uintptr(device), uintptr(unsafe.Pointer(pCopyMemoryToImageInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCopyMemoryToImageEXT = &vkCommand{"vkCopyMemoryToImageEXT", 2, true, nil}

// CopyMemoryToMicromapEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyMemoryToMicromapEXT.html
func CopyMemoryToMicromapEXT(device Device, deferredOperation DeferredOperationKHR, info *CopyMemoryToMicromapInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMemoryToMicromapInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = Result(execTrampoline(vkCopyMemoryToMicromapEXT, uintptr(device), uintptr(deferredOperation), uintptr(unsafe.Pointer(pInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCopyMemoryToMicromapEXT = &vkCommand{"vkCopyMemoryToMicromapEXT", 3, true, nil}

// CopyMicromapEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyMicromapEXT.html
func CopyMicromapEXT(device Device, deferredOperation DeferredOperationKHR, info *CopyMicromapInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMicromapInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = Result(execTrampoline(vkCopyMicromapEXT, uintptr(device), uintptr(deferredOperation), uintptr(unsafe.Pointer(pInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCopyMicromapEXT = &vkCommand{"vkCopyMicromapEXT", 3, true, nil}

// CopyMicromapToMemoryEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyMicromapToMemoryEXT.html
func CopyMicromapToMemoryEXT(device Device, deferredOperation DeferredOperationKHR, info *CopyMicromapToMemoryInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMicromapToMemoryInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = Result(execTrampoline(vkCopyMicromapToMemoryEXT, uintptr(device), uintptr(deferredOperation), uintptr(unsafe.Pointer(pInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCopyMicromapToMemoryEXT = &vkCommand{"vkCopyMicromapToMemoryEXT", 3, true, nil}

// CreateAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateAccelerationStructureKHR.html
func CreateAccelerationStructureKHR(device Device, createInfo *AccelerationStructureCreateInfoKHR, allocator *AllocationCallbacks) (accelerationStructure AccelerationStructureKHR, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkAccelerationStructureCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// accelerationStructure is a binding-allocated single return value and will be populated by Vulkan
	ptr_pAccelerationStructure := &accelerationStructure

	r = Result(execTrampoline(vkCreateAccelerationStructureKHR, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pAccelerationStructure))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateAccelerationStructureKHR = &vkCommand{"vkCreateAccelerationStructureKHR", 4, true, nil}

// CreateAccelerationStructureNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateAccelerationStructureNV.html
func CreateAccelerationStructureNV(device Device, createInfo *AccelerationStructureCreateInfoNV, allocator *AllocationCallbacks) (accelerationStructure AccelerationStructureNV, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkAccelerationStructureCreateInfoNV
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// accelerationStructure is a binding-allocated single return value and will be populated by Vulkan
	ptr_pAccelerationStructure := &accelerationStructure

	r = Result(execTrampoline(vkCreateAccelerationStructureNV, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pAccelerationStructure))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateAccelerationStructureNV = &vkCommand{"vkCreateAccelerationStructureNV", 4, true, nil}

// CreateBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateBuffer.html
func CreateBuffer(device Device, createInfo *BufferCreateInfo, allocator *AllocationCallbacks) (buffer Buffer, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkBufferCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// Workaround 1.  a fmt.Printf("anything\n") here causes the problem to go away.

	// buffer is a binding-allocated single return value and will be populated by Vulkan
	ptr_pBuffer := &buffer

	if vkCreateBuffer.fnHandle == nil {
		// call once to handle any lazy initialization
		r = Result(execTrampoline(vkCreateBuffer, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)),
			uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pBuffer))))
	} else {
		// Workaround 2. Syscall
		// See: https://pkg.go.dev/unsafe#Pointer for possible reason.
		//
		// "The compiler handles a Pointer converted to a uintptr in the argument list of a call
		//  to a function implemented in assembly by arranging that the referenced allocated object,
		//  if any, is retained and not moved until the call completes, even though from the types
		//  alone it would appear that the object is no longer needed during the call.
		//  For the compiler to recognize this pattern, the conversion must appear in the argument list"
		result, _, _ := syscall.Syscall6(uintptr(vkCreateBuffer.fnHandle), 4,
			uintptr(device),
			uintptr(unsafe.Pointer(pCreateInfo)),
			uintptr(unsafe.Pointer(pAllocator)),
			uintptr(unsafe.Pointer(ptr_pBuffer)),
			0,
			0)
		r = Result(result)
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return buffer, r
}

var vkCreateBuffer = &vkCommand{"vkCreateBuffer", 4, true, nil}

// CreateBufferView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateBufferView.html
func CreateBufferView(device Device, createInfo *BufferViewCreateInfo, allocator *AllocationCallbacks) (view BufferView, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkBufferViewCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// view is a binding-allocated single return value and will be populated by Vulkan
	ptr_pView := &view

	r = Result(execTrampoline(vkCreateBufferView, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pView))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateBufferView = &vkCommand{"vkCreateBufferView", 4, true, nil}

// CreateCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCommandPool.html
func CreateCommandPool(device Device, createInfo *CommandPoolCreateInfo, allocator *AllocationCallbacks) (commandPool CommandPool, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkCommandPoolCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// commandPool is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCommandPool := &commandPool

	r = Result(execTrampoline(vkCreateCommandPool, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pCommandPool))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateCommandPool = &vkCommand{"vkCreateCommandPool", 4, true, nil}

// CreateComputePipelines: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateComputePipelines.html
func CreateComputePipelines(device Device, pipelineCache PipelineCache, createInfos []ComputePipelineCreateInfo, allocator *AllocationCallbacks) (pipelines []Pipeline, r error) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	var pCreateInfos unsafe.Pointer
	if len(createInfos) > 0 {
		sl_createInfos := make([]_vkComputePipelineCreateInfo, createInfoCount)
		for i, v := range createInfos {
			sl_createInfos[i] = *(v.Vulkanize())
		}
		pCreateInfos = unsafe.Pointer(&sl_createInfos[0])
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelines is an output array that will be allocated by the binding, len is from createInfoCount
	pipelines = make([]Pipeline, createInfoCount)
	pPipelines := unsafe.Pointer(&pipelines[0])

	r = Result(execTrampoline(vkCreateComputePipelines, uintptr(device), uintptr(pipelineCache), uintptr(createInfoCount), uintptr(unsafe.Pointer(pCreateInfos)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(pPipelines))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateComputePipelines = &vkCommand{"vkCreateComputePipelines", 6, true, nil}

// CreateCuFunctionNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCuFunctionNVX.html
func CreateCuFunctionNVX(device Device, createInfo *CuFunctionCreateInfoNVX, allocator *AllocationCallbacks) (function CuFunctionNVX, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkCuFunctionCreateInfoNVX
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// function is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFunction := &function

	r = Result(execTrampoline(vkCreateCuFunctionNVX, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pFunction))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateCuFunctionNVX = &vkCommand{"vkCreateCuFunctionNVX", 4, true, nil}

// CreateCuModuleNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCuModuleNVX.html
func CreateCuModuleNVX(device Device, createInfo *CuModuleCreateInfoNVX, allocator *AllocationCallbacks) (module CuModuleNVX, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkCuModuleCreateInfoNVX
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// module is a binding-allocated single return value and will be populated by Vulkan
	ptr_pModule := &module

	r = Result(execTrampoline(vkCreateCuModuleNVX, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pModule))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateCuModuleNVX = &vkCommand{"vkCreateCuModuleNVX", 4, true, nil}

// CreateCudaFunctionNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCudaFunctionNV.html
func CreateCudaFunctionNV(device Device, createInfo *CudaFunctionCreateInfoNV, allocator *AllocationCallbacks) (function CudaFunctionNV, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkCudaFunctionCreateInfoNV
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// function is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFunction := &function

	r = Result(execTrampoline(vkCreateCudaFunctionNV, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pFunction))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateCudaFunctionNV = &vkCommand{"vkCreateCudaFunctionNV", 4, true, nil}

// CreateCudaModuleNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCudaModuleNV.html
func CreateCudaModuleNV(device Device, createInfo *CudaModuleCreateInfoNV, allocator *AllocationCallbacks) (module CudaModuleNV, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkCudaModuleCreateInfoNV
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// module is a binding-allocated single return value and will be populated by Vulkan
	ptr_pModule := &module

	r = Result(execTrampoline(vkCreateCudaModuleNV, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pModule))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateCudaModuleNV = &vkCommand{"vkCreateCudaModuleNV", 4, true, nil}

// CreateDebugReportCallbackEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDebugReportCallbackEXT.html
func CreateDebugReportCallbackEXT(instance Instance, createInfo *DebugReportCallbackCreateInfoEXT, allocator *AllocationCallbacks) (callback DebugReportCallbackEXT, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDebugReportCallbackCreateInfoEXT
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// callback is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCallback := &callback

	r = Result(execTrampoline(vkCreateDebugReportCallbackEXT, uintptr(instance), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pCallback))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDebugReportCallbackEXT = &vkCommand{"vkCreateDebugReportCallbackEXT", 4, true, nil}

// CreateDebugUtilsMessengerEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html
func CreateDebugUtilsMessengerEXT(instance Instance, createInfo *DebugUtilsMessengerCreateInfoEXT, allocator *AllocationCallbacks) (messenger DebugUtilsMessengerEXT, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDebugUtilsMessengerCreateInfoEXT
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// messenger is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMessenger := &messenger

	r = Result(execTrampoline(vkCreateDebugUtilsMessengerEXT, uintptr(instance), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pMessenger))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDebugUtilsMessengerEXT = &vkCommand{"vkCreateDebugUtilsMessengerEXT", 4, true, nil}

// CreateDeferredOperationKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDeferredOperationKHR.html
func CreateDeferredOperationKHR(device Device, allocator *AllocationCallbacks) (deferredOperation DeferredOperationKHR, r error) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// deferredOperation is a binding-allocated single return value and will be populated by Vulkan
	ptr_pDeferredOperation := &deferredOperation

	r = Result(execTrampoline(vkCreateDeferredOperationKHR, uintptr(device), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pDeferredOperation))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDeferredOperationKHR = &vkCommand{"vkCreateDeferredOperationKHR", 3, true, nil}

// CreateDescriptorPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorPool.html
func CreateDescriptorPool(device Device, createInfo *DescriptorPoolCreateInfo, allocator *AllocationCallbacks) (descriptorPool DescriptorPool, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDescriptorPoolCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// descriptorPool is a binding-allocated single return value and will be populated by Vulkan
	ptr_pDescriptorPool := &descriptorPool

	r = Result(execTrampoline(vkCreateDescriptorPool, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pDescriptorPool))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDescriptorPool = &vkCommand{"vkCreateDescriptorPool", 4, true, nil}

// CreateDescriptorSetLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorSetLayout.html
func CreateDescriptorSetLayout(device Device, createInfo *DescriptorSetLayoutCreateInfo, allocator *AllocationCallbacks) (setLayout DescriptorSetLayout, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDescriptorSetLayoutCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// setLayout is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSetLayout := &setLayout

	r = Result(execTrampoline(vkCreateDescriptorSetLayout, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSetLayout))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDescriptorSetLayout = &vkCommand{"vkCreateDescriptorSetLayout", 4, true, nil}

// CreateDescriptorUpdateTemplate: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorUpdateTemplate.html
func CreateDescriptorUpdateTemplate(device Device, createInfo *DescriptorUpdateTemplateCreateInfo, allocator *AllocationCallbacks) (descriptorUpdateTemplate DescriptorUpdateTemplate, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDescriptorUpdateTemplateCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// descriptorUpdateTemplate is a binding-allocated single return value and will be populated by Vulkan
	ptr_pDescriptorUpdateTemplate := &descriptorUpdateTemplate

	r = Result(execTrampoline(vkCreateDescriptorUpdateTemplate, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pDescriptorUpdateTemplate))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDescriptorUpdateTemplate = &vkCommand{"vkCreateDescriptorUpdateTemplate", 4, true, nil}
var CreateDescriptorUpdateTemplateKHR = CreateDescriptorUpdateTemplate

// CreateDevice: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDevice.html
func CreateDevice(physicalDevice PhysicalDevice, createInfo *DeviceCreateInfo, allocator *AllocationCallbacks) (device Device, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDeviceCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// device is a binding-allocated single return value and will be populated by Vulkan
	ptr_pDevice := &device

	r = Result(execTrampoline(vkCreateDevice, uintptr(physicalDevice), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pDevice))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDevice = &vkCommand{"vkCreateDevice", 4, true, nil}

// CreateDisplayModeKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDisplayModeKHR.html
func CreateDisplayModeKHR(physicalDevice PhysicalDevice, display DisplayKHR, createInfo *DisplayModeCreateInfoKHR, allocator *AllocationCallbacks) (mode DisplayModeKHR, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDisplayModeCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// mode is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMode := &mode

	r = Result(execTrampoline(vkCreateDisplayModeKHR, uintptr(physicalDevice), uintptr(display), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pMode))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDisplayModeKHR = &vkCommand{"vkCreateDisplayModeKHR", 5, true, nil}

// CreateDisplayPlaneSurfaceKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDisplayPlaneSurfaceKHR.html
func CreateDisplayPlaneSurfaceKHR(instance Instance, createInfo *DisplaySurfaceCreateInfoKHR, allocator *AllocationCallbacks) (surface SurfaceKHR, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDisplaySurfaceCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// surface is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSurface := &surface

	r = Result(execTrampoline(vkCreateDisplayPlaneSurfaceKHR, uintptr(instance), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSurface))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateDisplayPlaneSurfaceKHR = &vkCommand{"vkCreateDisplayPlaneSurfaceKHR", 4, true, nil}

// CreateEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateEvent.html
func CreateEvent(device Device, createInfo *EventCreateInfo, allocator *AllocationCallbacks) (event Event, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkEventCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// event is a binding-allocated single return value and will be populated by Vulkan
	ptr_pEvent := &event

	r = Result(execTrampoline(vkCreateEvent, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pEvent))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateEvent = &vkCommand{"vkCreateEvent", 4, true, nil}

// CreateFence: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateFence.html
func CreateFence(device Device, createInfo *FenceCreateInfo, allocator *AllocationCallbacks) (fence Fence, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkFenceCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// fence is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFence := &fence

	r = Result(execTrampoline(vkCreateFence, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pFence))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateFence = &vkCommand{"vkCreateFence", 4, true, nil}

// CreateFramebuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateFramebuffer.html
func CreateFramebuffer(device Device, createInfo *FramebufferCreateInfo, allocator *AllocationCallbacks) (framebuffer Framebuffer, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkFramebufferCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// framebuffer is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFramebuffer := &framebuffer

	r = Result(execTrampoline(vkCreateFramebuffer, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pFramebuffer))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateFramebuffer = &vkCommand{"vkCreateFramebuffer", 4, true, nil}

// CreateGraphicsPipelines: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateGraphicsPipelines.html
func CreateGraphicsPipelines(device Device, pipelineCache PipelineCache, createInfos []GraphicsPipelineCreateInfo, allocator *AllocationCallbacks) (pipelines []Pipeline, r error) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	var pCreateInfos unsafe.Pointer
	if len(createInfos) > 0 {
		sl_createInfos := make([]_vkGraphicsPipelineCreateInfo, createInfoCount)
		for i, v := range createInfos {
			sl_createInfos[i] = *(v.Vulkanize())
		}
		pCreateInfos = unsafe.Pointer(&sl_createInfos[0])
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelines is an output array that will be allocated by the binding, len is from createInfoCount
	pipelines = make([]Pipeline, createInfoCount)
	pPipelines := unsafe.Pointer(&pipelines[0])

	r = Result(execTrampoline(vkCreateGraphicsPipelines, uintptr(device), uintptr(pipelineCache), uintptr(createInfoCount), uintptr(unsafe.Pointer(pCreateInfos)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(pPipelines))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateGraphicsPipelines = &vkCommand{"vkCreateGraphicsPipelines", 6, true, nil}

// CreateHeadlessSurfaceEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateHeadlessSurfaceEXT.html
func CreateHeadlessSurfaceEXT(instance Instance, createInfo *HeadlessSurfaceCreateInfoEXT, allocator *AllocationCallbacks) (surface SurfaceKHR, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkHeadlessSurfaceCreateInfoEXT
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// surface is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSurface := &surface

	r = Result(execTrampoline(vkCreateHeadlessSurfaceEXT, uintptr(instance), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSurface))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateHeadlessSurfaceEXT = &vkCommand{"vkCreateHeadlessSurfaceEXT", 4, true, nil}

// CreateImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateImage.html
func CreateImage(device Device, createInfo *ImageCreateInfo, allocator *AllocationCallbacks) (image Image, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkImageCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// image is a binding-allocated single return value and will be populated by Vulkan
	ptr_pImage := &image

	r = Result(execTrampoline(vkCreateImage, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pImage))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateImage = &vkCommand{"vkCreateImage", 4, true, nil}

// CreateImageView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateImageView.html
func CreateImageView(device Device, createInfo *ImageViewCreateInfo, allocator *AllocationCallbacks) (view ImageView, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkImageViewCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// view is a binding-allocated single return value and will be populated by Vulkan
	ptr_pView := &view

	r = Result(execTrampoline(vkCreateImageView, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pView))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateImageView = &vkCommand{"vkCreateImageView", 4, true, nil}

// CreateIndirectCommandsLayoutNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateIndirectCommandsLayoutNV.html
func CreateIndirectCommandsLayoutNV(device Device, createInfo *IndirectCommandsLayoutCreateInfoNV, allocator *AllocationCallbacks) (indirectCommandsLayout IndirectCommandsLayoutNV, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkIndirectCommandsLayoutCreateInfoNV
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// indirectCommandsLayout is a binding-allocated single return value and will be populated by Vulkan
	ptr_pIndirectCommandsLayout := &indirectCommandsLayout

	r = Result(execTrampoline(vkCreateIndirectCommandsLayoutNV, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pIndirectCommandsLayout))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateIndirectCommandsLayoutNV = &vkCommand{"vkCreateIndirectCommandsLayoutNV", 4, true, nil}

// CreateInstance: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html
func CreateInstance(createInfo *InstanceCreateInfo, allocator *AllocationCallbacks) (instance Instance, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkInstanceCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// instance is a binding-allocated single return value and will be populated by Vulkan
	ptr_pInstance := &instance

	r = Result(execTrampoline(vkCreateInstance, uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pInstance))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateInstance = &vkCommand{"vkCreateInstance", 3, true, nil}

// CreateMicromapEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateMicromapEXT.html
func CreateMicromapEXT(device Device, createInfo *MicromapCreateInfoEXT, allocator *AllocationCallbacks) (micromap MicromapEXT, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkMicromapCreateInfoEXT
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// micromap is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMicromap := &micromap

	r = Result(execTrampoline(vkCreateMicromapEXT, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pMicromap))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateMicromapEXT = &vkCommand{"vkCreateMicromapEXT", 4, true, nil}

// CreateOpticalFlowSessionNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateOpticalFlowSessionNV.html
func CreateOpticalFlowSessionNV(device Device, createInfo *OpticalFlowSessionCreateInfoNV, allocator *AllocationCallbacks) (session OpticalFlowSessionNV, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkOpticalFlowSessionCreateInfoNV
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// session is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSession := &session

	r = Result(execTrampoline(vkCreateOpticalFlowSessionNV, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSession))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateOpticalFlowSessionNV = &vkCommand{"vkCreateOpticalFlowSessionNV", 4, true, nil}

// CreatePipelineCache: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineCache.html
func CreatePipelineCache(device Device, createInfo *PipelineCacheCreateInfo, allocator *AllocationCallbacks) (pipelineCache PipelineCache, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkPipelineCacheCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelineCache is a binding-allocated single return value and will be populated by Vulkan
	ptr_pPipelineCache := &pipelineCache

	r = Result(execTrampoline(vkCreatePipelineCache, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pPipelineCache))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreatePipelineCache = &vkCommand{"vkCreatePipelineCache", 4, true, nil}

// CreatePipelineLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineLayout.html
func CreatePipelineLayout(device Device, createInfo *PipelineLayoutCreateInfo, allocator *AllocationCallbacks) (pipelineLayout PipelineLayout, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkPipelineLayoutCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelineLayout is a binding-allocated single return value and will be populated by Vulkan
	ptr_pPipelineLayout := &pipelineLayout

	r = Result(execTrampoline(vkCreatePipelineLayout, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pPipelineLayout))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreatePipelineLayout = &vkCommand{"vkCreatePipelineLayout", 4, true, nil}

// CreatePrivateDataSlot: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePrivateDataSlot.html
func CreatePrivateDataSlot(device Device, createInfo *PrivateDataSlotCreateInfo, allocator *AllocationCallbacks) (privateDataSlot PrivateDataSlot, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkPrivateDataSlotCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// privateDataSlot is a binding-allocated single return value and will be populated by Vulkan
	ptr_pPrivateDataSlot := &privateDataSlot

	r = Result(execTrampoline(vkCreatePrivateDataSlot, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pPrivateDataSlot))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreatePrivateDataSlot = &vkCommand{"vkCreatePrivateDataSlot", 4, true, nil}
var CreatePrivateDataSlotEXT = CreatePrivateDataSlot

// CreateQueryPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateQueryPool.html
func CreateQueryPool(device Device, createInfo *QueryPoolCreateInfo, allocator *AllocationCallbacks) (queryPool QueryPool, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkQueryPoolCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// queryPool is a binding-allocated single return value and will be populated by Vulkan
	ptr_pQueryPool := &queryPool

	r = Result(execTrampoline(vkCreateQueryPool, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pQueryPool))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateQueryPool = &vkCommand{"vkCreateQueryPool", 4, true, nil}

// CreateRayTracingPipelinesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRayTracingPipelinesKHR.html
func CreateRayTracingPipelinesKHR(device Device, deferredOperation DeferredOperationKHR, pipelineCache PipelineCache, createInfos []RayTracingPipelineCreateInfoKHR, allocator *AllocationCallbacks) (pipelines []Pipeline, r error) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	var pCreateInfos unsafe.Pointer
	if len(createInfos) > 0 {
		sl_createInfos := make([]_vkRayTracingPipelineCreateInfoKHR, createInfoCount)
		for i, v := range createInfos {
			sl_createInfos[i] = *(v.Vulkanize())
		}
		pCreateInfos = unsafe.Pointer(&sl_createInfos[0])
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelines is an output array that will be allocated by the binding, len is from createInfoCount
	pipelines = make([]Pipeline, createInfoCount)
	pPipelines := unsafe.Pointer(&pipelines[0])

	r = Result(execTrampoline(vkCreateRayTracingPipelinesKHR, uintptr(device), uintptr(deferredOperation), uintptr(pipelineCache), uintptr(createInfoCount), uintptr(unsafe.Pointer(pCreateInfos)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(pPipelines))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateRayTracingPipelinesKHR = &vkCommand{"vkCreateRayTracingPipelinesKHR", 7, true, nil}

// CreateRayTracingPipelinesNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRayTracingPipelinesNV.html
func CreateRayTracingPipelinesNV(device Device, pipelineCache PipelineCache, createInfos []RayTracingPipelineCreateInfoNV, allocator *AllocationCallbacks) (pipelines []Pipeline, r error) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	var pCreateInfos unsafe.Pointer
	if len(createInfos) > 0 {
		sl_createInfos := make([]_vkRayTracingPipelineCreateInfoNV, createInfoCount)
		for i, v := range createInfos {
			sl_createInfos[i] = *(v.Vulkanize())
		}
		pCreateInfos = unsafe.Pointer(&sl_createInfos[0])
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelines is an output array that will be allocated by the binding, len is from createInfoCount
	pipelines = make([]Pipeline, createInfoCount)
	pPipelines := unsafe.Pointer(&pipelines[0])

	r = Result(execTrampoline(vkCreateRayTracingPipelinesNV, uintptr(device), uintptr(pipelineCache), uintptr(createInfoCount), uintptr(unsafe.Pointer(pCreateInfos)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(pPipelines))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateRayTracingPipelinesNV = &vkCommand{"vkCreateRayTracingPipelinesNV", 6, true, nil}

// CreateRenderPass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRenderPass.html
func CreateRenderPass(device Device, createInfo *RenderPassCreateInfo, allocator *AllocationCallbacks) (renderPass RenderPass, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkRenderPassCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// renderPass is a binding-allocated single return value and will be populated by Vulkan
	ptr_pRenderPass := &renderPass

	r = Result(execTrampoline(vkCreateRenderPass, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pRenderPass))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateRenderPass = &vkCommand{"vkCreateRenderPass", 4, true, nil}

// CreateRenderPass2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRenderPass2.html
func CreateRenderPass2(device Device, createInfo *RenderPassCreateInfo2, allocator *AllocationCallbacks) (renderPass RenderPass, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkRenderPassCreateInfo2
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// renderPass is a binding-allocated single return value and will be populated by Vulkan
	ptr_pRenderPass := &renderPass

	r = Result(execTrampoline(vkCreateRenderPass2, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pRenderPass))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateRenderPass2 = &vkCommand{"vkCreateRenderPass2", 4, true, nil}
var CreateRenderPass2KHR = CreateRenderPass2

// CreateSampler: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSampler.html
func CreateSampler(device Device, createInfo *SamplerCreateInfo, allocator *AllocationCallbacks) (sampler Sampler, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkSamplerCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// sampler is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSampler := &sampler

	r = Result(execTrampoline(vkCreateSampler, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSampler))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateSampler = &vkCommand{"vkCreateSampler", 4, true, nil}

// CreateSamplerYcbcrConversion: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSamplerYcbcrConversion.html
func CreateSamplerYcbcrConversion(device Device, createInfo *SamplerYcbcrConversionCreateInfo, allocator *AllocationCallbacks) (ycbcrConversion SamplerYcbcrConversion, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkSamplerYcbcrConversionCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// ycbcrConversion is a binding-allocated single return value and will be populated by Vulkan
	ptr_pYcbcrConversion := &ycbcrConversion

	r = Result(execTrampoline(vkCreateSamplerYcbcrConversion, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pYcbcrConversion))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateSamplerYcbcrConversion = &vkCommand{"vkCreateSamplerYcbcrConversion", 4, true, nil}
var CreateSamplerYcbcrConversionKHR = CreateSamplerYcbcrConversion

// CreateSemaphore: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSemaphore.html
func CreateSemaphore(device Device, createInfo *SemaphoreCreateInfo, allocator *AllocationCallbacks) (semaphore Semaphore, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkSemaphoreCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// semaphore is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSemaphore := &semaphore

	r = Result(execTrampoline(vkCreateSemaphore, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSemaphore))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateSemaphore = &vkCommand{"vkCreateSemaphore", 4, true, nil}

// CreateShaderModule: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateShaderModule.html
func CreateShaderModule(device Device, createInfo *ShaderModuleCreateInfo, allocator *AllocationCallbacks) (shaderModule ShaderModule, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkShaderModuleCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// shaderModule is a binding-allocated single return value and will be populated by Vulkan
	ptr_pShaderModule := &shaderModule

	r = Result(execTrampoline(vkCreateShaderModule, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pShaderModule))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateShaderModule = &vkCommand{"vkCreateShaderModule", 4, true, nil}

// CreateShadersEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateShadersEXT.html
func CreateShadersEXT(device Device, createInfos []ShaderCreateInfoEXT, allocator *AllocationCallbacks) (shaders []ShaderEXT, r error) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	var pCreateInfos unsafe.Pointer
	if len(createInfos) > 0 {
		sl_createInfos := make([]_vkShaderCreateInfoEXT, createInfoCount)
		for i, v := range createInfos {
			sl_createInfos[i] = *(v.Vulkanize())
		}
		pCreateInfos = unsafe.Pointer(&sl_createInfos[0])
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// shaders is an output array that will be allocated by the binding, len is from createInfoCount
	shaders = make([]ShaderEXT, createInfoCount)
	pShaders := unsafe.Pointer(&shaders[0])

	r = Result(execTrampoline(vkCreateShadersEXT, uintptr(device), uintptr(createInfoCount), uintptr(unsafe.Pointer(pCreateInfos)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(pShaders))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateShadersEXT = &vkCommand{"vkCreateShadersEXT", 5, true, nil}

// CreateSharedSwapchainsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSharedSwapchainsKHR.html
func CreateSharedSwapchainsKHR(device Device, createInfos []SwapchainCreateInfoKHR, allocator *AllocationCallbacks) (swapchains []SwapchainKHR, r error) {
	swapchainCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	var pCreateInfos unsafe.Pointer
	if len(createInfos) > 0 {
		sl_createInfos := make([]_vkSwapchainCreateInfoKHR, swapchainCount)
		for i, v := range createInfos {
			sl_createInfos[i] = *(v.Vulkanize())
		}
		pCreateInfos = unsafe.Pointer(&sl_createInfos[0])
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// swapchains is an output array that will be allocated by the binding, len is from swapchainCount
	swapchains = make([]SwapchainKHR, swapchainCount)
	pSwapchains := unsafe.Pointer(&swapchains[0])

	r = Result(execTrampoline(vkCreateSharedSwapchainsKHR, uintptr(device), uintptr(swapchainCount), uintptr(unsafe.Pointer(pCreateInfos)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(pSwapchains))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateSharedSwapchainsKHR = &vkCommand{"vkCreateSharedSwapchainsKHR", 5, true, nil}

// CreateSwapchainKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSwapchainKHR.html
func CreateSwapchainKHR(device Device, createInfo *SwapchainCreateInfoKHR, allocator *AllocationCallbacks) (swapchain SwapchainKHR, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkSwapchainCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// swapchain is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSwapchain := &swapchain

	r = Result(execTrampoline(vkCreateSwapchainKHR, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSwapchain))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateSwapchainKHR = &vkCommand{"vkCreateSwapchainKHR", 4, true, nil}

// CreateValidationCacheEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateValidationCacheEXT.html
func CreateValidationCacheEXT(device Device, createInfo *ValidationCacheCreateInfoEXT, allocator *AllocationCallbacks) (validationCache ValidationCacheEXT, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkValidationCacheCreateInfoEXT
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// validationCache is a binding-allocated single return value and will be populated by Vulkan
	ptr_pValidationCache := &validationCache

	r = Result(execTrampoline(vkCreateValidationCacheEXT, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pValidationCache))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateValidationCacheEXT = &vkCommand{"vkCreateValidationCacheEXT", 4, true, nil}

// CreateVideoSessionKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateVideoSessionKHR.html
func CreateVideoSessionKHR(device Device, createInfo *VideoSessionCreateInfoKHR, allocator *AllocationCallbacks) (videoSession VideoSessionKHR, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkVideoSessionCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// videoSession is a binding-allocated single return value and will be populated by Vulkan
	ptr_pVideoSession := &videoSession

	r = Result(execTrampoline(vkCreateVideoSessionKHR, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pVideoSession))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateVideoSessionKHR = &vkCommand{"vkCreateVideoSessionKHR", 4, true, nil}

// CreateVideoSessionParametersKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateVideoSessionParametersKHR.html
func CreateVideoSessionParametersKHR(device Device, createInfo *VideoSessionParametersCreateInfoKHR, allocator *AllocationCallbacks) (videoSessionParameters VideoSessionParametersKHR, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkVideoSessionParametersCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// videoSessionParameters is a binding-allocated single return value and will be populated by Vulkan
	ptr_pVideoSessionParameters := &videoSessionParameters

	r = Result(execTrampoline(vkCreateVideoSessionParametersKHR, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pVideoSessionParameters))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateVideoSessionParametersKHR = &vkCommand{"vkCreateVideoSessionParametersKHR", 4, true, nil}

// DebugMarkerSetObjectNameEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDebugMarkerSetObjectNameEXT.html
func DebugMarkerSetObjectNameEXT(device Device, nameInfo *DebugMarkerObjectNameInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - nameInfo
	var pNameInfo *_vkDebugMarkerObjectNameInfoEXT
	if nameInfo != nil {
		pNameInfo = nameInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkDebugMarkerSetObjectNameEXT, uintptr(device), uintptr(unsafe.Pointer(pNameInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkDebugMarkerSetObjectNameEXT = &vkCommand{"vkDebugMarkerSetObjectNameEXT", 2, true, nil}

// DebugMarkerSetObjectTagEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDebugMarkerSetObjectTagEXT.html
func DebugMarkerSetObjectTagEXT(device Device, tagInfo *DebugMarkerObjectTagInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - tagInfo
	var pTagInfo *_vkDebugMarkerObjectTagInfoEXT
	if tagInfo != nil {
		pTagInfo = tagInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkDebugMarkerSetObjectTagEXT, uintptr(device), uintptr(unsafe.Pointer(pTagInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkDebugMarkerSetObjectTagEXT = &vkCommand{"vkDebugMarkerSetObjectTagEXT", 2, true, nil}

// DebugReportMessageEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDebugReportMessageEXT.html
func DebugReportMessageEXT(instance Instance, flags DebugReportFlagsEXT, objectType DebugReportObjectTypeEXT, object uint64, location uintptr, messageCode int32, layerPrefix string, message string) {
	// Parameter is a singular input, requires translation - layerPrefix
	var pLayerPrefix *byte
	if layerPrefix != "" {
		pLayerPrefix = sys_stringToBytePointer(layerPrefix)
	}

	// Parameter is a singular input, requires translation - message
	var pMessage *byte
	if message != "" {
		pMessage = sys_stringToBytePointer(message)
	}

	execTrampoline(vkDebugReportMessageEXT, uintptr(instance), uintptr(flags), uintptr(objectType), uintptr(object), uintptr(location), uintptr(messageCode), uintptr(unsafe.Pointer(pLayerPrefix)), uintptr(unsafe.Pointer(pMessage)))

}

var vkDebugReportMessageEXT = &vkCommand{"vkDebugReportMessageEXT", 8, true, nil}

// DeferredOperationJoinKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDeferredOperationJoinKHR.html
func DeferredOperationJoinKHR(device Device, operation DeferredOperationKHR) (r error) {

	r = Result(execTrampoline(vkDeferredOperationJoinKHR, uintptr(device), uintptr(operation)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkDeferredOperationJoinKHR = &vkCommand{"vkDeferredOperationJoinKHR", 2, true, nil}

// DestroyAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyAccelerationStructureKHR.html
func DestroyAccelerationStructureKHR(device Device, accelerationStructure AccelerationStructureKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyAccelerationStructureKHR, uintptr(device), uintptr(accelerationStructure), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyAccelerationStructureKHR = &vkCommand{"vkDestroyAccelerationStructureKHR", 3, true, nil}

// DestroyAccelerationStructureNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyAccelerationStructureNV.html
func DestroyAccelerationStructureNV(device Device, accelerationStructure AccelerationStructureNV, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyAccelerationStructureNV, uintptr(device), uintptr(accelerationStructure), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyAccelerationStructureNV = &vkCommand{"vkDestroyAccelerationStructureNV", 3, true, nil}

// DestroyBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyBuffer.html
func DestroyBuffer(device Device, buffer Buffer, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyBuffer, uintptr(device), uintptr(buffer), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyBuffer = &vkCommand{"vkDestroyBuffer", 3, true, nil}

// DestroyBufferView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyBufferView.html
func DestroyBufferView(device Device, bufferView BufferView, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyBufferView, uintptr(device), uintptr(bufferView), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyBufferView = &vkCommand{"vkDestroyBufferView", 3, true, nil}

// DestroyCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCommandPool.html
func DestroyCommandPool(device Device, commandPool CommandPool, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyCommandPool, uintptr(device), uintptr(commandPool), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyCommandPool = &vkCommand{"vkDestroyCommandPool", 3, true, nil}

// DestroyCuFunctionNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCuFunctionNVX.html
func DestroyCuFunctionNVX(device Device, function CuFunctionNVX, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyCuFunctionNVX, uintptr(device), uintptr(function), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyCuFunctionNVX = &vkCommand{"vkDestroyCuFunctionNVX", 3, true, nil}

// DestroyCuModuleNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCuModuleNVX.html
func DestroyCuModuleNVX(device Device, module CuModuleNVX, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyCuModuleNVX, uintptr(device), uintptr(module), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyCuModuleNVX = &vkCommand{"vkDestroyCuModuleNVX", 3, true, nil}

// DestroyCudaFunctionNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCudaFunctionNV.html
func DestroyCudaFunctionNV(device Device, function CudaFunctionNV, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyCudaFunctionNV, uintptr(device), uintptr(function), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyCudaFunctionNV = &vkCommand{"vkDestroyCudaFunctionNV", 3, true, nil}

// DestroyCudaModuleNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCudaModuleNV.html
func DestroyCudaModuleNV(device Device, module CudaModuleNV, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyCudaModuleNV, uintptr(device), uintptr(module), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyCudaModuleNV = &vkCommand{"vkDestroyCudaModuleNV", 3, true, nil}

// DestroyDebugReportCallbackEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDebugReportCallbackEXT.html
func DestroyDebugReportCallbackEXT(instance Instance, callback DebugReportCallbackEXT, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyDebugReportCallbackEXT, uintptr(instance), uintptr(callback), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyDebugReportCallbackEXT = &vkCommand{"vkDestroyDebugReportCallbackEXT", 3, true, nil}

// DestroyDebugUtilsMessengerEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDebugUtilsMessengerEXT.html
func DestroyDebugUtilsMessengerEXT(instance Instance, messenger DebugUtilsMessengerEXT, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyDebugUtilsMessengerEXT, uintptr(instance), uintptr(messenger), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyDebugUtilsMessengerEXT = &vkCommand{"vkDestroyDebugUtilsMessengerEXT", 3, true, nil}

// DestroyDeferredOperationKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDeferredOperationKHR.html
func DestroyDeferredOperationKHR(device Device, operation DeferredOperationKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyDeferredOperationKHR, uintptr(device), uintptr(operation), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyDeferredOperationKHR = &vkCommand{"vkDestroyDeferredOperationKHR", 3, true, nil}

// DestroyDescriptorPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorPool.html
func DestroyDescriptorPool(device Device, descriptorPool DescriptorPool, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyDescriptorPool, uintptr(device), uintptr(descriptorPool), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyDescriptorPool = &vkCommand{"vkDestroyDescriptorPool", 3, true, nil}

// DestroyDescriptorSetLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorSetLayout.html
func DestroyDescriptorSetLayout(device Device, descriptorSetLayout DescriptorSetLayout, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyDescriptorSetLayout, uintptr(device), uintptr(descriptorSetLayout), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyDescriptorSetLayout = &vkCommand{"vkDestroyDescriptorSetLayout", 3, true, nil}

// DestroyDescriptorUpdateTemplate: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorUpdateTemplate.html
func DestroyDescriptorUpdateTemplate(device Device, descriptorUpdateTemplate DescriptorUpdateTemplate, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyDescriptorUpdateTemplate, uintptr(device), uintptr(descriptorUpdateTemplate), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyDescriptorUpdateTemplate = &vkCommand{"vkDestroyDescriptorUpdateTemplate", 3, true, nil}
var DestroyDescriptorUpdateTemplateKHR = DestroyDescriptorUpdateTemplate

// DestroyDevice: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDevice.html
func DestroyDevice(device Device, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyDevice, uintptr(device), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyDevice = &vkCommand{"vkDestroyDevice", 2, true, nil}

// DestroyEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyEvent.html
func DestroyEvent(device Device, event Event, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyEvent, uintptr(device), uintptr(event), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyEvent = &vkCommand{"vkDestroyEvent", 3, true, nil}

// DestroyFence: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyFence.html
func DestroyFence(device Device, fence Fence, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyFence, uintptr(device), uintptr(fence), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyFence = &vkCommand{"vkDestroyFence", 3, true, nil}

// DestroyFramebuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyFramebuffer.html
func DestroyFramebuffer(device Device, framebuffer Framebuffer, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyFramebuffer, uintptr(device), uintptr(framebuffer), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyFramebuffer = &vkCommand{"vkDestroyFramebuffer", 3, true, nil}

// DestroyImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyImage.html
func DestroyImage(device Device, image Image, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyImage, uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyImage = &vkCommand{"vkDestroyImage", 3, true, nil}

// DestroyImageView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyImageView.html
func DestroyImageView(device Device, imageView ImageView, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyImageView, uintptr(device), uintptr(imageView), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyImageView = &vkCommand{"vkDestroyImageView", 3, true, nil}

// DestroyIndirectCommandsLayoutNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyIndirectCommandsLayoutNV.html
func DestroyIndirectCommandsLayoutNV(device Device, indirectCommandsLayout IndirectCommandsLayoutNV, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyIndirectCommandsLayoutNV, uintptr(device), uintptr(indirectCommandsLayout), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyIndirectCommandsLayoutNV = &vkCommand{"vkDestroyIndirectCommandsLayoutNV", 3, true, nil}

// DestroyInstance: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyInstance.html
func DestroyInstance(instance Instance, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyInstance, uintptr(instance), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyInstance = &vkCommand{"vkDestroyInstance", 2, true, nil}

// DestroyMicromapEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyMicromapEXT.html
func DestroyMicromapEXT(device Device, micromap MicromapEXT, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyMicromapEXT, uintptr(device), uintptr(micromap), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyMicromapEXT = &vkCommand{"vkDestroyMicromapEXT", 3, true, nil}

// DestroyOpticalFlowSessionNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyOpticalFlowSessionNV.html
func DestroyOpticalFlowSessionNV(device Device, session OpticalFlowSessionNV, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyOpticalFlowSessionNV, uintptr(device), uintptr(session), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyOpticalFlowSessionNV = &vkCommand{"vkDestroyOpticalFlowSessionNV", 3, true, nil}

// DestroyPipeline: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipeline.html
func DestroyPipeline(device Device, pipeline Pipeline, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyPipeline, uintptr(device), uintptr(pipeline), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyPipeline = &vkCommand{"vkDestroyPipeline", 3, true, nil}

// DestroyPipelineCache: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineCache.html
func DestroyPipelineCache(device Device, pipelineCache PipelineCache, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyPipelineCache, uintptr(device), uintptr(pipelineCache), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyPipelineCache = &vkCommand{"vkDestroyPipelineCache", 3, true, nil}

// DestroyPipelineLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineLayout.html
func DestroyPipelineLayout(device Device, pipelineLayout PipelineLayout, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyPipelineLayout, uintptr(device), uintptr(pipelineLayout), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyPipelineLayout = &vkCommand{"vkDestroyPipelineLayout", 3, true, nil}

// DestroyPrivateDataSlot: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPrivateDataSlot.html
func DestroyPrivateDataSlot(device Device, privateDataSlot PrivateDataSlot, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyPrivateDataSlot, uintptr(device), uintptr(privateDataSlot), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyPrivateDataSlot = &vkCommand{"vkDestroyPrivateDataSlot", 3, true, nil}
var DestroyPrivateDataSlotEXT = DestroyPrivateDataSlot

// DestroyQueryPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyQueryPool.html
func DestroyQueryPool(device Device, queryPool QueryPool, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyQueryPool, uintptr(device), uintptr(queryPool), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyQueryPool = &vkCommand{"vkDestroyQueryPool", 3, true, nil}

// DestroyRenderPass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyRenderPass.html
func DestroyRenderPass(device Device, renderPass RenderPass, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyRenderPass, uintptr(device), uintptr(renderPass), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyRenderPass = &vkCommand{"vkDestroyRenderPass", 3, true, nil}

// DestroySampler: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySampler.html
func DestroySampler(device Device, sampler Sampler, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroySampler, uintptr(device), uintptr(sampler), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroySampler = &vkCommand{"vkDestroySampler", 3, true, nil}

// DestroySamplerYcbcrConversion: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySamplerYcbcrConversion.html
func DestroySamplerYcbcrConversion(device Device, ycbcrConversion SamplerYcbcrConversion, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroySamplerYcbcrConversion, uintptr(device), uintptr(ycbcrConversion), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroySamplerYcbcrConversion = &vkCommand{"vkDestroySamplerYcbcrConversion", 3, true, nil}
var DestroySamplerYcbcrConversionKHR = DestroySamplerYcbcrConversion

// DestroySemaphore: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySemaphore.html
func DestroySemaphore(device Device, semaphore Semaphore, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroySemaphore, uintptr(device), uintptr(semaphore), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroySemaphore = &vkCommand{"vkDestroySemaphore", 3, true, nil}

// DestroyShaderEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyShaderEXT.html
func DestroyShaderEXT(device Device, shader ShaderEXT, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyShaderEXT, uintptr(device), uintptr(shader), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyShaderEXT = &vkCommand{"vkDestroyShaderEXT", 3, true, nil}

// DestroyShaderModule: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyShaderModule.html
func DestroyShaderModule(device Device, shaderModule ShaderModule, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyShaderModule, uintptr(device), uintptr(shaderModule), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyShaderModule = &vkCommand{"vkDestroyShaderModule", 3, true, nil}

// DestroySurfaceKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySurfaceKHR.html
func DestroySurfaceKHR(instance Instance, surface SurfaceKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroySurfaceKHR, uintptr(instance), uintptr(surface), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroySurfaceKHR = &vkCommand{"vkDestroySurfaceKHR", 3, true, nil}

// DestroySwapchainKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySwapchainKHR.html
func DestroySwapchainKHR(device Device, swapchain SwapchainKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroySwapchainKHR, uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroySwapchainKHR = &vkCommand{"vkDestroySwapchainKHR", 3, true, nil}

// DestroyValidationCacheEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyValidationCacheEXT.html
func DestroyValidationCacheEXT(device Device, validationCache ValidationCacheEXT, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyValidationCacheEXT, uintptr(device), uintptr(validationCache), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyValidationCacheEXT = &vkCommand{"vkDestroyValidationCacheEXT", 3, true, nil}

// DestroyVideoSessionKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyVideoSessionKHR.html
func DestroyVideoSessionKHR(device Device, videoSession VideoSessionKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyVideoSessionKHR, uintptr(device), uintptr(videoSession), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyVideoSessionKHR = &vkCommand{"vkDestroyVideoSessionKHR", 3, true, nil}

// DestroyVideoSessionParametersKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyVideoSessionParametersKHR.html
func DestroyVideoSessionParametersKHR(device Device, videoSessionParameters VideoSessionParametersKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkDestroyVideoSessionParametersKHR, uintptr(device), uintptr(videoSessionParameters), uintptr(unsafe.Pointer(pAllocator)))

}

var vkDestroyVideoSessionParametersKHR = &vkCommand{"vkDestroyVideoSessionParametersKHR", 3, true, nil}

// DeviceWaitIdle: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDeviceWaitIdle.html
func DeviceWaitIdle(device Device) (r error) {

	r = Result(execTrampoline(vkDeviceWaitIdle, uintptr(device)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkDeviceWaitIdle = &vkCommand{"vkDeviceWaitIdle", 1, true, nil}

// DisplayPowerControlEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDisplayPowerControlEXT.html
func DisplayPowerControlEXT(device Device, display DisplayKHR, displayPowerInfo *DisplayPowerInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - displayPowerInfo
	var pDisplayPowerInfo *_vkDisplayPowerInfoEXT
	if displayPowerInfo != nil {
		pDisplayPowerInfo = displayPowerInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkDisplayPowerControlEXT, uintptr(device), uintptr(display), uintptr(unsafe.Pointer(pDisplayPowerInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkDisplayPowerControlEXT = &vkCommand{"vkDisplayPowerControlEXT", 3, true, nil}

// EndCommandBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEndCommandBuffer.html
func EndCommandBuffer(commandBuffer CommandBuffer) (r error) {

	r = Result(execTrampoline(vkEndCommandBuffer, uintptr(commandBuffer)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEndCommandBuffer = &vkCommand{"vkEndCommandBuffer", 1, true, nil}

// EnumerateDeviceExtensionProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateDeviceExtensionProperties.html
func EnumerateDeviceExtensionProperties(physicalDevice PhysicalDevice, layerName string) (properties []ExtensionProperties, r error) {
	// Parameter is a singular input, requires translation - layerName
	var pLayerName *byte
	if layerName != "" {
		pLayerName = sys_stringToBytePointer(layerName)
	}

	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkExtensionProperties

	r = Result(execTrampoline(vkEnumerateDeviceExtensionProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pLayerName)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkExtensionProperties, propertyCount)
	properties = make([]ExtensionProperties, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkEnumerateDeviceExtensionProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pLayerName)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEnumerateDeviceExtensionProperties = &vkCommand{"vkEnumerateDeviceExtensionProperties", 4, true, nil}

// EnumerateDeviceLayerProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateDeviceLayerProperties.html
func EnumerateDeviceLayerProperties(physicalDevice PhysicalDevice) (properties []LayerProperties, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkLayerProperties

	r = Result(execTrampoline(vkEnumerateDeviceLayerProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkLayerProperties, propertyCount)
	properties = make([]LayerProperties, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkEnumerateDeviceLayerProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEnumerateDeviceLayerProperties = &vkCommand{"vkEnumerateDeviceLayerProperties", 3, true, nil}

// EnumerateInstanceExtensionProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html
func EnumerateInstanceExtensionProperties(layerName string) (properties []ExtensionProperties, r error) {
	// Parameter is a singular input, requires translation - layerName
	var pLayerName *byte
	if layerName != "" {
		pLayerName = sys_stringToBytePointer(layerName)
	}

	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkExtensionProperties

	r = Result(execTrampoline(vkEnumerateInstanceExtensionProperties, uintptr(unsafe.Pointer(pLayerName)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkExtensionProperties, propertyCount)
	properties = make([]ExtensionProperties, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkEnumerateInstanceExtensionProperties, uintptr(unsafe.Pointer(pLayerName)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEnumerateInstanceExtensionProperties = &vkCommand{"vkEnumerateInstanceExtensionProperties", 3, true, nil}

// EnumerateInstanceLayerProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceLayerProperties.html
func EnumerateInstanceLayerProperties() (properties []LayerProperties, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkLayerProperties

	r = Result(execTrampoline(vkEnumerateInstanceLayerProperties, uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkLayerProperties, propertyCount)
	properties = make([]LayerProperties, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkEnumerateInstanceLayerProperties, uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEnumerateInstanceLayerProperties = &vkCommand{"vkEnumerateInstanceLayerProperties", 2, true, nil}

// EnumerateInstanceVersion: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceVersion.html
func EnumerateInstanceVersion() (apiVersion uint32, r error) {
	// apiVersion is a binding-allocated single return value and will be populated by Vulkan
	ptr_pApiVersion := &apiVersion

	r = Result(execTrampoline(vkEnumerateInstanceVersion, uintptr(unsafe.Pointer(ptr_pApiVersion))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEnumerateInstanceVersion = &vkCommand{"vkEnumerateInstanceVersion", 1, true, nil}

// EnumeratePhysicalDeviceGroups: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDeviceGroups.html
func EnumeratePhysicalDeviceGroups(instance Instance) (physicalDeviceGroupProperties []PhysicalDeviceGroupProperties, r error) {
	// physicalDeviceGroupProperties is a double-call array output
	var physicalDeviceGroupCount uint32
	pPhysicalDeviceGroupCount := &physicalDeviceGroupCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pPhysicalDeviceGroupProperties *_vkPhysicalDeviceGroupProperties

	r = Result(execTrampoline(vkEnumeratePhysicalDeviceGroups, uintptr(instance), uintptr(unsafe.Pointer(pPhysicalDeviceGroupCount)), uintptr(unsafe.Pointer(pPhysicalDeviceGroupProperties))))

	sl_pPhysicalDeviceGroupProperties := make([]_vkPhysicalDeviceGroupProperties, physicalDeviceGroupCount)
	physicalDeviceGroupProperties = make([]PhysicalDeviceGroupProperties, physicalDeviceGroupCount)
	pPhysicalDeviceGroupProperties = &sl_pPhysicalDeviceGroupProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkEnumeratePhysicalDeviceGroups, uintptr(instance), uintptr(unsafe.Pointer(pPhysicalDeviceGroupCount)), uintptr(unsafe.Pointer(pPhysicalDeviceGroupProperties))))

	for i := range sl_pPhysicalDeviceGroupProperties {
		physicalDeviceGroupProperties[i] = *sl_pPhysicalDeviceGroupProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEnumeratePhysicalDeviceGroups = &vkCommand{"vkEnumeratePhysicalDeviceGroups", 3, true, nil}
var EnumeratePhysicalDeviceGroupsKHR = EnumeratePhysicalDeviceGroups

// EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.html
func EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice PhysicalDevice, queueFamilyIndex uint32) (counters []PerformanceCounterKHR, counterDescriptions []PerformanceCounterDescriptionKHR, r error) {
	// counters is a double-call array output
	var counterCount uint32
	pCounterCount := &counterCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pCounters *_vkPerformanceCounterKHR
	// NOT identical internal and external, result needs translation
	var pCounterDescriptions *_vkPerformanceCounterDescriptionKHR

	r = Result(execTrampoline(vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR, uintptr(physicalDevice), uintptr(queueFamilyIndex), uintptr(unsafe.Pointer(pCounterCount)), uintptr(unsafe.Pointer(pCounters)), uintptr(unsafe.Pointer(pCounterDescriptions))))

	sl_pCounters := make([]_vkPerformanceCounterKHR, counterCount)
	counters = make([]PerformanceCounterKHR, counterCount)
	pCounters = &sl_pCounters[0]

	sl_pCounterDescriptions := make([]_vkPerformanceCounterDescriptionKHR, counterCount)
	counterDescriptions = make([]PerformanceCounterDescriptionKHR, counterCount)
	pCounterDescriptions = &sl_pCounterDescriptions[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR, uintptr(physicalDevice), uintptr(queueFamilyIndex), uintptr(unsafe.Pointer(pCounterCount)), uintptr(unsafe.Pointer(pCounters)), uintptr(unsafe.Pointer(pCounterDescriptions))))

	for i := range sl_pCounters {
		counters[i] = *sl_pCounters[i].Goify()
	}
	for i := range sl_pCounterDescriptions {
		counterDescriptions[i] = *sl_pCounterDescriptions[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = &vkCommand{"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR", 5, true, nil}

// EnumeratePhysicalDevices: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDevices.html
func EnumeratePhysicalDevices(instance Instance) (physicalDevices []PhysicalDevice, r error) {
	// physicalDevices is a double-call array output
	var physicalDeviceCount uint32
	pPhysicalDeviceCount := &physicalDeviceCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pPhysicalDevices *PhysicalDevice

	r = Result(execTrampoline(vkEnumeratePhysicalDevices, uintptr(instance), uintptr(unsafe.Pointer(pPhysicalDeviceCount)), uintptr(unsafe.Pointer(pPhysicalDevices))))

	sl_pPhysicalDevices := make([]PhysicalDevice, physicalDeviceCount)
	physicalDevices = make([]PhysicalDevice, physicalDeviceCount)
	pPhysicalDevices = &sl_pPhysicalDevices[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkEnumeratePhysicalDevices, uintptr(instance), uintptr(unsafe.Pointer(pPhysicalDeviceCount)), uintptr(unsafe.Pointer(pPhysicalDevices))))

	for i := range sl_pPhysicalDevices {
		physicalDevices[i] = *&sl_pPhysicalDevices[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkEnumeratePhysicalDevices = &vkCommand{"vkEnumeratePhysicalDevices", 3, true, nil}

// FlushMappedMemoryRanges: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFlushMappedMemoryRanges.html
func FlushMappedMemoryRanges(device Device, memoryRanges []MappedMemoryRange) (r error) {
	memoryRangeCount := len(memoryRanges)
	// memoryRanges is an input slice that requires translation to an internal type
	var pMemoryRanges unsafe.Pointer
	if len(memoryRanges) > 0 {
		sl_memoryRanges := make([]_vkMappedMemoryRange, memoryRangeCount)
		for i, v := range memoryRanges {
			sl_memoryRanges[i] = *(v.Vulkanize())
		}
		pMemoryRanges = unsafe.Pointer(&sl_memoryRanges[0])
	}

	r = Result(execTrampoline(vkFlushMappedMemoryRanges, uintptr(device), uintptr(memoryRangeCount), uintptr(unsafe.Pointer(pMemoryRanges))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkFlushMappedMemoryRanges = &vkCommand{"vkFlushMappedMemoryRanges", 3, true, nil}

// FreeCommandBuffers: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeCommandBuffers.html
func FreeCommandBuffers(device Device, commandPool CommandPool, commandBuffers []CommandBuffer) {
	commandBufferCount := len(commandBuffers)
	// commandBuffers is an input slice of values that do not need translation used
	var pCommandBuffers unsafe.Pointer
	if commandBuffers != nil {
		pCommandBuffers = unsafe.Pointer(&commandBuffers[0])
	}

	execTrampoline(vkFreeCommandBuffers, uintptr(device), uintptr(commandPool), uintptr(commandBufferCount), uintptr(unsafe.Pointer(pCommandBuffers)))

}

var vkFreeCommandBuffers = &vkCommand{"vkFreeCommandBuffers", 4, true, nil}

// FreeDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeDescriptorSets.html
func FreeDescriptorSets(device Device, descriptorPool DescriptorPool, descriptorSets []DescriptorSet) (r error) {
	descriptorSetCount := len(descriptorSets)
	// descriptorSets is an input slice of values that do not need translation used
	var pDescriptorSets unsafe.Pointer
	if descriptorSets != nil {
		pDescriptorSets = unsafe.Pointer(&descriptorSets[0])
	}

	r = Result(execTrampoline(vkFreeDescriptorSets, uintptr(device), uintptr(descriptorPool), uintptr(descriptorSetCount), uintptr(unsafe.Pointer(pDescriptorSets))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkFreeDescriptorSets = &vkCommand{"vkFreeDescriptorSets", 4, true, nil}

// FreeMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeMemory.html
func FreeMemory(device Device, memory DeviceMemory, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(vkFreeMemory, uintptr(device), uintptr(memory), uintptr(unsafe.Pointer(pAllocator)))

}

var vkFreeMemory = &vkCommand{"vkFreeMemory", 3, true, nil}

// GetAccelerationStructureBuildSizesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureBuildSizesKHR.html
func GetAccelerationStructureBuildSizesKHR(device Device, buildType AccelerationStructureBuildTypeKHR, buildInfo *AccelerationStructureBuildGeometryInfoKHR, maxPrimitiveCounts []uint32) (sizeInfo AccelerationStructureBuildSizesInfoKHR) {
	// Parameter is a singular input, requires translation - buildInfo
	var pBuildInfo *_vkAccelerationStructureBuildGeometryInfoKHR
	if buildInfo != nil {
		pBuildInfo = buildInfo.Vulkanize()
	}

	// maxPrimitiveCounts is an input slice that requires translation to an internal type; length is embedded in pBuildInfo
	pMaxPrimitiveCounts := unsafe.Pointer(nil)
	// WARNING TODO - passing nil pointer to get to a version that will compile. THIS VULKAN CALL WILL FAIL!// sizeInfo is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSizeInfo *_vkAccelerationStructureBuildSizesInfoKHR = sizeInfo.Vulkanize()

	execTrampoline(vkGetAccelerationStructureBuildSizesKHR, uintptr(device), uintptr(buildType), uintptr(unsafe.Pointer(pBuildInfo)), uintptr(unsafe.Pointer(pMaxPrimitiveCounts)), uintptr(unsafe.Pointer(pSizeInfo)))

	sizeInfo = *(pSizeInfo.Goify())
	return
}

var vkGetAccelerationStructureBuildSizesKHR = &vkCommand{"vkGetAccelerationStructureBuildSizesKHR", 5, true, nil}

// GetAccelerationStructureDeviceAddressKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureDeviceAddressKHR.html
func GetAccelerationStructureDeviceAddressKHR(device Device, info *AccelerationStructureDeviceAddressInfoKHR) (deviceAddress DeviceAddress) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkAccelerationStructureDeviceAddressInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	deviceAddress = DeviceAddress(execTrampoline(vkGetAccelerationStructureDeviceAddressKHR, uintptr(device), uintptr(unsafe.Pointer(pInfo))))

	return
}

var vkGetAccelerationStructureDeviceAddressKHR = &vkCommand{"vkGetAccelerationStructureDeviceAddressKHR", 2, true, nil}

// GetAccelerationStructureHandleNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureHandleNV.html
func GetAccelerationStructureHandleNV(device Device, accelerationStructure AccelerationStructureNV, data []byte) (r error) {
	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	r = Result(execTrampoline(vkGetAccelerationStructureHandleNV, uintptr(device), uintptr(accelerationStructure), uintptr(dataSize), uintptr(unsafe.Pointer(pData))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetAccelerationStructureHandleNV = &vkCommand{"vkGetAccelerationStructureHandleNV", 4, true, nil}

// GetAccelerationStructureMemoryRequirementsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureMemoryRequirementsNV.html
func GetAccelerationStructureMemoryRequirementsNV(device Device, info *AccelerationStructureMemoryRequirementsInfoNV) (memoryRequirements MemoryRequirements2KHR) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkAccelerationStructureMemoryRequirementsInfoNV
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMemoryRequirements := &memoryRequirements

	execTrampoline(vkGetAccelerationStructureMemoryRequirementsNV, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(ptr_pMemoryRequirements)))

	return
}

var vkGetAccelerationStructureMemoryRequirementsNV = &vkCommand{"vkGetAccelerationStructureMemoryRequirementsNV", 3, true, nil}

// GetAccelerationStructureOpaqueCaptureDescriptorDataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT.html
func GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(device Device, info *AccelerationStructureCaptureDescriptorDataInfoEXT) (data byte, r error) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkAccelerationStructureCaptureDescriptorDataInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// data is a binding-allocated single return value and will be populated by Vulkan
	ptr_pData := &data

	r = Result(execTrampoline(vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(ptr_pData))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = &vkCommand{"vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT", 3, true, nil}

// GetBufferDeviceAddress: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferDeviceAddress.html
func GetBufferDeviceAddress(device Device, info *BufferDeviceAddressInfo) (deviceAddress DeviceAddress) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkBufferDeviceAddressInfo
	if info != nil {
		pInfo = info.Vulkanize()
	}

	deviceAddress = DeviceAddress(execTrampoline(vkGetBufferDeviceAddress, uintptr(device), uintptr(unsafe.Pointer(pInfo))))

	return
}

var vkGetBufferDeviceAddress = &vkCommand{"vkGetBufferDeviceAddress", 2, true, nil}
var GetBufferDeviceAddressEXT = GetBufferDeviceAddress

var GetBufferDeviceAddressKHR = GetBufferDeviceAddress

// GetBufferMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements.html
func GetBufferMemoryRequirements(device Device, buffer Buffer) (memoryRequirements MemoryRequirements) {
	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMemoryRequirements := &memoryRequirements

	execTrampoline(vkGetBufferMemoryRequirements, uintptr(device), uintptr(buffer), uintptr(unsafe.Pointer(ptr_pMemoryRequirements)))

	return
}

var vkGetBufferMemoryRequirements = &vkCommand{"vkGetBufferMemoryRequirements", 3, true, nil}

// GetBufferMemoryRequirements2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements2.html
func GetBufferMemoryRequirements2(device Device, info *BufferMemoryRequirementsInfo2) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkBufferMemoryRequirementsInfo2
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryRequirements *_vkMemoryRequirements2 = memoryRequirements.Vulkanize()

	execTrampoline(vkGetBufferMemoryRequirements2, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pMemoryRequirements)))

	memoryRequirements = *(pMemoryRequirements.Goify())
	return
}

var vkGetBufferMemoryRequirements2 = &vkCommand{"vkGetBufferMemoryRequirements2", 3, true, nil}
var GetBufferMemoryRequirements2KHR = GetBufferMemoryRequirements2

// GetBufferOpaqueCaptureAddress: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferOpaqueCaptureAddress.html
func GetBufferOpaqueCaptureAddress(device Device, info *BufferDeviceAddressInfo) (r uint64) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkBufferDeviceAddressInfo
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = uint64(execTrampoline(vkGetBufferOpaqueCaptureAddress, uintptr(device), uintptr(unsafe.Pointer(pInfo))))

	return
}

var vkGetBufferOpaqueCaptureAddress = &vkCommand{"vkGetBufferOpaqueCaptureAddress", 2, true, nil}
var GetBufferOpaqueCaptureAddressKHR = GetBufferOpaqueCaptureAddress

// GetBufferOpaqueCaptureDescriptorDataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferOpaqueCaptureDescriptorDataEXT.html
func GetBufferOpaqueCaptureDescriptorDataEXT(device Device, info *BufferCaptureDescriptorDataInfoEXT) (data byte, r error) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkBufferCaptureDescriptorDataInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// data is a binding-allocated single return value and will be populated by Vulkan
	ptr_pData := &data

	r = Result(execTrampoline(vkGetBufferOpaqueCaptureDescriptorDataEXT, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(ptr_pData))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetBufferOpaqueCaptureDescriptorDataEXT = &vkCommand{"vkGetBufferOpaqueCaptureDescriptorDataEXT", 3, true, nil}
var GetCalibratedTimestampsEXT = GetCalibratedTimestampsKHR

// GetCalibratedTimestampsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetCalibratedTimestampsKHR.html
func GetCalibratedTimestampsKHR(device Device, timestampInfos []CalibratedTimestampInfoKHR) (timestamps []uint64, maxDeviation uint64, r error) {
	timestampCount := len(timestampInfos)
	// timestampInfos is an input slice that requires translation to an internal type
	var pTimestampInfos unsafe.Pointer
	if len(timestampInfos) > 0 {
		sl_timestampInfos := make([]_vkCalibratedTimestampInfoKHR, timestampCount)
		for i, v := range timestampInfos {
			sl_timestampInfos[i] = *(v.Vulkanize())
		}
		pTimestampInfos = unsafe.Pointer(&sl_timestampInfos[0])
	}

	// timestamps is an output array that will be allocated by the binding, len is from timestampCount
	timestamps = make([]uint64, timestampCount)
	pTimestamps := unsafe.Pointer(&timestamps[0])

	// maxDeviation is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMaxDeviation := &maxDeviation

	r = Result(execTrampoline(vkGetCalibratedTimestampsKHR, uintptr(device), uintptr(timestampCount), uintptr(unsafe.Pointer(pTimestampInfos)), uintptr(unsafe.Pointer(pTimestamps)), uintptr(unsafe.Pointer(ptr_pMaxDeviation))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetCalibratedTimestampsKHR = &vkCommand{"vkGetCalibratedTimestampsKHR", 5, true, nil}

// GetCudaModuleCacheNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetCudaModuleCacheNV.html
func GetCudaModuleCacheNV(device Device, module CudaModuleNV) (cacheData []byte, r error) {
	// cacheData is a double-call array output
	var cacheSize uintptr
	pCacheSize := &cacheSize
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pCacheData *byte

	r = Result(execTrampoline(vkGetCudaModuleCacheNV, uintptr(device), uintptr(module), uintptr(unsafe.Pointer(pCacheSize)), uintptr(unsafe.Pointer(pCacheData))))

	sl_pCacheData := make([]byte, cacheSize)
	cacheData = make([]byte, cacheSize)
	pCacheData = &sl_pCacheData[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetCudaModuleCacheNV, uintptr(device), uintptr(module), uintptr(unsafe.Pointer(pCacheSize)), uintptr(unsafe.Pointer(pCacheData))))

	for i := range sl_pCacheData {
		cacheData[i] = *&sl_pCacheData[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetCudaModuleCacheNV = &vkCommand{"vkGetCudaModuleCacheNV", 4, true, nil}

// GetDeferredOperationMaxConcurrencyKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeferredOperationMaxConcurrencyKHR.html
func GetDeferredOperationMaxConcurrencyKHR(device Device, operation DeferredOperationKHR) (r uint32) {

	r = uint32(execTrampoline(vkGetDeferredOperationMaxConcurrencyKHR, uintptr(device), uintptr(operation)))

	return
}

var vkGetDeferredOperationMaxConcurrencyKHR = &vkCommand{"vkGetDeferredOperationMaxConcurrencyKHR", 2, true, nil}

// GetDeferredOperationResultKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeferredOperationResultKHR.html
func GetDeferredOperationResultKHR(device Device, operation DeferredOperationKHR) (r error) {

	r = Result(execTrampoline(vkGetDeferredOperationResultKHR, uintptr(device), uintptr(operation)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDeferredOperationResultKHR = &vkCommand{"vkGetDeferredOperationResultKHR", 2, true, nil}

// GetDescriptorEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorEXT.html
func GetDescriptorEXT(device Device, descriptorInfo *DescriptorGetInfoEXT, descriptor []byte) {
	// Parameter is a singular input, requires translation - descriptorInfo
	var pDescriptorInfo *_vkDescriptorGetInfoEXT
	if descriptorInfo != nil {
		pDescriptorInfo = descriptorInfo.Vulkanize()
	}

	dataSize := len(descriptor)
	// descriptor is a user-allocated array input that will be written to
	pDescriptor := unsafe.Pointer(&descriptor[0])

	execTrampoline(vkGetDescriptorEXT, uintptr(device), uintptr(unsafe.Pointer(pDescriptorInfo)), uintptr(dataSize), uintptr(unsafe.Pointer(pDescriptor)))

}

var vkGetDescriptorEXT = &vkCommand{"vkGetDescriptorEXT", 4, true, nil}

// GetDescriptorSetHostMappingVALVE: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetHostMappingVALVE.html
func GetDescriptorSetHostMappingVALVE(device Device, descriptorSet DescriptorSet) (pData *byte) {
	// pData is a binding-allocated single return value and will be populated by Vulkan
	ptr_ppData := &pData

	execTrampoline(vkGetDescriptorSetHostMappingVALVE, uintptr(device), uintptr(descriptorSet), uintptr(unsafe.Pointer(ptr_ppData)))

	return
}

var vkGetDescriptorSetHostMappingVALVE = &vkCommand{"vkGetDescriptorSetHostMappingVALVE", 3, true, nil}

// GetDescriptorSetLayoutBindingOffsetEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutBindingOffsetEXT.html
func GetDescriptorSetLayoutBindingOffsetEXT(device Device, layout DescriptorSetLayout, binding uint32) (offset DeviceSize) {
	// offset is a binding-allocated single return value and will be populated by Vulkan
	ptr_pOffset := &offset

	execTrampoline(vkGetDescriptorSetLayoutBindingOffsetEXT, uintptr(device), uintptr(layout), uintptr(binding), uintptr(unsafe.Pointer(ptr_pOffset)))

	return
}

var vkGetDescriptorSetLayoutBindingOffsetEXT = &vkCommand{"vkGetDescriptorSetLayoutBindingOffsetEXT", 4, true, nil}

// GetDescriptorSetLayoutHostMappingInfoVALVE: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutHostMappingInfoVALVE.html
func GetDescriptorSetLayoutHostMappingInfoVALVE(device Device, bindingReference *DescriptorSetBindingReferenceVALVE) (hostMapping DescriptorSetLayoutHostMappingInfoVALVE) {
	// Parameter is a singular input, requires translation - bindingReference
	var pBindingReference *_vkDescriptorSetBindingReferenceVALVE
	if bindingReference != nil {
		pBindingReference = bindingReference.Vulkanize()
	}

	// hostMapping is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pHostMapping *_vkDescriptorSetLayoutHostMappingInfoVALVE = hostMapping.Vulkanize()

	execTrampoline(vkGetDescriptorSetLayoutHostMappingInfoVALVE, uintptr(device), uintptr(unsafe.Pointer(pBindingReference)), uintptr(unsafe.Pointer(pHostMapping)))

	hostMapping = *(pHostMapping.Goify())
	return
}

var vkGetDescriptorSetLayoutHostMappingInfoVALVE = &vkCommand{"vkGetDescriptorSetLayoutHostMappingInfoVALVE", 3, true, nil}

// GetDescriptorSetLayoutSizeEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutSizeEXT.html
func GetDescriptorSetLayoutSizeEXT(device Device, layout DescriptorSetLayout) (layoutSizeInBytes DeviceSize) {
	// layoutSizeInBytes is a binding-allocated single return value and will be populated by Vulkan
	ptr_pLayoutSizeInBytes := &layoutSizeInBytes

	execTrampoline(vkGetDescriptorSetLayoutSizeEXT, uintptr(device), uintptr(layout), uintptr(unsafe.Pointer(ptr_pLayoutSizeInBytes)))

	return
}

var vkGetDescriptorSetLayoutSizeEXT = &vkCommand{"vkGetDescriptorSetLayoutSizeEXT", 3, true, nil}

// GetDescriptorSetLayoutSupport: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutSupport.html
func GetDescriptorSetLayoutSupport(device Device, createInfo *DescriptorSetLayoutCreateInfo) (support DescriptorSetLayoutSupport) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDescriptorSetLayoutCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// support is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSupport *_vkDescriptorSetLayoutSupport = support.Vulkanize()

	execTrampoline(vkGetDescriptorSetLayoutSupport, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pSupport)))

	support = *(pSupport.Goify())
	return
}

var vkGetDescriptorSetLayoutSupport = &vkCommand{"vkGetDescriptorSetLayoutSupport", 3, true, nil}
var GetDescriptorSetLayoutSupportKHR = GetDescriptorSetLayoutSupport

// GetDeviceAccelerationStructureCompatibilityKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceAccelerationStructureCompatibilityKHR.html
func GetDeviceAccelerationStructureCompatibilityKHR(device Device, versionInfo *AccelerationStructureVersionInfoKHR) (compatibility AccelerationStructureCompatibilityKHR) {
	// Parameter is a singular input, requires translation - versionInfo
	var pVersionInfo *_vkAccelerationStructureVersionInfoKHR
	if versionInfo != nil {
		pVersionInfo = versionInfo.Vulkanize()
	}

	// compatibility is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCompatibility := &compatibility

	execTrampoline(vkGetDeviceAccelerationStructureCompatibilityKHR, uintptr(device), uintptr(unsafe.Pointer(pVersionInfo)), uintptr(unsafe.Pointer(ptr_pCompatibility)))

	return
}

var vkGetDeviceAccelerationStructureCompatibilityKHR = &vkCommand{"vkGetDeviceAccelerationStructureCompatibilityKHR", 3, true, nil}

// GetDeviceBufferMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceBufferMemoryRequirements.html
func GetDeviceBufferMemoryRequirements(device Device, info *DeviceBufferMemoryRequirements) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkDeviceBufferMemoryRequirements
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryRequirements *_vkMemoryRequirements2 = memoryRequirements.Vulkanize()

	execTrampoline(vkGetDeviceBufferMemoryRequirements, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pMemoryRequirements)))

	memoryRequirements = *(pMemoryRequirements.Goify())
	return
}

var vkGetDeviceBufferMemoryRequirements = &vkCommand{"vkGetDeviceBufferMemoryRequirements", 3, true, nil}
var GetDeviceBufferMemoryRequirementsKHR = GetDeviceBufferMemoryRequirements

// GetDeviceFaultInfoEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceFaultInfoEXT.html
func GetDeviceFaultInfoEXT(device Device) (faultCounts DeviceFaultCountsEXT, faultInfo DeviceFaultInfoEXT, r error) {
	// faultCounts is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pFaultCounts *_vkDeviceFaultCountsEXT = faultCounts.Vulkanize()

	// faultInfo is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pFaultInfo *_vkDeviceFaultInfoEXT = faultInfo.Vulkanize()

	r = Result(execTrampoline(vkGetDeviceFaultInfoEXT, uintptr(device), uintptr(unsafe.Pointer(pFaultCounts)), uintptr(unsafe.Pointer(pFaultInfo))))

	faultCounts = *(pFaultCounts.Goify())
	faultInfo = *(pFaultInfo.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDeviceFaultInfoEXT = &vkCommand{"vkGetDeviceFaultInfoEXT", 3, true, nil}

// GetDeviceGroupPeerMemoryFeatures: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupPeerMemoryFeatures.html
func GetDeviceGroupPeerMemoryFeatures(device Device, heapIndex uint32, localDeviceIndex uint32, remoteDeviceIndex uint32) (peerMemoryFeatures PeerMemoryFeatureFlags) {
	// peerMemoryFeatures is a binding-allocated single return value and will be populated by Vulkan
	ptr_pPeerMemoryFeatures := &peerMemoryFeatures

	execTrampoline(vkGetDeviceGroupPeerMemoryFeatures, uintptr(device), uintptr(heapIndex), uintptr(localDeviceIndex), uintptr(remoteDeviceIndex), uintptr(unsafe.Pointer(ptr_pPeerMemoryFeatures)))

	return
}

var vkGetDeviceGroupPeerMemoryFeatures = &vkCommand{"vkGetDeviceGroupPeerMemoryFeatures", 5, true, nil}
var GetDeviceGroupPeerMemoryFeaturesKHR = GetDeviceGroupPeerMemoryFeatures

// GetDeviceGroupPresentCapabilitiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupPresentCapabilitiesKHR.html
func GetDeviceGroupPresentCapabilitiesKHR(device Device) (deviceGroupPresentCapabilities DeviceGroupPresentCapabilitiesKHR, r error) {
	// deviceGroupPresentCapabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pDeviceGroupPresentCapabilities *_vkDeviceGroupPresentCapabilitiesKHR = deviceGroupPresentCapabilities.Vulkanize()

	r = Result(execTrampoline(vkGetDeviceGroupPresentCapabilitiesKHR, uintptr(device), uintptr(unsafe.Pointer(pDeviceGroupPresentCapabilities))))

	deviceGroupPresentCapabilities = *(pDeviceGroupPresentCapabilities.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDeviceGroupPresentCapabilitiesKHR = &vkCommand{"vkGetDeviceGroupPresentCapabilitiesKHR", 2, true, nil}

// GetDeviceGroupSurfacePresentModesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupSurfacePresentModesKHR.html
func GetDeviceGroupSurfacePresentModesKHR(device Device, surface SurfaceKHR) (modes DeviceGroupPresentModeFlagsKHR, r error) {
	// modes is a binding-allocated single return value and will be populated by Vulkan
	ptr_pModes := &modes

	r = Result(execTrampoline(vkGetDeviceGroupSurfacePresentModesKHR, uintptr(device), uintptr(surface), uintptr(unsafe.Pointer(ptr_pModes))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDeviceGroupSurfacePresentModesKHR = &vkCommand{"vkGetDeviceGroupSurfacePresentModesKHR", 3, true, nil}

// GetDeviceImageMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageMemoryRequirements.html
func GetDeviceImageMemoryRequirements(device Device, info *DeviceImageMemoryRequirements) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkDeviceImageMemoryRequirements
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryRequirements *_vkMemoryRequirements2 = memoryRequirements.Vulkanize()

	execTrampoline(vkGetDeviceImageMemoryRequirements, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pMemoryRequirements)))

	memoryRequirements = *(pMemoryRequirements.Goify())
	return
}

var vkGetDeviceImageMemoryRequirements = &vkCommand{"vkGetDeviceImageMemoryRequirements", 3, true, nil}
var GetDeviceImageMemoryRequirementsKHR = GetDeviceImageMemoryRequirements

// GetDeviceImageSparseMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageSparseMemoryRequirements.html
func GetDeviceImageSparseMemoryRequirements(device Device, info *DeviceImageMemoryRequirements) (sparseMemoryRequirements []SparseImageMemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkDeviceImageMemoryRequirements
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// sparseMemoryRequirements is a double-call array output
	var sparseMemoryRequirementCount uint32
	pSparseMemoryRequirementCount := &sparseMemoryRequirementCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSparseMemoryRequirements *_vkSparseImageMemoryRequirements2

	execTrampoline(vkGetDeviceImageSparseMemoryRequirements, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	sl_pSparseMemoryRequirements := make([]_vkSparseImageMemoryRequirements2, sparseMemoryRequirementCount)
	sparseMemoryRequirements = make([]SparseImageMemoryRequirements2, sparseMemoryRequirementCount)
	pSparseMemoryRequirements = &sl_pSparseMemoryRequirements[0]

	// Trampoline call after last array allocation
	execTrampoline(vkGetDeviceImageSparseMemoryRequirements, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	for i := range sl_pSparseMemoryRequirements {
		sparseMemoryRequirements[i] = *sl_pSparseMemoryRequirements[i].Goify()
	}
	return
}

var vkGetDeviceImageSparseMemoryRequirements = &vkCommand{"vkGetDeviceImageSparseMemoryRequirements", 4, true, nil}
var GetDeviceImageSparseMemoryRequirementsKHR = GetDeviceImageSparseMemoryRequirements

// GetDeviceImageSubresourceLayoutKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageSubresourceLayoutKHR.html
func GetDeviceImageSubresourceLayoutKHR(device Device, info *DeviceImageSubresourceInfoKHR) (layout SubresourceLayout2KHR) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkDeviceImageSubresourceInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// layout is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pLayout *_vkSubresourceLayout2KHR = layout.Vulkanize()

	execTrampoline(vkGetDeviceImageSubresourceLayoutKHR, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pLayout)))

	layout = *(pLayout.Goify())
	return
}

var vkGetDeviceImageSubresourceLayoutKHR = &vkCommand{"vkGetDeviceImageSubresourceLayoutKHR", 3, true, nil}

// GetDeviceMemoryCommitment: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMemoryCommitment.html
func GetDeviceMemoryCommitment(device Device, memory DeviceMemory) (committedMemoryInBytes DeviceSize) {
	// committedMemoryInBytes is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCommittedMemoryInBytes := &committedMemoryInBytes

	execTrampoline(vkGetDeviceMemoryCommitment, uintptr(device), uintptr(memory), uintptr(unsafe.Pointer(ptr_pCommittedMemoryInBytes)))

	return
}

var vkGetDeviceMemoryCommitment = &vkCommand{"vkGetDeviceMemoryCommitment", 3, true, nil}

// GetDeviceMemoryOpaqueCaptureAddress: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMemoryOpaqueCaptureAddress.html
func GetDeviceMemoryOpaqueCaptureAddress(device Device, info *DeviceMemoryOpaqueCaptureAddressInfo) (r uint64) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkDeviceMemoryOpaqueCaptureAddressInfo
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = uint64(execTrampoline(vkGetDeviceMemoryOpaqueCaptureAddress, uintptr(device), uintptr(unsafe.Pointer(pInfo))))

	return
}

var vkGetDeviceMemoryOpaqueCaptureAddress = &vkCommand{"vkGetDeviceMemoryOpaqueCaptureAddress", 2, true, nil}
var GetDeviceMemoryOpaqueCaptureAddressKHR = GetDeviceMemoryOpaqueCaptureAddress

// GetDeviceMicromapCompatibilityEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMicromapCompatibilityEXT.html
func GetDeviceMicromapCompatibilityEXT(device Device, versionInfo *MicromapVersionInfoEXT) (compatibility AccelerationStructureCompatibilityKHR) {
	// Parameter is a singular input, requires translation - versionInfo
	var pVersionInfo *_vkMicromapVersionInfoEXT
	if versionInfo != nil {
		pVersionInfo = versionInfo.Vulkanize()
	}

	// compatibility is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCompatibility := &compatibility

	execTrampoline(vkGetDeviceMicromapCompatibilityEXT, uintptr(device), uintptr(unsafe.Pointer(pVersionInfo)), uintptr(unsafe.Pointer(ptr_pCompatibility)))

	return
}

var vkGetDeviceMicromapCompatibilityEXT = &vkCommand{"vkGetDeviceMicromapCompatibilityEXT", 3, true, nil}

// GetDeviceProcAddr: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceProcAddr.html
func GetDeviceProcAddr(device Device, name string) (fn PFN_vkVoidFunction) {
	// Parameter is a singular input, requires translation - name
	var pName *byte
	if name != "" {
		pName = sys_stringToBytePointer(name)
	}

	fn = PFN_vkVoidFunction(execTrampoline(vkGetDeviceProcAddr, uintptr(device), uintptr(unsafe.Pointer(pName))))

	return
}

var vkGetDeviceProcAddr = &vkCommand{"vkGetDeviceProcAddr", 2, true, nil}

// GetDeviceQueue: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html
func GetDeviceQueue(device Device, queueFamilyIndex uint32, queueIndex uint32) (queue Queue) {
	// queue is a binding-allocated single return value and will be populated by Vulkan
	ptr_pQueue := &queue

	execTrampoline(vkGetDeviceQueue, uintptr(device), uintptr(queueFamilyIndex), uintptr(queueIndex), uintptr(unsafe.Pointer(ptr_pQueue)))

	return
}

var vkGetDeviceQueue = &vkCommand{"vkGetDeviceQueue", 4, true, nil}

// GetDeviceQueue2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue2.html
func GetDeviceQueue2(device Device, queueInfo *DeviceQueueInfo2) (queue Queue) {
	// Parameter is a singular input, requires translation - queueInfo
	var pQueueInfo *_vkDeviceQueueInfo2
	if queueInfo != nil {
		pQueueInfo = queueInfo.Vulkanize()
	}

	// queue is a binding-allocated single return value and will be populated by Vulkan
	ptr_pQueue := &queue

	execTrampoline(vkGetDeviceQueue2, uintptr(device), uintptr(unsafe.Pointer(pQueueInfo)), uintptr(unsafe.Pointer(ptr_pQueue)))

	return
}

var vkGetDeviceQueue2 = &vkCommand{"vkGetDeviceQueue2", 3, true, nil}

// GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.html
func GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(device Device, renderpass RenderPass) (maxWorkgroupSize Extent2D, r error) {
	// maxWorkgroupSize is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMaxWorkgroupSize := &maxWorkgroupSize

	r = Result(execTrampoline(vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI, uintptr(device), uintptr(renderpass), uintptr(unsafe.Pointer(ptr_pMaxWorkgroupSize))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = &vkCommand{"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI", 3, true, nil}

// GetDisplayModeProperties2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayModeProperties2KHR.html
func GetDisplayModeProperties2KHR(physicalDevice PhysicalDevice, display DisplayKHR) (properties []DisplayModeProperties2KHR, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayModeProperties2KHR

	r = Result(execTrampoline(vkGetDisplayModeProperties2KHR, uintptr(physicalDevice), uintptr(display), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkDisplayModeProperties2KHR, propertyCount)
	properties = make([]DisplayModeProperties2KHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetDisplayModeProperties2KHR, uintptr(physicalDevice), uintptr(display), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDisplayModeProperties2KHR = &vkCommand{"vkGetDisplayModeProperties2KHR", 4, true, nil}

// GetDisplayModePropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayModePropertiesKHR.html
func GetDisplayModePropertiesKHR(physicalDevice PhysicalDevice, display DisplayKHR) (properties []DisplayModePropertiesKHR, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayModePropertiesKHR

	r = Result(execTrampoline(vkGetDisplayModePropertiesKHR, uintptr(physicalDevice), uintptr(display), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkDisplayModePropertiesKHR, propertyCount)
	properties = make([]DisplayModePropertiesKHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetDisplayModePropertiesKHR, uintptr(physicalDevice), uintptr(display), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDisplayModePropertiesKHR = &vkCommand{"vkGetDisplayModePropertiesKHR", 4, true, nil}

// GetDisplayPlaneCapabilities2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneCapabilities2KHR.html
func GetDisplayPlaneCapabilities2KHR(physicalDevice PhysicalDevice, displayPlaneInfo *DisplayPlaneInfo2KHR) (capabilities DisplayPlaneCapabilities2KHR, r error) {
	// Parameter is a singular input, requires translation - displayPlaneInfo
	var pDisplayPlaneInfo *_vkDisplayPlaneInfo2KHR
	if displayPlaneInfo != nil {
		pDisplayPlaneInfo = displayPlaneInfo.Vulkanize()
	}

	// capabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pCapabilities *_vkDisplayPlaneCapabilities2KHR = capabilities.Vulkanize()

	r = Result(execTrampoline(vkGetDisplayPlaneCapabilities2KHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pDisplayPlaneInfo)), uintptr(unsafe.Pointer(pCapabilities))))

	capabilities = *(pCapabilities.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDisplayPlaneCapabilities2KHR = &vkCommand{"vkGetDisplayPlaneCapabilities2KHR", 3, true, nil}

// GetDisplayPlaneCapabilitiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneCapabilitiesKHR.html
func GetDisplayPlaneCapabilitiesKHR(physicalDevice PhysicalDevice, mode DisplayModeKHR, planeIndex uint32) (capabilities DisplayPlaneCapabilitiesKHR, r error) {
	// capabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pCapabilities *_vkDisplayPlaneCapabilitiesKHR = capabilities.Vulkanize()

	r = Result(execTrampoline(vkGetDisplayPlaneCapabilitiesKHR, uintptr(physicalDevice), uintptr(mode), uintptr(planeIndex), uintptr(unsafe.Pointer(pCapabilities))))

	capabilities = *(pCapabilities.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDisplayPlaneCapabilitiesKHR = &vkCommand{"vkGetDisplayPlaneCapabilitiesKHR", 4, true, nil}

// GetDisplayPlaneSupportedDisplaysKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneSupportedDisplaysKHR.html
func GetDisplayPlaneSupportedDisplaysKHR(physicalDevice PhysicalDevice, planeIndex uint32) (displays []DisplayKHR, r error) {
	// displays is a double-call array output
	var displayCount uint32
	pDisplayCount := &displayCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pDisplays *DisplayKHR

	r = Result(execTrampoline(vkGetDisplayPlaneSupportedDisplaysKHR, uintptr(physicalDevice), uintptr(planeIndex), uintptr(unsafe.Pointer(pDisplayCount)), uintptr(unsafe.Pointer(pDisplays))))

	sl_pDisplays := make([]DisplayKHR, displayCount)
	displays = make([]DisplayKHR, displayCount)
	pDisplays = &sl_pDisplays[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetDisplayPlaneSupportedDisplaysKHR, uintptr(physicalDevice), uintptr(planeIndex), uintptr(unsafe.Pointer(pDisplayCount)), uintptr(unsafe.Pointer(pDisplays))))

	for i := range sl_pDisplays {
		displays[i] = *&sl_pDisplays[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDisplayPlaneSupportedDisplaysKHR = &vkCommand{"vkGetDisplayPlaneSupportedDisplaysKHR", 4, true, nil}

// GetDrmDisplayEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDrmDisplayEXT.html
func GetDrmDisplayEXT(physicalDevice PhysicalDevice, drmFd int32, connectorId uint32) (display DisplayKHR, r error) {
	// display is a binding-allocated single return value and will be populated by Vulkan
	ptr_display := &display

	r = Result(execTrampoline(vkGetDrmDisplayEXT, uintptr(physicalDevice), uintptr(drmFd), uintptr(connectorId), uintptr(unsafe.Pointer(ptr_display))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDrmDisplayEXT = &vkCommand{"vkGetDrmDisplayEXT", 4, true, nil}

// GetDynamicRenderingTilePropertiesQCOM: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDynamicRenderingTilePropertiesQCOM.html
func GetDynamicRenderingTilePropertiesQCOM(device Device, renderingInfo *RenderingInfo) (properties TilePropertiesQCOM, r error) {
	// Parameter is a singular input, requires translation - renderingInfo
	var pRenderingInfo *_vkRenderingInfo
	if renderingInfo != nil {
		pRenderingInfo = renderingInfo.Vulkanize()
	}

	// properties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pProperties *_vkTilePropertiesQCOM = properties.Vulkanize()

	r = Result(execTrampoline(vkGetDynamicRenderingTilePropertiesQCOM, uintptr(device), uintptr(unsafe.Pointer(pRenderingInfo)), uintptr(unsafe.Pointer(pProperties))))

	properties = *(pProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDynamicRenderingTilePropertiesQCOM = &vkCommand{"vkGetDynamicRenderingTilePropertiesQCOM", 3, true, nil}

// GetEncodedVideoSessionParametersKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetEncodedVideoSessionParametersKHR.html
func GetEncodedVideoSessionParametersKHR(device Device, videoSessionParametersInfo *VideoEncodeSessionParametersGetInfoKHR) (feedbackInfo VideoEncodeSessionParametersFeedbackInfoKHR, data []byte, r error) {
	// Parameter is a singular input, requires translation - videoSessionParametersInfo
	var pVideoSessionParametersInfo *_vkVideoEncodeSessionParametersGetInfoKHR
	if videoSessionParametersInfo != nil {
		pVideoSessionParametersInfo = videoSessionParametersInfo.Vulkanize()
	}

	// feedbackInfo is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pFeedbackInfo *_vkVideoEncodeSessionParametersFeedbackInfoKHR = feedbackInfo.Vulkanize()

	// data is a double-call array output
	var dataSize uintptr
	pDataSize := &dataSize
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pData *byte

	r = Result(execTrampoline(vkGetEncodedVideoSessionParametersKHR, uintptr(device), uintptr(unsafe.Pointer(pVideoSessionParametersInfo)), uintptr(unsafe.Pointer(pFeedbackInfo)), uintptr(unsafe.Pointer(pDataSize)), uintptr(unsafe.Pointer(pData))))

	feedbackInfo = *(pFeedbackInfo.Goify())
	sl_pData := make([]byte, dataSize)
	data = make([]byte, dataSize)
	pData = &sl_pData[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetEncodedVideoSessionParametersKHR, uintptr(device), uintptr(unsafe.Pointer(pVideoSessionParametersInfo)), uintptr(unsafe.Pointer(pFeedbackInfo)), uintptr(unsafe.Pointer(pDataSize)), uintptr(unsafe.Pointer(pData))))

	for i := range sl_pData {
		data[i] = *&sl_pData[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetEncodedVideoSessionParametersKHR = &vkCommand{"vkGetEncodedVideoSessionParametersKHR", 5, true, nil}

// GetEventStatus: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetEventStatus.html
func GetEventStatus(device Device, event Event) (r error) {

	r = Result(execTrampoline(vkGetEventStatus, uintptr(device), uintptr(event)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetEventStatus = &vkCommand{"vkGetEventStatus", 2, true, nil}

// GetFenceFdKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceFdKHR.html
func GetFenceFdKHR(device Device, getFdInfo *FenceGetFdInfoKHR) (fd int32, r error) {
	// Parameter is a singular input, requires translation - getFdInfo
	var pGetFdInfo *_vkFenceGetFdInfoKHR
	if getFdInfo != nil {
		pGetFdInfo = getFdInfo.Vulkanize()
	}

	// fd is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFd := &fd

	r = Result(execTrampoline(vkGetFenceFdKHR, uintptr(device), uintptr(unsafe.Pointer(pGetFdInfo)), uintptr(unsafe.Pointer(ptr_pFd))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetFenceFdKHR = &vkCommand{"vkGetFenceFdKHR", 3, true, nil}

// GetFenceStatus: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceStatus.html
func GetFenceStatus(device Device, fence Fence) (r error) {

	r = Result(execTrampoline(vkGetFenceStatus, uintptr(device), uintptr(fence)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetFenceStatus = &vkCommand{"vkGetFenceStatus", 2, true, nil}

// GetFramebufferTilePropertiesQCOM: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFramebufferTilePropertiesQCOM.html
func GetFramebufferTilePropertiesQCOM(device Device, framebuffer Framebuffer) (properties []TilePropertiesQCOM, r error) {
	// properties is a double-call array output
	var propertiesCount uint32
	pPropertiesCount := &propertiesCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkTilePropertiesQCOM

	r = Result(execTrampoline(vkGetFramebufferTilePropertiesQCOM, uintptr(device), uintptr(framebuffer), uintptr(unsafe.Pointer(pPropertiesCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkTilePropertiesQCOM, propertiesCount)
	properties = make([]TilePropertiesQCOM, propertiesCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetFramebufferTilePropertiesQCOM, uintptr(device), uintptr(framebuffer), uintptr(unsafe.Pointer(pPropertiesCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetFramebufferTilePropertiesQCOM = &vkCommand{"vkGetFramebufferTilePropertiesQCOM", 4, true, nil}

// GetGeneratedCommandsMemoryRequirementsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetGeneratedCommandsMemoryRequirementsNV.html
func GetGeneratedCommandsMemoryRequirementsNV(device Device, info *GeneratedCommandsMemoryRequirementsInfoNV) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkGeneratedCommandsMemoryRequirementsInfoNV
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryRequirements *_vkMemoryRequirements2 = memoryRequirements.Vulkanize()

	execTrampoline(vkGetGeneratedCommandsMemoryRequirementsNV, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pMemoryRequirements)))

	memoryRequirements = *(pMemoryRequirements.Goify())
	return
}

var vkGetGeneratedCommandsMemoryRequirementsNV = &vkCommand{"vkGetGeneratedCommandsMemoryRequirementsNV", 3, true, nil}

// GetImageDrmFormatModifierPropertiesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageDrmFormatModifierPropertiesEXT.html
func GetImageDrmFormatModifierPropertiesEXT(device Device, image Image) (properties ImageDrmFormatModifierPropertiesEXT, r error) {
	// properties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pProperties *_vkImageDrmFormatModifierPropertiesEXT = properties.Vulkanize()

	r = Result(execTrampoline(vkGetImageDrmFormatModifierPropertiesEXT, uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pProperties))))

	properties = *(pProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetImageDrmFormatModifierPropertiesEXT = &vkCommand{"vkGetImageDrmFormatModifierPropertiesEXT", 3, true, nil}

// GetImageMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageMemoryRequirements.html
func GetImageMemoryRequirements(device Device, image Image) (memoryRequirements MemoryRequirements) {
	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMemoryRequirements := &memoryRequirements

	execTrampoline(vkGetImageMemoryRequirements, uintptr(device), uintptr(image), uintptr(unsafe.Pointer(ptr_pMemoryRequirements)))

	return
}

var vkGetImageMemoryRequirements = &vkCommand{"vkGetImageMemoryRequirements", 3, true, nil}

// GetImageMemoryRequirements2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageMemoryRequirements2.html
func GetImageMemoryRequirements2(device Device, info *ImageMemoryRequirementsInfo2) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkImageMemoryRequirementsInfo2
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryRequirements *_vkMemoryRequirements2 = memoryRequirements.Vulkanize()

	execTrampoline(vkGetImageMemoryRequirements2, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pMemoryRequirements)))

	memoryRequirements = *(pMemoryRequirements.Goify())
	return
}

var vkGetImageMemoryRequirements2 = &vkCommand{"vkGetImageMemoryRequirements2", 3, true, nil}
var GetImageMemoryRequirements2KHR = GetImageMemoryRequirements2

// GetImageOpaqueCaptureDescriptorDataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageOpaqueCaptureDescriptorDataEXT.html
func GetImageOpaqueCaptureDescriptorDataEXT(device Device, info *ImageCaptureDescriptorDataInfoEXT) (data byte, r error) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkImageCaptureDescriptorDataInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// data is a binding-allocated single return value and will be populated by Vulkan
	ptr_pData := &data

	r = Result(execTrampoline(vkGetImageOpaqueCaptureDescriptorDataEXT, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(ptr_pData))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetImageOpaqueCaptureDescriptorDataEXT = &vkCommand{"vkGetImageOpaqueCaptureDescriptorDataEXT", 3, true, nil}

// GetImageSparseMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSparseMemoryRequirements.html
func GetImageSparseMemoryRequirements(device Device, image Image) (sparseMemoryRequirements []SparseImageMemoryRequirements) {
	// sparseMemoryRequirements is a double-call array output
	var sparseMemoryRequirementCount uint32
	pSparseMemoryRequirementCount := &sparseMemoryRequirementCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSparseMemoryRequirements *_vkSparseImageMemoryRequirements

	execTrampoline(vkGetImageSparseMemoryRequirements, uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	sl_pSparseMemoryRequirements := make([]_vkSparseImageMemoryRequirements, sparseMemoryRequirementCount)
	sparseMemoryRequirements = make([]SparseImageMemoryRequirements, sparseMemoryRequirementCount)
	pSparseMemoryRequirements = &sl_pSparseMemoryRequirements[0]

	// Trampoline call after last array allocation
	execTrampoline(vkGetImageSparseMemoryRequirements, uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	for i := range sl_pSparseMemoryRequirements {
		sparseMemoryRequirements[i] = *sl_pSparseMemoryRequirements[i].Goify()
	}
	return
}

var vkGetImageSparseMemoryRequirements = &vkCommand{"vkGetImageSparseMemoryRequirements", 4, true, nil}

// GetImageSparseMemoryRequirements2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSparseMemoryRequirements2.html
func GetImageSparseMemoryRequirements2(device Device, info *ImageSparseMemoryRequirementsInfo2) (sparseMemoryRequirements []SparseImageMemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkImageSparseMemoryRequirementsInfo2
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// sparseMemoryRequirements is a double-call array output
	var sparseMemoryRequirementCount uint32
	pSparseMemoryRequirementCount := &sparseMemoryRequirementCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSparseMemoryRequirements *_vkSparseImageMemoryRequirements2

	execTrampoline(vkGetImageSparseMemoryRequirements2, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	sl_pSparseMemoryRequirements := make([]_vkSparseImageMemoryRequirements2, sparseMemoryRequirementCount)
	sparseMemoryRequirements = make([]SparseImageMemoryRequirements2, sparseMemoryRequirementCount)
	pSparseMemoryRequirements = &sl_pSparseMemoryRequirements[0]

	// Trampoline call after last array allocation
	execTrampoline(vkGetImageSparseMemoryRequirements2, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	for i := range sl_pSparseMemoryRequirements {
		sparseMemoryRequirements[i] = *sl_pSparseMemoryRequirements[i].Goify()
	}
	return
}

var vkGetImageSparseMemoryRequirements2 = &vkCommand{"vkGetImageSparseMemoryRequirements2", 4, true, nil}
var GetImageSparseMemoryRequirements2KHR = GetImageSparseMemoryRequirements2

// GetImageSubresourceLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSubresourceLayout.html
func GetImageSubresourceLayout(device Device, image Image, subresource *ImageSubresource) (layout SubresourceLayout) {
	// Parameter is a singular input, pass direct - subresource
	var pSubresource unsafe.Pointer
	if subresource != nil {
		pSubresource = unsafe.Pointer(subresource)
	}

	// layout is a binding-allocated single return value and will be populated by Vulkan
	ptr_pLayout := &layout

	execTrampoline(vkGetImageSubresourceLayout, uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pSubresource)), uintptr(unsafe.Pointer(ptr_pLayout)))

	return
}

var vkGetImageSubresourceLayout = &vkCommand{"vkGetImageSubresourceLayout", 4, true, nil}
var GetImageSubresourceLayout2EXT = GetImageSubresourceLayout2KHR

// GetImageSubresourceLayout2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSubresourceLayout2KHR.html
func GetImageSubresourceLayout2KHR(device Device, image Image, subresource *ImageSubresource2KHR) (layout SubresourceLayout2KHR) {
	// Parameter is a singular input, requires translation - subresource
	var pSubresource *_vkImageSubresource2KHR
	if subresource != nil {
		pSubresource = subresource.Vulkanize()
	}

	// layout is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pLayout *_vkSubresourceLayout2KHR = layout.Vulkanize()

	execTrampoline(vkGetImageSubresourceLayout2KHR, uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pSubresource)), uintptr(unsafe.Pointer(pLayout)))

	layout = *(pLayout.Goify())
	return
}

var vkGetImageSubresourceLayout2KHR = &vkCommand{"vkGetImageSubresourceLayout2KHR", 4, true, nil}

// GetImageViewAddressNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageViewAddressNVX.html
func GetImageViewAddressNVX(device Device, imageView ImageView) (properties ImageViewAddressPropertiesNVX, r error) {
	// properties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pProperties *_vkImageViewAddressPropertiesNVX = properties.Vulkanize()

	r = Result(execTrampoline(vkGetImageViewAddressNVX, uintptr(device), uintptr(imageView), uintptr(unsafe.Pointer(pProperties))))

	properties = *(pProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetImageViewAddressNVX = &vkCommand{"vkGetImageViewAddressNVX", 3, true, nil}

// GetImageViewHandleNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageViewHandleNVX.html
func GetImageViewHandleNVX(device Device, info *ImageViewHandleInfoNVX) (r uint32) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkImageViewHandleInfoNVX
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = uint32(execTrampoline(vkGetImageViewHandleNVX, uintptr(device), uintptr(unsafe.Pointer(pInfo))))

	return
}

var vkGetImageViewHandleNVX = &vkCommand{"vkGetImageViewHandleNVX", 2, true, nil}

// GetImageViewOpaqueCaptureDescriptorDataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageViewOpaqueCaptureDescriptorDataEXT.html
func GetImageViewOpaqueCaptureDescriptorDataEXT(device Device, info *ImageViewCaptureDescriptorDataInfoEXT) (data byte, r error) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkImageViewCaptureDescriptorDataInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// data is a binding-allocated single return value and will be populated by Vulkan
	ptr_pData := &data

	r = Result(execTrampoline(vkGetImageViewOpaqueCaptureDescriptorDataEXT, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(ptr_pData))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetImageViewOpaqueCaptureDescriptorDataEXT = &vkCommand{"vkGetImageViewOpaqueCaptureDescriptorDataEXT", 3, true, nil}

// GetInstanceProcAddr: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetInstanceProcAddr.html
func GetInstanceProcAddr(instance Instance, name string) (fn PFN_vkVoidFunction) {
	// Parameter is a singular input, requires translation - name
	var pName *byte
	if name != "" {
		pName = sys_stringToBytePointer(name)
	}

	fn = PFN_vkVoidFunction(execTrampoline(vkGetInstanceProcAddr, uintptr(instance), uintptr(unsafe.Pointer(pName))))

	return
}

var vkGetInstanceProcAddr = &vkCommand{"vkGetInstanceProcAddr", 2, true, nil}

// GetLatencyTimingsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetLatencyTimingsNV.html
func GetLatencyTimingsNV(device Device, swapchain SwapchainKHR) (latencyMarkerInfo GetLatencyMarkerInfoNV) {
	// latencyMarkerInfo is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pLatencyMarkerInfo *_vkGetLatencyMarkerInfoNV = latencyMarkerInfo.Vulkanize()

	execTrampoline(vkGetLatencyTimingsNV, uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pLatencyMarkerInfo)))

	latencyMarkerInfo = *(pLatencyMarkerInfo.Goify())
	return
}

var vkGetLatencyTimingsNV = &vkCommand{"vkGetLatencyTimingsNV", 3, true, nil}

// GetMemoryFdKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryFdKHR.html
func GetMemoryFdKHR(device Device, getFdInfo *MemoryGetFdInfoKHR) (fd int32, r error) {
	// Parameter is a singular input, requires translation - getFdInfo
	var pGetFdInfo *_vkMemoryGetFdInfoKHR
	if getFdInfo != nil {
		pGetFdInfo = getFdInfo.Vulkanize()
	}

	// fd is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFd := &fd

	r = Result(execTrampoline(vkGetMemoryFdKHR, uintptr(device), uintptr(unsafe.Pointer(pGetFdInfo)), uintptr(unsafe.Pointer(ptr_pFd))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetMemoryFdKHR = &vkCommand{"vkGetMemoryFdKHR", 3, true, nil}

// GetMemoryFdPropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryFdPropertiesKHR.html
func GetMemoryFdPropertiesKHR(device Device, handleType ExternalMemoryHandleTypeFlagBits, fd int32) (memoryFdProperties MemoryFdPropertiesKHR, r error) {
	// memoryFdProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryFdProperties *_vkMemoryFdPropertiesKHR = memoryFdProperties.Vulkanize()

	r = Result(execTrampoline(vkGetMemoryFdPropertiesKHR, uintptr(device), uintptr(handleType), uintptr(fd), uintptr(unsafe.Pointer(pMemoryFdProperties))))

	memoryFdProperties = *(pMemoryFdProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetMemoryFdPropertiesKHR = &vkCommand{"vkGetMemoryFdPropertiesKHR", 4, true, nil}

// GetMemoryHostPointerPropertiesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryHostPointerPropertiesEXT.html
func GetMemoryHostPointerPropertiesEXT(device Device, handleType ExternalMemoryHandleTypeFlagBits, hostPointer *byte) (memoryHostPointerProperties MemoryHostPointerPropertiesEXT, r error) {
	// Parameter is a singular input, pass direct - hostPointer
	var pHostPointer unsafe.Pointer
	if hostPointer != nil {
		pHostPointer = unsafe.Pointer(hostPointer)
	}

	// memoryHostPointerProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryHostPointerProperties *_vkMemoryHostPointerPropertiesEXT = memoryHostPointerProperties.Vulkanize()

	r = Result(execTrampoline(vkGetMemoryHostPointerPropertiesEXT, uintptr(device), uintptr(handleType), uintptr(unsafe.Pointer(pHostPointer)), uintptr(unsafe.Pointer(pMemoryHostPointerProperties))))

	memoryHostPointerProperties = *(pMemoryHostPointerProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetMemoryHostPointerPropertiesEXT = &vkCommand{"vkGetMemoryHostPointerPropertiesEXT", 4, true, nil}

// GetMemoryRemoteAddressNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryRemoteAddressNV.html
func GetMemoryRemoteAddressNV(device Device, memoryGetRemoteAddressInfo *MemoryGetRemoteAddressInfoNV) (address RemoteAddressNV, r error) {
	// Parameter is a singular input, requires translation - memoryGetRemoteAddressInfo
	var pMemoryGetRemoteAddressInfo *_vkMemoryGetRemoteAddressInfoNV
	if memoryGetRemoteAddressInfo != nil {
		pMemoryGetRemoteAddressInfo = memoryGetRemoteAddressInfo.Vulkanize()
	}

	// address is a binding-allocated single return value and will be populated by Vulkan
	ptr_pAddress := &address

	r = Result(execTrampoline(vkGetMemoryRemoteAddressNV, uintptr(device), uintptr(unsafe.Pointer(pMemoryGetRemoteAddressInfo)), uintptr(unsafe.Pointer(ptr_pAddress))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetMemoryRemoteAddressNV = &vkCommand{"vkGetMemoryRemoteAddressNV", 3, true, nil}

// GetMicromapBuildSizesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMicromapBuildSizesEXT.html
func GetMicromapBuildSizesEXT(device Device, buildType AccelerationStructureBuildTypeKHR, buildInfo *MicromapBuildInfoEXT) (sizeInfo MicromapBuildSizesInfoEXT) {
	// Parameter is a singular input, requires translation - buildInfo
	var pBuildInfo *_vkMicromapBuildInfoEXT
	if buildInfo != nil {
		pBuildInfo = buildInfo.Vulkanize()
	}

	// sizeInfo is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSizeInfo *_vkMicromapBuildSizesInfoEXT = sizeInfo.Vulkanize()

	execTrampoline(vkGetMicromapBuildSizesEXT, uintptr(device), uintptr(buildType), uintptr(unsafe.Pointer(pBuildInfo)), uintptr(unsafe.Pointer(pSizeInfo)))

	sizeInfo = *(pSizeInfo.Goify())
	return
}

var vkGetMicromapBuildSizesEXT = &vkCommand{"vkGetMicromapBuildSizesEXT", 4, true, nil}

// GetPastPresentationTimingGOOGLE: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPastPresentationTimingGOOGLE.html
func GetPastPresentationTimingGOOGLE(device Device, swapchain SwapchainKHR) (presentationTimings []PastPresentationTimingGOOGLE, r error) {
	// presentationTimings is a double-call array output
	var presentationTimingCount uint32
	pPresentationTimingCount := &presentationTimingCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pPresentationTimings *_vkPastPresentationTimingGOOGLE

	r = Result(execTrampoline(vkGetPastPresentationTimingGOOGLE, uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pPresentationTimingCount)), uintptr(unsafe.Pointer(pPresentationTimings))))

	sl_pPresentationTimings := make([]_vkPastPresentationTimingGOOGLE, presentationTimingCount)
	presentationTimings = make([]PastPresentationTimingGOOGLE, presentationTimingCount)
	pPresentationTimings = &sl_pPresentationTimings[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPastPresentationTimingGOOGLE, uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pPresentationTimingCount)), uintptr(unsafe.Pointer(pPresentationTimings))))

	for i := range sl_pPresentationTimings {
		presentationTimings[i] = *sl_pPresentationTimings[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPastPresentationTimingGOOGLE = &vkCommand{"vkGetPastPresentationTimingGOOGLE", 4, true, nil}

// GetPerformanceParameterINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPerformanceParameterINTEL.html
func GetPerformanceParameterINTEL(device Device, parameter PerformanceParameterTypeINTEL) (value PerformanceValueINTEL, r error) {
	// value is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pValue *_vkPerformanceValueINTEL = value.Vulkanize()

	r = Result(execTrampoline(vkGetPerformanceParameterINTEL, uintptr(device), uintptr(parameter), uintptr(unsafe.Pointer(pValue))))

	value = *(pValue.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPerformanceParameterINTEL = &vkCommand{"vkGetPerformanceParameterINTEL", 3, true, nil}
var GetPhysicalDeviceCalibrateableTimeDomainsEXT = GetPhysicalDeviceCalibrateableTimeDomainsKHR

// GetPhysicalDeviceCalibrateableTimeDomainsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsKHR.html
func GetPhysicalDeviceCalibrateableTimeDomainsKHR(physicalDevice PhysicalDevice) (timeDomains []TimeDomainKHR, r error) {
	// timeDomains is a double-call array output
	var timeDomainCount uint32
	pTimeDomainCount := &timeDomainCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pTimeDomains *TimeDomainKHR

	r = Result(execTrampoline(vkGetPhysicalDeviceCalibrateableTimeDomainsKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pTimeDomainCount)), uintptr(unsafe.Pointer(pTimeDomains))))

	sl_pTimeDomains := make([]TimeDomainKHR, timeDomainCount)
	timeDomains = make([]TimeDomainKHR, timeDomainCount)
	pTimeDomains = &sl_pTimeDomains[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDeviceCalibrateableTimeDomainsKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pTimeDomainCount)), uintptr(unsafe.Pointer(pTimeDomains))))

	for i := range sl_pTimeDomains {
		timeDomains[i] = *&sl_pTimeDomains[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceCalibrateableTimeDomainsKHR = &vkCommand{"vkGetPhysicalDeviceCalibrateableTimeDomainsKHR", 3, true, nil}

// GetPhysicalDeviceCooperativeMatrixPropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR.html
func GetPhysicalDeviceCooperativeMatrixPropertiesKHR(physicalDevice PhysicalDevice) (properties []CooperativeMatrixPropertiesKHR, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkCooperativeMatrixPropertiesKHR

	r = Result(execTrampoline(vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkCooperativeMatrixPropertiesKHR, propertyCount)
	properties = make([]CooperativeMatrixPropertiesKHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR = &vkCommand{"vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR", 3, true, nil}

// GetPhysicalDeviceCooperativeMatrixPropertiesNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.html
func GetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice PhysicalDevice) (properties []CooperativeMatrixPropertiesNV, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkCooperativeMatrixPropertiesNV

	r = Result(execTrampoline(vkGetPhysicalDeviceCooperativeMatrixPropertiesNV, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkCooperativeMatrixPropertiesNV, propertyCount)
	properties = make([]CooperativeMatrixPropertiesNV, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDeviceCooperativeMatrixPropertiesNV, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = &vkCommand{"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", 3, true, nil}

// GetPhysicalDeviceDisplayPlaneProperties2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPlaneProperties2KHR.html
func GetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice PhysicalDevice) (properties []DisplayPlaneProperties2KHR, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayPlaneProperties2KHR

	r = Result(execTrampoline(vkGetPhysicalDeviceDisplayPlaneProperties2KHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkDisplayPlaneProperties2KHR, propertyCount)
	properties = make([]DisplayPlaneProperties2KHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDeviceDisplayPlaneProperties2KHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceDisplayPlaneProperties2KHR = &vkCommand{"vkGetPhysicalDeviceDisplayPlaneProperties2KHR", 3, true, nil}

// GetPhysicalDeviceDisplayPlanePropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPlanePropertiesKHR.html
func GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice PhysicalDevice) (properties []DisplayPlanePropertiesKHR, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayPlanePropertiesKHR

	r = Result(execTrampoline(vkGetPhysicalDeviceDisplayPlanePropertiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkDisplayPlanePropertiesKHR, propertyCount)
	properties = make([]DisplayPlanePropertiesKHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDeviceDisplayPlanePropertiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceDisplayPlanePropertiesKHR = &vkCommand{"vkGetPhysicalDeviceDisplayPlanePropertiesKHR", 3, true, nil}

// GetPhysicalDeviceDisplayProperties2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayProperties2KHR.html
func GetPhysicalDeviceDisplayProperties2KHR(physicalDevice PhysicalDevice) (properties []DisplayProperties2KHR, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayProperties2KHR

	r = Result(execTrampoline(vkGetPhysicalDeviceDisplayProperties2KHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkDisplayProperties2KHR, propertyCount)
	properties = make([]DisplayProperties2KHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDeviceDisplayProperties2KHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceDisplayProperties2KHR = &vkCommand{"vkGetPhysicalDeviceDisplayProperties2KHR", 3, true, nil}

// GetPhysicalDeviceDisplayPropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPropertiesKHR.html
func GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice PhysicalDevice) (properties []DisplayPropertiesKHR, r error) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayPropertiesKHR

	r = Result(execTrampoline(vkGetPhysicalDeviceDisplayPropertiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkDisplayPropertiesKHR, propertyCount)
	properties = make([]DisplayPropertiesKHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDeviceDisplayPropertiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceDisplayPropertiesKHR = &vkCommand{"vkGetPhysicalDeviceDisplayPropertiesKHR", 3, true, nil}

// GetPhysicalDeviceExternalBufferProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalBufferProperties.html
func GetPhysicalDeviceExternalBufferProperties(physicalDevice PhysicalDevice, externalBufferInfo *PhysicalDeviceExternalBufferInfo) (externalBufferProperties ExternalBufferProperties) {
	// Parameter is a singular input, requires translation - externalBufferInfo
	var pExternalBufferInfo *_vkPhysicalDeviceExternalBufferInfo
	if externalBufferInfo != nil {
		pExternalBufferInfo = externalBufferInfo.Vulkanize()
	}

	// externalBufferProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pExternalBufferProperties *_vkExternalBufferProperties = externalBufferProperties.Vulkanize()

	execTrampoline(vkGetPhysicalDeviceExternalBufferProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pExternalBufferInfo)), uintptr(unsafe.Pointer(pExternalBufferProperties)))

	externalBufferProperties = *(pExternalBufferProperties.Goify())
	return
}

var vkGetPhysicalDeviceExternalBufferProperties = &vkCommand{"vkGetPhysicalDeviceExternalBufferProperties", 3, true, nil}
var GetPhysicalDeviceExternalBufferPropertiesKHR = GetPhysicalDeviceExternalBufferProperties

// GetPhysicalDeviceExternalFenceProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalFenceProperties.html
func GetPhysicalDeviceExternalFenceProperties(physicalDevice PhysicalDevice, externalFenceInfo *PhysicalDeviceExternalFenceInfo) (externalFenceProperties ExternalFenceProperties) {
	// Parameter is a singular input, requires translation - externalFenceInfo
	var pExternalFenceInfo *_vkPhysicalDeviceExternalFenceInfo
	if externalFenceInfo != nil {
		pExternalFenceInfo = externalFenceInfo.Vulkanize()
	}

	// externalFenceProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pExternalFenceProperties *_vkExternalFenceProperties = externalFenceProperties.Vulkanize()

	execTrampoline(vkGetPhysicalDeviceExternalFenceProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pExternalFenceInfo)), uintptr(unsafe.Pointer(pExternalFenceProperties)))

	externalFenceProperties = *(pExternalFenceProperties.Goify())
	return
}

var vkGetPhysicalDeviceExternalFenceProperties = &vkCommand{"vkGetPhysicalDeviceExternalFenceProperties", 3, true, nil}
var GetPhysicalDeviceExternalFencePropertiesKHR = GetPhysicalDeviceExternalFenceProperties

// GetPhysicalDeviceExternalImageFormatPropertiesNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalImageFormatPropertiesNV.html
func GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice PhysicalDevice, format Format, typ ImageType, tiling ImageTiling, usage ImageUsageFlags, flags ImageCreateFlags, externalHandleType ExternalMemoryHandleTypeFlagsNV) (externalImageFormatProperties ExternalImageFormatPropertiesNV, r error) {
	// externalImageFormatProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pExternalImageFormatProperties *_vkExternalImageFormatPropertiesNV = externalImageFormatProperties.Vulkanize()

	r = Result(execTrampoline(vkGetPhysicalDeviceExternalImageFormatPropertiesNV, uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(tiling), uintptr(usage), uintptr(flags), uintptr(externalHandleType), uintptr(unsafe.Pointer(pExternalImageFormatProperties))))

	externalImageFormatProperties = *(pExternalImageFormatProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceExternalImageFormatPropertiesNV = &vkCommand{"vkGetPhysicalDeviceExternalImageFormatPropertiesNV", 8, true, nil}

// GetPhysicalDeviceExternalSemaphoreProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalSemaphoreProperties.html
func GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice PhysicalDevice, externalSemaphoreInfo *PhysicalDeviceExternalSemaphoreInfo) (externalSemaphoreProperties ExternalSemaphoreProperties) {
	// Parameter is a singular input, requires translation - externalSemaphoreInfo
	var pExternalSemaphoreInfo *_vkPhysicalDeviceExternalSemaphoreInfo
	if externalSemaphoreInfo != nil {
		pExternalSemaphoreInfo = externalSemaphoreInfo.Vulkanize()
	}

	// externalSemaphoreProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pExternalSemaphoreProperties *_vkExternalSemaphoreProperties = externalSemaphoreProperties.Vulkanize()

	execTrampoline(vkGetPhysicalDeviceExternalSemaphoreProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pExternalSemaphoreInfo)), uintptr(unsafe.Pointer(pExternalSemaphoreProperties)))

	externalSemaphoreProperties = *(pExternalSemaphoreProperties.Goify())
	return
}

var vkGetPhysicalDeviceExternalSemaphoreProperties = &vkCommand{"vkGetPhysicalDeviceExternalSemaphoreProperties", 3, true, nil}
var GetPhysicalDeviceExternalSemaphorePropertiesKHR = GetPhysicalDeviceExternalSemaphoreProperties

// GetPhysicalDeviceFeatures: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html
func GetPhysicalDeviceFeatures(physicalDevice PhysicalDevice) (features PhysicalDeviceFeatures) {
	// features is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pFeatures *_vkPhysicalDeviceFeatures = features.Vulkanize()

	execTrampoline(vkGetPhysicalDeviceFeatures, uintptr(physicalDevice), uintptr(unsafe.Pointer(pFeatures)))

	features = *(pFeatures.Goify())
	return
}

var vkGetPhysicalDeviceFeatures = &vkCommand{"vkGetPhysicalDeviceFeatures", 2, true, nil}

// GetPhysicalDeviceFeatures2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures2.html
func GetPhysicalDeviceFeatures2(physicalDevice PhysicalDevice) (features PhysicalDeviceFeatures2) {
	// features is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pFeatures *_vkPhysicalDeviceFeatures2 = features.Vulkanize()

	execTrampoline(vkGetPhysicalDeviceFeatures2, uintptr(physicalDevice), uintptr(unsafe.Pointer(pFeatures)))

	features = *(pFeatures.Goify())
	return
}

var vkGetPhysicalDeviceFeatures2 = &vkCommand{"vkGetPhysicalDeviceFeatures2", 2, true, nil}
var GetPhysicalDeviceFeatures2KHR = GetPhysicalDeviceFeatures2

// GetPhysicalDeviceFormatProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFormatProperties.html
func GetPhysicalDeviceFormatProperties(physicalDevice PhysicalDevice, format Format) (formatProperties FormatProperties) {
	// formatProperties is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFormatProperties := &formatProperties

	execTrampoline(vkGetPhysicalDeviceFormatProperties, uintptr(physicalDevice), uintptr(format), uintptr(unsafe.Pointer(ptr_pFormatProperties)))

	return
}

var vkGetPhysicalDeviceFormatProperties = &vkCommand{"vkGetPhysicalDeviceFormatProperties", 3, true, nil}

// GetPhysicalDeviceFormatProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFormatProperties2.html
func GetPhysicalDeviceFormatProperties2(physicalDevice PhysicalDevice, format Format) (formatProperties FormatProperties2) {
	// formatProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pFormatProperties *_vkFormatProperties2 = formatProperties.Vulkanize()

	execTrampoline(vkGetPhysicalDeviceFormatProperties2, uintptr(physicalDevice), uintptr(format), uintptr(unsafe.Pointer(pFormatProperties)))

	formatProperties = *(pFormatProperties.Goify())
	return
}

var vkGetPhysicalDeviceFormatProperties2 = &vkCommand{"vkGetPhysicalDeviceFormatProperties2", 3, true, nil}
var GetPhysicalDeviceFormatProperties2KHR = GetPhysicalDeviceFormatProperties2

// GetPhysicalDeviceFragmentShadingRatesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFragmentShadingRatesKHR.html
func GetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice PhysicalDevice) (fragmentShadingRates []PhysicalDeviceFragmentShadingRateKHR, r error) {
	// fragmentShadingRates is a double-call array output
	var fragmentShadingRateCount uint32
	pFragmentShadingRateCount := &fragmentShadingRateCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pFragmentShadingRates *_vkPhysicalDeviceFragmentShadingRateKHR

	r = Result(execTrampoline(vkGetPhysicalDeviceFragmentShadingRatesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pFragmentShadingRateCount)), uintptr(unsafe.Pointer(pFragmentShadingRates))))

	sl_pFragmentShadingRates := make([]_vkPhysicalDeviceFragmentShadingRateKHR, fragmentShadingRateCount)
	fragmentShadingRates = make([]PhysicalDeviceFragmentShadingRateKHR, fragmentShadingRateCount)
	pFragmentShadingRates = &sl_pFragmentShadingRates[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDeviceFragmentShadingRatesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pFragmentShadingRateCount)), uintptr(unsafe.Pointer(pFragmentShadingRates))))

	for i := range sl_pFragmentShadingRates {
		fragmentShadingRates[i] = *sl_pFragmentShadingRates[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceFragmentShadingRatesKHR = &vkCommand{"vkGetPhysicalDeviceFragmentShadingRatesKHR", 3, true, nil}

// GetPhysicalDeviceImageFormatProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties.html
func GetPhysicalDeviceImageFormatProperties(physicalDevice PhysicalDevice, format Format, typ ImageType, tiling ImageTiling, usage ImageUsageFlags, flags ImageCreateFlags) (imageFormatProperties ImageFormatProperties, r error) {
	// imageFormatProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pImageFormatProperties *_vkImageFormatProperties = imageFormatProperties.Vulkanize()

	r = Result(execTrampoline(vkGetPhysicalDeviceImageFormatProperties, uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(tiling), uintptr(usage), uintptr(flags), uintptr(unsafe.Pointer(pImageFormatProperties))))

	imageFormatProperties = *(pImageFormatProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceImageFormatProperties = &vkCommand{"vkGetPhysicalDeviceImageFormatProperties", 7, true, nil}

// GetPhysicalDeviceImageFormatProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties2.html
func GetPhysicalDeviceImageFormatProperties2(physicalDevice PhysicalDevice, imageFormatInfo *PhysicalDeviceImageFormatInfo2) (imageFormatProperties ImageFormatProperties2, r error) {
	// Parameter is a singular input, requires translation - imageFormatInfo
	var pImageFormatInfo *_vkPhysicalDeviceImageFormatInfo2
	if imageFormatInfo != nil {
		pImageFormatInfo = imageFormatInfo.Vulkanize()
	}

	// imageFormatProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pImageFormatProperties *_vkImageFormatProperties2 = imageFormatProperties.Vulkanize()

	r = Result(execTrampoline(vkGetPhysicalDeviceImageFormatProperties2, uintptr(physicalDevice), uintptr(unsafe.Pointer(pImageFormatInfo)), uintptr(unsafe.Pointer(pImageFormatProperties))))

	imageFormatProperties = *(pImageFormatProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceImageFormatProperties2 = &vkCommand{"vkGetPhysicalDeviceImageFormatProperties2", 3, true, nil}
var GetPhysicalDeviceImageFormatProperties2KHR = GetPhysicalDeviceImageFormatProperties2

// GetPhysicalDeviceMemoryProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMemoryProperties.html
func GetPhysicalDeviceMemoryProperties(physicalDevice PhysicalDevice) (memoryProperties PhysicalDeviceMemoryProperties) {
	// memoryProperties is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMemoryProperties := &memoryProperties

	execTrampoline(vkGetPhysicalDeviceMemoryProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(ptr_pMemoryProperties)))

	return
}

var vkGetPhysicalDeviceMemoryProperties = &vkCommand{"vkGetPhysicalDeviceMemoryProperties", 2, true, nil}

// GetPhysicalDeviceMemoryProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMemoryProperties2.html
func GetPhysicalDeviceMemoryProperties2(physicalDevice PhysicalDevice) (memoryProperties PhysicalDeviceMemoryProperties2) {
	// memoryProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryProperties *_vkPhysicalDeviceMemoryProperties2 = memoryProperties.Vulkanize()

	execTrampoline(vkGetPhysicalDeviceMemoryProperties2, uintptr(physicalDevice), uintptr(unsafe.Pointer(pMemoryProperties)))

	memoryProperties = *(pMemoryProperties.Goify())
	return
}

var vkGetPhysicalDeviceMemoryProperties2 = &vkCommand{"vkGetPhysicalDeviceMemoryProperties2", 2, true, nil}
var GetPhysicalDeviceMemoryProperties2KHR = GetPhysicalDeviceMemoryProperties2

// GetPhysicalDeviceMultisamplePropertiesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMultisamplePropertiesEXT.html
func GetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice PhysicalDevice, samples SampleCountFlagBits) (multisampleProperties MultisamplePropertiesEXT) {
	// multisampleProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMultisampleProperties *_vkMultisamplePropertiesEXT = multisampleProperties.Vulkanize()

	execTrampoline(vkGetPhysicalDeviceMultisamplePropertiesEXT, uintptr(physicalDevice), uintptr(samples), uintptr(unsafe.Pointer(pMultisampleProperties)))

	multisampleProperties = *(pMultisampleProperties.Goify())
	return
}

var vkGetPhysicalDeviceMultisamplePropertiesEXT = &vkCommand{"vkGetPhysicalDeviceMultisamplePropertiesEXT", 3, true, nil}

// GetPhysicalDeviceOpticalFlowImageFormatsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceOpticalFlowImageFormatsNV.html
func GetPhysicalDeviceOpticalFlowImageFormatsNV(physicalDevice PhysicalDevice, opticalFlowImageFormatInfo *OpticalFlowImageFormatInfoNV) (imageFormatProperties []OpticalFlowImageFormatPropertiesNV, r error) {
	// Parameter is a singular input, requires translation - opticalFlowImageFormatInfo
	var pOpticalFlowImageFormatInfo *_vkOpticalFlowImageFormatInfoNV
	if opticalFlowImageFormatInfo != nil {
		pOpticalFlowImageFormatInfo = opticalFlowImageFormatInfo.Vulkanize()
	}

	// imageFormatProperties is a double-call array output
	var formatCount uint32
	pFormatCount := &formatCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pImageFormatProperties *_vkOpticalFlowImageFormatPropertiesNV

	r = Result(execTrampoline(vkGetPhysicalDeviceOpticalFlowImageFormatsNV, uintptr(physicalDevice), uintptr(unsafe.Pointer(pOpticalFlowImageFormatInfo)), uintptr(unsafe.Pointer(pFormatCount)), uintptr(unsafe.Pointer(pImageFormatProperties))))

	sl_pImageFormatProperties := make([]_vkOpticalFlowImageFormatPropertiesNV, formatCount)
	imageFormatProperties = make([]OpticalFlowImageFormatPropertiesNV, formatCount)
	pImageFormatProperties = &sl_pImageFormatProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDeviceOpticalFlowImageFormatsNV, uintptr(physicalDevice), uintptr(unsafe.Pointer(pOpticalFlowImageFormatInfo)), uintptr(unsafe.Pointer(pFormatCount)), uintptr(unsafe.Pointer(pImageFormatProperties))))

	for i := range sl_pImageFormatProperties {
		imageFormatProperties[i] = *sl_pImageFormatProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceOpticalFlowImageFormatsNV = &vkCommand{"vkGetPhysicalDeviceOpticalFlowImageFormatsNV", 4, true, nil}

// GetPhysicalDevicePresentRectanglesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDevicePresentRectanglesKHR.html
func GetPhysicalDevicePresentRectanglesKHR(physicalDevice PhysicalDevice, surface SurfaceKHR) (rects []Rect2D, r error) {
	// rects is a double-call array output
	var rectCount uint32
	pRectCount := &rectCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pRects *_vkRect2D

	r = Result(execTrampoline(vkGetPhysicalDevicePresentRectanglesKHR, uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pRectCount)), uintptr(unsafe.Pointer(pRects))))

	sl_pRects := make([]_vkRect2D, rectCount)
	rects = make([]Rect2D, rectCount)
	pRects = &sl_pRects[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDevicePresentRectanglesKHR, uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pRectCount)), uintptr(unsafe.Pointer(pRects))))

	for i := range sl_pRects {
		rects[i] = *sl_pRects[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDevicePresentRectanglesKHR = &vkCommand{"vkGetPhysicalDevicePresentRectanglesKHR", 4, true, nil}

// GetPhysicalDeviceProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceProperties.html
func GetPhysicalDeviceProperties(physicalDevice PhysicalDevice) (properties PhysicalDeviceProperties) {
	// properties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pProperties *_vkPhysicalDeviceProperties = properties.Vulkanize()

	execTrampoline(vkGetPhysicalDeviceProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pProperties)))

	properties = *(pProperties.Goify())
	return
}

var vkGetPhysicalDeviceProperties = &vkCommand{"vkGetPhysicalDeviceProperties", 2, true, nil}

// GetPhysicalDeviceProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceProperties2.html
func GetPhysicalDeviceProperties2(physicalDevice PhysicalDevice) (properties PhysicalDeviceProperties2) {
	// properties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pProperties *_vkPhysicalDeviceProperties2 = properties.Vulkanize()

	execTrampoline(vkGetPhysicalDeviceProperties2, uintptr(physicalDevice), uintptr(unsafe.Pointer(pProperties)))

	properties = *(pProperties.Goify())
	return
}

var vkGetPhysicalDeviceProperties2 = &vkCommand{"vkGetPhysicalDeviceProperties2", 2, true, nil}
var GetPhysicalDeviceProperties2KHR = GetPhysicalDeviceProperties2

// GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR.html
func GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice PhysicalDevice, performanceQueryCreateInfo *QueryPoolPerformanceCreateInfoKHR) (numPasses uint32) {
	// Parameter is a singular input, requires translation - performanceQueryCreateInfo
	var pPerformanceQueryCreateInfo *_vkQueryPoolPerformanceCreateInfoKHR
	if performanceQueryCreateInfo != nil {
		pPerformanceQueryCreateInfo = performanceQueryCreateInfo.Vulkanize()
	}

	// numPasses is a binding-allocated single return value and will be populated by Vulkan
	ptr_pNumPasses := &numPasses

	execTrampoline(vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPerformanceQueryCreateInfo)), uintptr(unsafe.Pointer(ptr_pNumPasses)))

	return
}

var vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = &vkCommand{"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR", 3, true, nil}

// GetPhysicalDeviceQueueFamilyProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties.html
func GetPhysicalDeviceQueueFamilyProperties(physicalDevice PhysicalDevice) (queueFamilyProperties []QueueFamilyProperties) {
	// queueFamilyProperties is a double-call array output
	var queueFamilyPropertyCount uint32
	pQueueFamilyPropertyCount := &queueFamilyPropertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pQueueFamilyProperties *_vkQueueFamilyProperties

	execTrampoline(vkGetPhysicalDeviceQueueFamilyProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pQueueFamilyPropertyCount)), uintptr(unsafe.Pointer(pQueueFamilyProperties)))

	sl_pQueueFamilyProperties := make([]_vkQueueFamilyProperties, queueFamilyPropertyCount)
	queueFamilyProperties = make([]QueueFamilyProperties, queueFamilyPropertyCount)
	pQueueFamilyProperties = &sl_pQueueFamilyProperties[0]

	// Trampoline call after last array allocation
	execTrampoline(vkGetPhysicalDeviceQueueFamilyProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pQueueFamilyPropertyCount)), uintptr(unsafe.Pointer(pQueueFamilyProperties)))

	for i := range sl_pQueueFamilyProperties {
		queueFamilyProperties[i] = *sl_pQueueFamilyProperties[i].Goify()
	}
	return
}

var vkGetPhysicalDeviceQueueFamilyProperties = &vkCommand{"vkGetPhysicalDeviceQueueFamilyProperties", 3, true, nil}

// GetPhysicalDeviceQueueFamilyProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties2.html
func GetPhysicalDeviceQueueFamilyProperties2(physicalDevice PhysicalDevice) (queueFamilyProperties []QueueFamilyProperties2) {
	// queueFamilyProperties is a double-call array output
	var queueFamilyPropertyCount uint32
	pQueueFamilyPropertyCount := &queueFamilyPropertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pQueueFamilyProperties *_vkQueueFamilyProperties2

	execTrampoline(vkGetPhysicalDeviceQueueFamilyProperties2, uintptr(physicalDevice), uintptr(unsafe.Pointer(pQueueFamilyPropertyCount)), uintptr(unsafe.Pointer(pQueueFamilyProperties)))

	sl_pQueueFamilyProperties := make([]_vkQueueFamilyProperties2, queueFamilyPropertyCount)
	queueFamilyProperties = make([]QueueFamilyProperties2, queueFamilyPropertyCount)
	pQueueFamilyProperties = &sl_pQueueFamilyProperties[0]

	// Trampoline call after last array allocation
	execTrampoline(vkGetPhysicalDeviceQueueFamilyProperties2, uintptr(physicalDevice), uintptr(unsafe.Pointer(pQueueFamilyPropertyCount)), uintptr(unsafe.Pointer(pQueueFamilyProperties)))

	for i := range sl_pQueueFamilyProperties {
		queueFamilyProperties[i] = *sl_pQueueFamilyProperties[i].Goify()
	}
	return
}

var vkGetPhysicalDeviceQueueFamilyProperties2 = &vkCommand{"vkGetPhysicalDeviceQueueFamilyProperties2", 3, true, nil}
var GetPhysicalDeviceQueueFamilyProperties2KHR = GetPhysicalDeviceQueueFamilyProperties2

// GetPhysicalDeviceRefreshableObjectTypesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceRefreshableObjectTypesKHR.html
func GetPhysicalDeviceRefreshableObjectTypesKHR(physicalDevice PhysicalDevice) (refreshableObjectTypes []ObjectType, r error) {
	// refreshableObjectTypes is a double-call array output
	var refreshableObjectTypeCount uint32
	pRefreshableObjectTypeCount := &refreshableObjectTypeCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pRefreshableObjectTypes *ObjectType

	r = Result(execTrampoline(vkGetPhysicalDeviceRefreshableObjectTypesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pRefreshableObjectTypeCount)), uintptr(unsafe.Pointer(pRefreshableObjectTypes))))

	sl_pRefreshableObjectTypes := make([]ObjectType, refreshableObjectTypeCount)
	refreshableObjectTypes = make([]ObjectType, refreshableObjectTypeCount)
	pRefreshableObjectTypes = &sl_pRefreshableObjectTypes[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDeviceRefreshableObjectTypesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pRefreshableObjectTypeCount)), uintptr(unsafe.Pointer(pRefreshableObjectTypes))))

	for i := range sl_pRefreshableObjectTypes {
		refreshableObjectTypes[i] = *&sl_pRefreshableObjectTypes[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceRefreshableObjectTypesKHR = &vkCommand{"vkGetPhysicalDeviceRefreshableObjectTypesKHR", 3, true, nil}

// GetPhysicalDeviceSparseImageFormatProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties.html
func GetPhysicalDeviceSparseImageFormatProperties(physicalDevice PhysicalDevice, format Format, typ ImageType, samples SampleCountFlagBits, usage ImageUsageFlags, tiling ImageTiling) (properties []SparseImageFormatProperties) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkSparseImageFormatProperties

	execTrampoline(vkGetPhysicalDeviceSparseImageFormatProperties, uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(samples), uintptr(usage), uintptr(tiling), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))

	sl_pProperties := make([]_vkSparseImageFormatProperties, propertyCount)
	properties = make([]SparseImageFormatProperties, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	execTrampoline(vkGetPhysicalDeviceSparseImageFormatProperties, uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(samples), uintptr(usage), uintptr(tiling), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

var vkGetPhysicalDeviceSparseImageFormatProperties = &vkCommand{"vkGetPhysicalDeviceSparseImageFormatProperties", 8, true, nil}

// GetPhysicalDeviceSparseImageFormatProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2.html
func GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice PhysicalDevice, formatInfo *PhysicalDeviceSparseImageFormatInfo2) (properties []SparseImageFormatProperties2) {
	// Parameter is a singular input, requires translation - formatInfo
	var pFormatInfo *_vkPhysicalDeviceSparseImageFormatInfo2
	if formatInfo != nil {
		pFormatInfo = formatInfo.Vulkanize()
	}

	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkSparseImageFormatProperties2

	execTrampoline(vkGetPhysicalDeviceSparseImageFormatProperties2, uintptr(physicalDevice), uintptr(unsafe.Pointer(pFormatInfo)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))

	sl_pProperties := make([]_vkSparseImageFormatProperties2, propertyCount)
	properties = make([]SparseImageFormatProperties2, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	execTrampoline(vkGetPhysicalDeviceSparseImageFormatProperties2, uintptr(physicalDevice), uintptr(unsafe.Pointer(pFormatInfo)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

var vkGetPhysicalDeviceSparseImageFormatProperties2 = &vkCommand{"vkGetPhysicalDeviceSparseImageFormatProperties2", 4, true, nil}
var GetPhysicalDeviceSparseImageFormatProperties2KHR = GetPhysicalDeviceSparseImageFormatProperties2

// GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.html
func GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice PhysicalDevice) (combinations []FramebufferMixedSamplesCombinationNV, r error) {
	// combinations is a double-call array output
	var combinationCount uint32
	pCombinationCount := &combinationCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pCombinations *_vkFramebufferMixedSamplesCombinationNV

	r = Result(execTrampoline(vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV, uintptr(physicalDevice), uintptr(unsafe.Pointer(pCombinationCount)), uintptr(unsafe.Pointer(pCombinations))))

	sl_pCombinations := make([]_vkFramebufferMixedSamplesCombinationNV, combinationCount)
	combinations = make([]FramebufferMixedSamplesCombinationNV, combinationCount)
	pCombinations = &sl_pCombinations[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV, uintptr(physicalDevice), uintptr(unsafe.Pointer(pCombinationCount)), uintptr(unsafe.Pointer(pCombinations))))

	for i := range sl_pCombinations {
		combinations[i] = *sl_pCombinations[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = &vkCommand{"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", 3, true, nil}

// GetPhysicalDeviceSurfaceCapabilities2EXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilities2EXT.html
func GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice PhysicalDevice, surface SurfaceKHR) (surfaceCapabilities SurfaceCapabilities2EXT, r error) {
	// surfaceCapabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSurfaceCapabilities *_vkSurfaceCapabilities2EXT = surfaceCapabilities.Vulkanize()

	r = Result(execTrampoline(vkGetPhysicalDeviceSurfaceCapabilities2EXT, uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pSurfaceCapabilities))))

	surfaceCapabilities = *(pSurfaceCapabilities.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSurfaceCapabilities2EXT = &vkCommand{"vkGetPhysicalDeviceSurfaceCapabilities2EXT", 3, true, nil}

// GetPhysicalDeviceSurfaceCapabilities2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilities2KHR.html
func GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice PhysicalDevice, surfaceInfo *PhysicalDeviceSurfaceInfo2KHR) (surfaceCapabilities SurfaceCapabilities2KHR, r error) {
	// Parameter is a singular input, requires translation - surfaceInfo
	var pSurfaceInfo *_vkPhysicalDeviceSurfaceInfo2KHR
	if surfaceInfo != nil {
		pSurfaceInfo = surfaceInfo.Vulkanize()
	}

	// surfaceCapabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSurfaceCapabilities *_vkSurfaceCapabilities2KHR = surfaceCapabilities.Vulkanize()

	r = Result(execTrampoline(vkGetPhysicalDeviceSurfaceCapabilities2KHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pSurfaceInfo)), uintptr(unsafe.Pointer(pSurfaceCapabilities))))

	surfaceCapabilities = *(pSurfaceCapabilities.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSurfaceCapabilities2KHR = &vkCommand{"vkGetPhysicalDeviceSurfaceCapabilities2KHR", 3, true, nil}

// GetPhysicalDeviceSurfaceCapabilitiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilitiesKHR.html
func GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice PhysicalDevice, surface SurfaceKHR) (surfaceCapabilities SurfaceCapabilitiesKHR, r error) {
	// surfaceCapabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSurfaceCapabilities *_vkSurfaceCapabilitiesKHR = surfaceCapabilities.Vulkanize()

	r = Result(execTrampoline(vkGetPhysicalDeviceSurfaceCapabilitiesKHR, uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pSurfaceCapabilities))))

	surfaceCapabilities = *(pSurfaceCapabilities.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSurfaceCapabilitiesKHR = &vkCommand{"vkGetPhysicalDeviceSurfaceCapabilitiesKHR", 3, true, nil}

// GetPhysicalDeviceSurfaceFormats2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceFormats2KHR.html
func GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice PhysicalDevice, surfaceInfo *PhysicalDeviceSurfaceInfo2KHR) (surfaceFormats []SurfaceFormat2KHR, r error) {
	// Parameter is a singular input, requires translation - surfaceInfo
	var pSurfaceInfo *_vkPhysicalDeviceSurfaceInfo2KHR
	if surfaceInfo != nil {
		pSurfaceInfo = surfaceInfo.Vulkanize()
	}

	// surfaceFormats is a double-call array output
	var surfaceFormatCount uint32
	pSurfaceFormatCount := &surfaceFormatCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSurfaceFormats *_vkSurfaceFormat2KHR

	r = Result(execTrampoline(vkGetPhysicalDeviceSurfaceFormats2KHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pSurfaceInfo)), uintptr(unsafe.Pointer(pSurfaceFormatCount)), uintptr(unsafe.Pointer(pSurfaceFormats))))

	sl_pSurfaceFormats := make([]_vkSurfaceFormat2KHR, surfaceFormatCount)
	surfaceFormats = make([]SurfaceFormat2KHR, surfaceFormatCount)
	pSurfaceFormats = &sl_pSurfaceFormats[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDeviceSurfaceFormats2KHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pSurfaceInfo)), uintptr(unsafe.Pointer(pSurfaceFormatCount)), uintptr(unsafe.Pointer(pSurfaceFormats))))

	for i := range sl_pSurfaceFormats {
		surfaceFormats[i] = *sl_pSurfaceFormats[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSurfaceFormats2KHR = &vkCommand{"vkGetPhysicalDeviceSurfaceFormats2KHR", 4, true, nil}

// GetPhysicalDeviceSurfaceFormatsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceFormatsKHR.html
func GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice PhysicalDevice, surface SurfaceKHR) (surfaceFormats []SurfaceFormatKHR, r error) {
	// surfaceFormats is a double-call array output
	var surfaceFormatCount uint32
	pSurfaceFormatCount := &surfaceFormatCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSurfaceFormats *_vkSurfaceFormatKHR

	r = Result(execTrampoline(vkGetPhysicalDeviceSurfaceFormatsKHR, uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pSurfaceFormatCount)), uintptr(unsafe.Pointer(pSurfaceFormats))))

	sl_pSurfaceFormats := make([]_vkSurfaceFormatKHR, surfaceFormatCount)
	surfaceFormats = make([]SurfaceFormatKHR, surfaceFormatCount)
	pSurfaceFormats = &sl_pSurfaceFormats[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDeviceSurfaceFormatsKHR, uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pSurfaceFormatCount)), uintptr(unsafe.Pointer(pSurfaceFormats))))

	for i := range sl_pSurfaceFormats {
		surfaceFormats[i] = *sl_pSurfaceFormats[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSurfaceFormatsKHR = &vkCommand{"vkGetPhysicalDeviceSurfaceFormatsKHR", 4, true, nil}

// GetPhysicalDeviceSurfacePresentModesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfacePresentModesKHR.html
func GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice PhysicalDevice, surface SurfaceKHR) (presentModes []PresentModeKHR, r error) {
	// presentModes is a double-call array output
	var presentModeCount uint32
	pPresentModeCount := &presentModeCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pPresentModes *PresentModeKHR

	r = Result(execTrampoline(vkGetPhysicalDeviceSurfacePresentModesKHR, uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pPresentModeCount)), uintptr(unsafe.Pointer(pPresentModes))))

	sl_pPresentModes := make([]PresentModeKHR, presentModeCount)
	presentModes = make([]PresentModeKHR, presentModeCount)
	pPresentModes = &sl_pPresentModes[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDeviceSurfacePresentModesKHR, uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pPresentModeCount)), uintptr(unsafe.Pointer(pPresentModes))))

	for i := range sl_pPresentModes {
		presentModes[i] = *&sl_pPresentModes[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSurfacePresentModesKHR = &vkCommand{"vkGetPhysicalDeviceSurfacePresentModesKHR", 4, true, nil}

// GetPhysicalDeviceSurfaceSupportKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html
func GetPhysicalDeviceSurfaceSupportKHR(physicalDevice PhysicalDevice, queueFamilyIndex uint32, surface SurfaceKHR) (supported bool, r error) {
	// supported is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var internal_supported Bool32 = translateInternal_Bool32(supported)
	var pSupported = &internal_supported

	r = Result(execTrampoline(vkGetPhysicalDeviceSurfaceSupportKHR, uintptr(physicalDevice), uintptr(queueFamilyIndex), uintptr(surface), uintptr(unsafe.Pointer(pSupported))))

	supported = translatePublic_Bool32(internal_supported)
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSurfaceSupportKHR = &vkCommand{"vkGetPhysicalDeviceSurfaceSupportKHR", 4, true, nil}

// GetPhysicalDeviceToolProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceToolProperties.html
func GetPhysicalDeviceToolProperties(physicalDevice PhysicalDevice) (toolProperties []PhysicalDeviceToolProperties, r error) {
	// toolProperties is a double-call array output
	var toolCount uint32
	pToolCount := &toolCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pToolProperties *_vkPhysicalDeviceToolProperties

	r = Result(execTrampoline(vkGetPhysicalDeviceToolProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pToolCount)), uintptr(unsafe.Pointer(pToolProperties))))

	sl_pToolProperties := make([]_vkPhysicalDeviceToolProperties, toolCount)
	toolProperties = make([]PhysicalDeviceToolProperties, toolCount)
	pToolProperties = &sl_pToolProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDeviceToolProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pToolCount)), uintptr(unsafe.Pointer(pToolProperties))))

	for i := range sl_pToolProperties {
		toolProperties[i] = *sl_pToolProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceToolProperties = &vkCommand{"vkGetPhysicalDeviceToolProperties", 3, true, nil}
var GetPhysicalDeviceToolPropertiesEXT = GetPhysicalDeviceToolProperties

// GetPhysicalDeviceVideoCapabilitiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceVideoCapabilitiesKHR.html
func GetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice PhysicalDevice, videoProfile *VideoProfileInfoKHR) (capabilities VideoCapabilitiesKHR, r error) {
	// Parameter is a singular input, requires translation - videoProfile
	var pVideoProfile *_vkVideoProfileInfoKHR
	if videoProfile != nil {
		pVideoProfile = videoProfile.Vulkanize()
	}

	// capabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pCapabilities *_vkVideoCapabilitiesKHR = capabilities.Vulkanize()

	r = Result(execTrampoline(vkGetPhysicalDeviceVideoCapabilitiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pVideoProfile)), uintptr(unsafe.Pointer(pCapabilities))))

	capabilities = *(pCapabilities.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceVideoCapabilitiesKHR = &vkCommand{"vkGetPhysicalDeviceVideoCapabilitiesKHR", 3, true, nil}

// GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR.html
func GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(physicalDevice PhysicalDevice, qualityLevelInfo *PhysicalDeviceVideoEncodeQualityLevelInfoKHR) (qualityLevelProperties VideoEncodeQualityLevelPropertiesKHR, r error) {
	// Parameter is a singular input, requires translation - qualityLevelInfo
	var pQualityLevelInfo *_vkPhysicalDeviceVideoEncodeQualityLevelInfoKHR
	if qualityLevelInfo != nil {
		pQualityLevelInfo = qualityLevelInfo.Vulkanize()
	}

	// qualityLevelProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pQualityLevelProperties *_vkVideoEncodeQualityLevelPropertiesKHR = qualityLevelProperties.Vulkanize()

	r = Result(execTrampoline(vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pQualityLevelInfo)), uintptr(unsafe.Pointer(pQualityLevelProperties))))

	qualityLevelProperties = *(pQualityLevelProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = &vkCommand{"vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR", 3, true, nil}

// GetPhysicalDeviceVideoFormatPropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceVideoFormatPropertiesKHR.html
func GetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice PhysicalDevice, videoFormatInfo *PhysicalDeviceVideoFormatInfoKHR) (videoFormatProperties []VideoFormatPropertiesKHR, r error) {
	// Parameter is a singular input, requires translation - videoFormatInfo
	var pVideoFormatInfo *_vkPhysicalDeviceVideoFormatInfoKHR
	if videoFormatInfo != nil {
		pVideoFormatInfo = videoFormatInfo.Vulkanize()
	}

	// videoFormatProperties is a double-call array output
	var videoFormatPropertyCount uint32
	pVideoFormatPropertyCount := &videoFormatPropertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pVideoFormatProperties *_vkVideoFormatPropertiesKHR

	r = Result(execTrampoline(vkGetPhysicalDeviceVideoFormatPropertiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pVideoFormatInfo)), uintptr(unsafe.Pointer(pVideoFormatPropertyCount)), uintptr(unsafe.Pointer(pVideoFormatProperties))))

	sl_pVideoFormatProperties := make([]_vkVideoFormatPropertiesKHR, videoFormatPropertyCount)
	videoFormatProperties = make([]VideoFormatPropertiesKHR, videoFormatPropertyCount)
	pVideoFormatProperties = &sl_pVideoFormatProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPhysicalDeviceVideoFormatPropertiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pVideoFormatInfo)), uintptr(unsafe.Pointer(pVideoFormatPropertyCount)), uintptr(unsafe.Pointer(pVideoFormatProperties))))

	for i := range sl_pVideoFormatProperties {
		videoFormatProperties[i] = *sl_pVideoFormatProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceVideoFormatPropertiesKHR = &vkCommand{"vkGetPhysicalDeviceVideoFormatPropertiesKHR", 4, true, nil}

// GetPipelineCacheData: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineCacheData.html
func GetPipelineCacheData(device Device, pipelineCache PipelineCache) (data []byte, r error) {
	// data is a double-call array output
	var dataSize uintptr
	pDataSize := &dataSize
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pData *byte

	r = Result(execTrampoline(vkGetPipelineCacheData, uintptr(device), uintptr(pipelineCache), uintptr(unsafe.Pointer(pDataSize)), uintptr(unsafe.Pointer(pData))))

	sl_pData := make([]byte, dataSize)
	data = make([]byte, dataSize)
	pData = &sl_pData[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPipelineCacheData, uintptr(device), uintptr(pipelineCache), uintptr(unsafe.Pointer(pDataSize)), uintptr(unsafe.Pointer(pData))))

	for i := range sl_pData {
		data[i] = *&sl_pData[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPipelineCacheData = &vkCommand{"vkGetPipelineCacheData", 4, true, nil}

// GetPipelineExecutableInternalRepresentationsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineExecutableInternalRepresentationsKHR.html
func GetPipelineExecutableInternalRepresentationsKHR(device Device, executableInfo *PipelineExecutableInfoKHR) (internalRepresentations []PipelineExecutableInternalRepresentationKHR, r error) {
	// Parameter is a singular input, requires translation - executableInfo
	var pExecutableInfo *_vkPipelineExecutableInfoKHR
	if executableInfo != nil {
		pExecutableInfo = executableInfo.Vulkanize()
	}

	// internalRepresentations is a double-call array output
	var internalRepresentationCount uint32
	pInternalRepresentationCount := &internalRepresentationCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pInternalRepresentations *_vkPipelineExecutableInternalRepresentationKHR

	r = Result(execTrampoline(vkGetPipelineExecutableInternalRepresentationsKHR, uintptr(device), uintptr(unsafe.Pointer(pExecutableInfo)), uintptr(unsafe.Pointer(pInternalRepresentationCount)), uintptr(unsafe.Pointer(pInternalRepresentations))))

	sl_pInternalRepresentations := make([]_vkPipelineExecutableInternalRepresentationKHR, internalRepresentationCount)
	internalRepresentations = make([]PipelineExecutableInternalRepresentationKHR, internalRepresentationCount)
	pInternalRepresentations = &sl_pInternalRepresentations[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPipelineExecutableInternalRepresentationsKHR, uintptr(device), uintptr(unsafe.Pointer(pExecutableInfo)), uintptr(unsafe.Pointer(pInternalRepresentationCount)), uintptr(unsafe.Pointer(pInternalRepresentations))))

	for i := range sl_pInternalRepresentations {
		internalRepresentations[i] = *sl_pInternalRepresentations[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPipelineExecutableInternalRepresentationsKHR = &vkCommand{"vkGetPipelineExecutableInternalRepresentationsKHR", 4, true, nil}

// GetPipelineExecutablePropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineExecutablePropertiesKHR.html
func GetPipelineExecutablePropertiesKHR(device Device, pipelineInfo *PipelineInfoKHR) (properties []PipelineExecutablePropertiesKHR, r error) {
	// Parameter is a singular input, requires translation - pipelineInfo
	var pPipelineInfo *_vkPipelineInfoKHR
	if pipelineInfo != nil {
		pPipelineInfo = pipelineInfo.Vulkanize()
	}

	// properties is a double-call array output
	var executableCount uint32
	pExecutableCount := &executableCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkPipelineExecutablePropertiesKHR

	r = Result(execTrampoline(vkGetPipelineExecutablePropertiesKHR, uintptr(device), uintptr(unsafe.Pointer(pPipelineInfo)), uintptr(unsafe.Pointer(pExecutableCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkPipelineExecutablePropertiesKHR, executableCount)
	properties = make([]PipelineExecutablePropertiesKHR, executableCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPipelineExecutablePropertiesKHR, uintptr(device), uintptr(unsafe.Pointer(pPipelineInfo)), uintptr(unsafe.Pointer(pExecutableCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPipelineExecutablePropertiesKHR = &vkCommand{"vkGetPipelineExecutablePropertiesKHR", 4, true, nil}

// GetPipelineExecutableStatisticsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineExecutableStatisticsKHR.html
func GetPipelineExecutableStatisticsKHR(device Device, executableInfo *PipelineExecutableInfoKHR) (statistics []PipelineExecutableStatisticKHR, r error) {
	// Parameter is a singular input, requires translation - executableInfo
	var pExecutableInfo *_vkPipelineExecutableInfoKHR
	if executableInfo != nil {
		pExecutableInfo = executableInfo.Vulkanize()
	}

	// statistics is a double-call array output
	var statisticCount uint32
	pStatisticCount := &statisticCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pStatistics *_vkPipelineExecutableStatisticKHR

	r = Result(execTrampoline(vkGetPipelineExecutableStatisticsKHR, uintptr(device), uintptr(unsafe.Pointer(pExecutableInfo)), uintptr(unsafe.Pointer(pStatisticCount)), uintptr(unsafe.Pointer(pStatistics))))

	sl_pStatistics := make([]_vkPipelineExecutableStatisticKHR, statisticCount)
	statistics = make([]PipelineExecutableStatisticKHR, statisticCount)
	pStatistics = &sl_pStatistics[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetPipelineExecutableStatisticsKHR, uintptr(device), uintptr(unsafe.Pointer(pExecutableInfo)), uintptr(unsafe.Pointer(pStatisticCount)), uintptr(unsafe.Pointer(pStatistics))))

	for i := range sl_pStatistics {
		statistics[i] = *sl_pStatistics[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPipelineExecutableStatisticsKHR = &vkCommand{"vkGetPipelineExecutableStatisticsKHR", 4, true, nil}

// GetPipelineIndirectDeviceAddressNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineIndirectDeviceAddressNV.html
func GetPipelineIndirectDeviceAddressNV(device Device, info *PipelineIndirectDeviceAddressInfoNV) (deviceAddress DeviceAddress) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkPipelineIndirectDeviceAddressInfoNV
	if info != nil {
		pInfo = info.Vulkanize()
	}

	deviceAddress = DeviceAddress(execTrampoline(vkGetPipelineIndirectDeviceAddressNV, uintptr(device), uintptr(unsafe.Pointer(pInfo))))

	return
}

var vkGetPipelineIndirectDeviceAddressNV = &vkCommand{"vkGetPipelineIndirectDeviceAddressNV", 2, true, nil}

// GetPipelineIndirectMemoryRequirementsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineIndirectMemoryRequirementsNV.html
func GetPipelineIndirectMemoryRequirementsNV(device Device, createInfo *ComputePipelineCreateInfo) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkComputePipelineCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryRequirements *_vkMemoryRequirements2 = memoryRequirements.Vulkanize()

	execTrampoline(vkGetPipelineIndirectMemoryRequirementsNV, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pMemoryRequirements)))

	memoryRequirements = *(pMemoryRequirements.Goify())
	return
}

var vkGetPipelineIndirectMemoryRequirementsNV = &vkCommand{"vkGetPipelineIndirectMemoryRequirementsNV", 3, true, nil}

// GetPipelinePropertiesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelinePropertiesEXT.html
func GetPipelinePropertiesEXT(device Device, pipelineInfo *PipelineInfoEXT) (pipelineProperties BaseOutStructure, r error) {
	// Parameter is a singular input, pass direct - pipelineInfo
	var pPipelineInfo unsafe.Pointer
	if pipelineInfo != nil {
		pPipelineInfo = unsafe.Pointer(pipelineInfo)
	}

	// pipelineProperties is a binding-allocated single return value and will be populated by Vulkan
	ptr_pPipelineProperties := &pipelineProperties

	r = Result(execTrampoline(vkGetPipelinePropertiesEXT, uintptr(device), uintptr(unsafe.Pointer(pPipelineInfo)), uintptr(unsafe.Pointer(ptr_pPipelineProperties))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPipelinePropertiesEXT = &vkCommand{"vkGetPipelinePropertiesEXT", 3, true, nil}

// GetPrivateData: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPrivateData.html
func GetPrivateData(device Device, objectType ObjectType, objectHandle uint64, privateDataSlot PrivateDataSlot) (data uint64) {
	// data is a binding-allocated single return value and will be populated by Vulkan
	ptr_pData := &data

	execTrampoline(vkGetPrivateData, uintptr(device), uintptr(objectType), uintptr(objectHandle), uintptr(privateDataSlot), uintptr(unsafe.Pointer(ptr_pData)))

	return
}

var vkGetPrivateData = &vkCommand{"vkGetPrivateData", 5, true, nil}
var GetPrivateDataEXT = GetPrivateData

// GetQueryPoolResults: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetQueryPoolResults.html
func GetQueryPoolResults(device Device, queryPool QueryPool, firstQuery uint32, queryCount uint32, data []byte, stride DeviceSize, flags QueryResultFlags) (r error) {
	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	r = Result(execTrampoline(vkGetQueryPoolResults, uintptr(device), uintptr(queryPool), uintptr(firstQuery), uintptr(queryCount), uintptr(dataSize), uintptr(unsafe.Pointer(pData)), uintptr(stride), uintptr(flags)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetQueryPoolResults = &vkCommand{"vkGetQueryPoolResults", 8, true, nil}

// GetQueueCheckpointData2NV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetQueueCheckpointData2NV.html
func GetQueueCheckpointData2NV(queue Queue) (checkpointData []CheckpointData2NV) {
	// checkpointData is a double-call array output
	var checkpointDataCount uint32
	pCheckpointDataCount := &checkpointDataCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pCheckpointData *_vkCheckpointData2NV

	execTrampoline(vkGetQueueCheckpointData2NV, uintptr(queue), uintptr(unsafe.Pointer(pCheckpointDataCount)), uintptr(unsafe.Pointer(pCheckpointData)))

	sl_pCheckpointData := make([]_vkCheckpointData2NV, checkpointDataCount)
	checkpointData = make([]CheckpointData2NV, checkpointDataCount)
	pCheckpointData = &sl_pCheckpointData[0]

	// Trampoline call after last array allocation
	execTrampoline(vkGetQueueCheckpointData2NV, uintptr(queue), uintptr(unsafe.Pointer(pCheckpointDataCount)), uintptr(unsafe.Pointer(pCheckpointData)))

	for i := range sl_pCheckpointData {
		checkpointData[i] = *sl_pCheckpointData[i].Goify()
	}
	return
}

var vkGetQueueCheckpointData2NV = &vkCommand{"vkGetQueueCheckpointData2NV", 3, true, nil}

// GetQueueCheckpointDataNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetQueueCheckpointDataNV.html
func GetQueueCheckpointDataNV(queue Queue) (checkpointData []CheckpointDataNV) {
	// checkpointData is a double-call array output
	var checkpointDataCount uint32
	pCheckpointDataCount := &checkpointDataCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pCheckpointData *_vkCheckpointDataNV

	execTrampoline(vkGetQueueCheckpointDataNV, uintptr(queue), uintptr(unsafe.Pointer(pCheckpointDataCount)), uintptr(unsafe.Pointer(pCheckpointData)))

	sl_pCheckpointData := make([]_vkCheckpointDataNV, checkpointDataCount)
	checkpointData = make([]CheckpointDataNV, checkpointDataCount)
	pCheckpointData = &sl_pCheckpointData[0]

	// Trampoline call after last array allocation
	execTrampoline(vkGetQueueCheckpointDataNV, uintptr(queue), uintptr(unsafe.Pointer(pCheckpointDataCount)), uintptr(unsafe.Pointer(pCheckpointData)))

	for i := range sl_pCheckpointData {
		checkpointData[i] = *sl_pCheckpointData[i].Goify()
	}
	return
}

var vkGetQueueCheckpointDataNV = &vkCommand{"vkGetQueueCheckpointDataNV", 3, true, nil}

// GetRayTracingCaptureReplayShaderGroupHandlesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.html
func GetRayTracingCaptureReplayShaderGroupHandlesKHR(device Device, pipeline Pipeline, firstGroup uint32, groupCount uint32, data []byte) (r error) {
	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	r = Result(execTrampoline(vkGetRayTracingCaptureReplayShaderGroupHandlesKHR, uintptr(device), uintptr(pipeline), uintptr(firstGroup), uintptr(groupCount), uintptr(dataSize), uintptr(unsafe.Pointer(pData))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = &vkCommand{"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR", 6, true, nil}

// GetRayTracingShaderGroupHandlesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRayTracingShaderGroupHandlesKHR.html
func GetRayTracingShaderGroupHandlesKHR(device Device, pipeline Pipeline, firstGroup uint32, groupCount uint32, data []byte) (r error) {
	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	r = Result(execTrampoline(vkGetRayTracingShaderGroupHandlesKHR, uintptr(device), uintptr(pipeline), uintptr(firstGroup), uintptr(groupCount), uintptr(dataSize), uintptr(unsafe.Pointer(pData))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetRayTracingShaderGroupHandlesKHR = &vkCommand{"vkGetRayTracingShaderGroupHandlesKHR", 6, true, nil}
var GetRayTracingShaderGroupHandlesNV = GetRayTracingShaderGroupHandlesKHR

// GetRayTracingShaderGroupStackSizeKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRayTracingShaderGroupStackSizeKHR.html
func GetRayTracingShaderGroupStackSizeKHR(device Device, pipeline Pipeline, group uint32, groupShader ShaderGroupShaderKHR) (deviceSize DeviceSize) {

	deviceSize = DeviceSize(execTrampoline(vkGetRayTracingShaderGroupStackSizeKHR, uintptr(device), uintptr(pipeline), uintptr(group), uintptr(groupShader)))

	return
}

var vkGetRayTracingShaderGroupStackSizeKHR = &vkCommand{"vkGetRayTracingShaderGroupStackSizeKHR", 4, true, nil}

// GetRefreshCycleDurationGOOGLE: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRefreshCycleDurationGOOGLE.html
func GetRefreshCycleDurationGOOGLE(device Device, swapchain SwapchainKHR) (displayTimingProperties RefreshCycleDurationGOOGLE, r error) {
	// displayTimingProperties is a binding-allocated single return value and will be populated by Vulkan
	ptr_pDisplayTimingProperties := &displayTimingProperties

	r = Result(execTrampoline(vkGetRefreshCycleDurationGOOGLE, uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(ptr_pDisplayTimingProperties))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetRefreshCycleDurationGOOGLE = &vkCommand{"vkGetRefreshCycleDurationGOOGLE", 3, true, nil}

// GetRenderAreaGranularity: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRenderAreaGranularity.html
func GetRenderAreaGranularity(device Device, renderPass RenderPass) (granularity Extent2D) {
	// granularity is a binding-allocated single return value and will be populated by Vulkan
	ptr_pGranularity := &granularity

	execTrampoline(vkGetRenderAreaGranularity, uintptr(device), uintptr(renderPass), uintptr(unsafe.Pointer(ptr_pGranularity)))

	return
}

var vkGetRenderAreaGranularity = &vkCommand{"vkGetRenderAreaGranularity", 3, true, nil}

// GetRenderingAreaGranularityKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRenderingAreaGranularityKHR.html
func GetRenderingAreaGranularityKHR(device Device, renderingAreaInfo *RenderingAreaInfoKHR) (granularity Extent2D) {
	// Parameter is a singular input, requires translation - renderingAreaInfo
	var pRenderingAreaInfo *_vkRenderingAreaInfoKHR
	if renderingAreaInfo != nil {
		pRenderingAreaInfo = renderingAreaInfo.Vulkanize()
	}

	// granularity is a binding-allocated single return value and will be populated by Vulkan
	ptr_pGranularity := &granularity

	execTrampoline(vkGetRenderingAreaGranularityKHR, uintptr(device), uintptr(unsafe.Pointer(pRenderingAreaInfo)), uintptr(unsafe.Pointer(ptr_pGranularity)))

	return
}

var vkGetRenderingAreaGranularityKHR = &vkCommand{"vkGetRenderingAreaGranularityKHR", 3, true, nil}

// GetSamplerOpaqueCaptureDescriptorDataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSamplerOpaqueCaptureDescriptorDataEXT.html
func GetSamplerOpaqueCaptureDescriptorDataEXT(device Device, info *SamplerCaptureDescriptorDataInfoEXT) (data byte, r error) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkSamplerCaptureDescriptorDataInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// data is a binding-allocated single return value and will be populated by Vulkan
	ptr_pData := &data

	r = Result(execTrampoline(vkGetSamplerOpaqueCaptureDescriptorDataEXT, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(ptr_pData))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetSamplerOpaqueCaptureDescriptorDataEXT = &vkCommand{"vkGetSamplerOpaqueCaptureDescriptorDataEXT", 3, true, nil}

// GetSemaphoreCounterValue: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreCounterValue.html
func GetSemaphoreCounterValue(device Device, semaphore Semaphore) (value uint64, r error) {
	// value is a binding-allocated single return value and will be populated by Vulkan
	ptr_pValue := &value

	r = Result(execTrampoline(vkGetSemaphoreCounterValue, uintptr(device), uintptr(semaphore), uintptr(unsafe.Pointer(ptr_pValue))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetSemaphoreCounterValue = &vkCommand{"vkGetSemaphoreCounterValue", 3, true, nil}
var GetSemaphoreCounterValueKHR = GetSemaphoreCounterValue

// GetSemaphoreFdKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreFdKHR.html
func GetSemaphoreFdKHR(device Device, getFdInfo *SemaphoreGetFdInfoKHR) (fd int32, r error) {
	// Parameter is a singular input, requires translation - getFdInfo
	var pGetFdInfo *_vkSemaphoreGetFdInfoKHR
	if getFdInfo != nil {
		pGetFdInfo = getFdInfo.Vulkanize()
	}

	// fd is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFd := &fd

	r = Result(execTrampoline(vkGetSemaphoreFdKHR, uintptr(device), uintptr(unsafe.Pointer(pGetFdInfo)), uintptr(unsafe.Pointer(ptr_pFd))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetSemaphoreFdKHR = &vkCommand{"vkGetSemaphoreFdKHR", 3, true, nil}

// GetShaderBinaryDataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetShaderBinaryDataEXT.html
func GetShaderBinaryDataEXT(device Device, shader ShaderEXT) (data []byte, r error) {
	// data is a double-call array output
	var dataSize uintptr
	pDataSize := &dataSize
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pData *byte

	r = Result(execTrampoline(vkGetShaderBinaryDataEXT, uintptr(device), uintptr(shader), uintptr(unsafe.Pointer(pDataSize)), uintptr(unsafe.Pointer(pData))))

	sl_pData := make([]byte, dataSize)
	data = make([]byte, dataSize)
	pData = &sl_pData[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetShaderBinaryDataEXT, uintptr(device), uintptr(shader), uintptr(unsafe.Pointer(pDataSize)), uintptr(unsafe.Pointer(pData))))

	for i := range sl_pData {
		data[i] = *&sl_pData[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetShaderBinaryDataEXT = &vkCommand{"vkGetShaderBinaryDataEXT", 4, true, nil}

// GetShaderInfoAMD: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetShaderInfoAMD.html
func GetShaderInfoAMD(device Device, pipeline Pipeline, shaderStage ShaderStageFlagBits, infoType ShaderInfoTypeAMD) (info []byte, r error) {
	// info is a double-call array output
	var infoSize uintptr
	pInfoSize := &infoSize
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pInfo *byte

	r = Result(execTrampoline(vkGetShaderInfoAMD, uintptr(device), uintptr(pipeline), uintptr(shaderStage), uintptr(infoType), uintptr(unsafe.Pointer(pInfoSize)), uintptr(unsafe.Pointer(pInfo))))

	sl_pInfo := make([]byte, infoSize)
	info = make([]byte, infoSize)
	pInfo = &sl_pInfo[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetShaderInfoAMD, uintptr(device), uintptr(pipeline), uintptr(shaderStage), uintptr(infoType), uintptr(unsafe.Pointer(pInfoSize)), uintptr(unsafe.Pointer(pInfo))))

	for i := range sl_pInfo {
		info[i] = *&sl_pInfo[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetShaderInfoAMD = &vkCommand{"vkGetShaderInfoAMD", 6, true, nil}

// GetShaderModuleCreateInfoIdentifierEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetShaderModuleCreateInfoIdentifierEXT.html
func GetShaderModuleCreateInfoIdentifierEXT(device Device, createInfo *ShaderModuleCreateInfo) (identifier ShaderModuleIdentifierEXT) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkShaderModuleCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// identifier is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pIdentifier *_vkShaderModuleIdentifierEXT = identifier.Vulkanize()

	execTrampoline(vkGetShaderModuleCreateInfoIdentifierEXT, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pIdentifier)))

	identifier = *(pIdentifier.Goify())
	return
}

var vkGetShaderModuleCreateInfoIdentifierEXT = &vkCommand{"vkGetShaderModuleCreateInfoIdentifierEXT", 3, true, nil}

// GetShaderModuleIdentifierEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetShaderModuleIdentifierEXT.html
func GetShaderModuleIdentifierEXT(device Device, shaderModule ShaderModule) (identifier ShaderModuleIdentifierEXT) {
	// identifier is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pIdentifier *_vkShaderModuleIdentifierEXT = identifier.Vulkanize()

	execTrampoline(vkGetShaderModuleIdentifierEXT, uintptr(device), uintptr(shaderModule), uintptr(unsafe.Pointer(pIdentifier)))

	identifier = *(pIdentifier.Goify())
	return
}

var vkGetShaderModuleIdentifierEXT = &vkCommand{"vkGetShaderModuleIdentifierEXT", 3, true, nil}

// GetSwapchainCounterEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainCounterEXT.html
func GetSwapchainCounterEXT(device Device, swapchain SwapchainKHR, counter SurfaceCounterFlagBitsEXT) (counterValue uint64, r error) {
	// counterValue is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCounterValue := &counterValue

	r = Result(execTrampoline(vkGetSwapchainCounterEXT, uintptr(device), uintptr(swapchain), uintptr(counter), uintptr(unsafe.Pointer(ptr_pCounterValue))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetSwapchainCounterEXT = &vkCommand{"vkGetSwapchainCounterEXT", 4, true, nil}

// GetSwapchainImagesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainImagesKHR.html
func GetSwapchainImagesKHR(device Device, swapchain SwapchainKHR) (swapchainImages []Image, r error) {
	// swapchainImages is a double-call array output
	var swapchainImageCount uint32
	pSwapchainImageCount := &swapchainImageCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSwapchainImages *Image

	r = Result(execTrampoline(vkGetSwapchainImagesKHR, uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pSwapchainImageCount)), uintptr(unsafe.Pointer(pSwapchainImages))))

	sl_pSwapchainImages := make([]Image, swapchainImageCount)
	swapchainImages = make([]Image, swapchainImageCount)
	pSwapchainImages = &sl_pSwapchainImages[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetSwapchainImagesKHR, uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pSwapchainImageCount)), uintptr(unsafe.Pointer(pSwapchainImages))))

	for i := range sl_pSwapchainImages {
		swapchainImages[i] = *&sl_pSwapchainImages[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetSwapchainImagesKHR = &vkCommand{"vkGetSwapchainImagesKHR", 4, true, nil}

// GetSwapchainStatusKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainStatusKHR.html
func GetSwapchainStatusKHR(device Device, swapchain SwapchainKHR) (r error) {

	r = Result(execTrampoline(vkGetSwapchainStatusKHR, uintptr(device), uintptr(swapchain)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetSwapchainStatusKHR = &vkCommand{"vkGetSwapchainStatusKHR", 2, true, nil}

// GetValidationCacheDataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetValidationCacheDataEXT.html
func GetValidationCacheDataEXT(device Device, validationCache ValidationCacheEXT) (data []byte, r error) {
	// data is a double-call array output
	var dataSize uintptr
	pDataSize := &dataSize
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pData *byte

	r = Result(execTrampoline(vkGetValidationCacheDataEXT, uintptr(device), uintptr(validationCache), uintptr(unsafe.Pointer(pDataSize)), uintptr(unsafe.Pointer(pData))))

	sl_pData := make([]byte, dataSize)
	data = make([]byte, dataSize)
	pData = &sl_pData[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetValidationCacheDataEXT, uintptr(device), uintptr(validationCache), uintptr(unsafe.Pointer(pDataSize)), uintptr(unsafe.Pointer(pData))))

	for i := range sl_pData {
		data[i] = *&sl_pData[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetValidationCacheDataEXT = &vkCommand{"vkGetValidationCacheDataEXT", 4, true, nil}

// GetVideoSessionMemoryRequirementsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetVideoSessionMemoryRequirementsKHR.html
func GetVideoSessionMemoryRequirementsKHR(device Device, videoSession VideoSessionKHR) (memoryRequirements []VideoSessionMemoryRequirementsKHR, r error) {
	// memoryRequirements is a double-call array output
	var memoryRequirementsCount uint32
	pMemoryRequirementsCount := &memoryRequirementsCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pMemoryRequirements *_vkVideoSessionMemoryRequirementsKHR

	r = Result(execTrampoline(vkGetVideoSessionMemoryRequirementsKHR, uintptr(device), uintptr(videoSession), uintptr(unsafe.Pointer(pMemoryRequirementsCount)), uintptr(unsafe.Pointer(pMemoryRequirements))))

	sl_pMemoryRequirements := make([]_vkVideoSessionMemoryRequirementsKHR, memoryRequirementsCount)
	memoryRequirements = make([]VideoSessionMemoryRequirementsKHR, memoryRequirementsCount)
	pMemoryRequirements = &sl_pMemoryRequirements[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(vkGetVideoSessionMemoryRequirementsKHR, uintptr(device), uintptr(videoSession), uintptr(unsafe.Pointer(pMemoryRequirementsCount)), uintptr(unsafe.Pointer(pMemoryRequirements))))

	for i := range sl_pMemoryRequirements {
		memoryRequirements[i] = *sl_pMemoryRequirements[i].Goify()
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetVideoSessionMemoryRequirementsKHR = &vkCommand{"vkGetVideoSessionMemoryRequirementsKHR", 4, true, nil}

// ImportFenceFdKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportFenceFdKHR.html
func ImportFenceFdKHR(device Device, importFenceFdInfo *ImportFenceFdInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - importFenceFdInfo
	var pImportFenceFdInfo *_vkImportFenceFdInfoKHR
	if importFenceFdInfo != nil {
		pImportFenceFdInfo = importFenceFdInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkImportFenceFdKHR, uintptr(device), uintptr(unsafe.Pointer(pImportFenceFdInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkImportFenceFdKHR = &vkCommand{"vkImportFenceFdKHR", 2, true, nil}

// ImportSemaphoreFdKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportSemaphoreFdKHR.html
func ImportSemaphoreFdKHR(device Device, importSemaphoreFdInfo *ImportSemaphoreFdInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - importSemaphoreFdInfo
	var pImportSemaphoreFdInfo *_vkImportSemaphoreFdInfoKHR
	if importSemaphoreFdInfo != nil {
		pImportSemaphoreFdInfo = importSemaphoreFdInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkImportSemaphoreFdKHR, uintptr(device), uintptr(unsafe.Pointer(pImportSemaphoreFdInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkImportSemaphoreFdKHR = &vkCommand{"vkImportSemaphoreFdKHR", 2, true, nil}

// InitializePerformanceApiINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkInitializePerformanceApiINTEL.html
func InitializePerformanceApiINTEL(device Device, initializeInfo *InitializePerformanceApiInfoINTEL) (r error) {
	// Parameter is a singular input, requires translation - initializeInfo
	var pInitializeInfo *_vkInitializePerformanceApiInfoINTEL
	if initializeInfo != nil {
		pInitializeInfo = initializeInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkInitializePerformanceApiINTEL, uintptr(device), uintptr(unsafe.Pointer(pInitializeInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkInitializePerformanceApiINTEL = &vkCommand{"vkInitializePerformanceApiINTEL", 2, true, nil}

// InvalidateMappedMemoryRanges: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkInvalidateMappedMemoryRanges.html
func InvalidateMappedMemoryRanges(device Device, memoryRanges []MappedMemoryRange) (r error) {
	memoryRangeCount := len(memoryRanges)
	// memoryRanges is an input slice that requires translation to an internal type
	var pMemoryRanges unsafe.Pointer
	if len(memoryRanges) > 0 {
		sl_memoryRanges := make([]_vkMappedMemoryRange, memoryRangeCount)
		for i, v := range memoryRanges {
			sl_memoryRanges[i] = *(v.Vulkanize())
		}
		pMemoryRanges = unsafe.Pointer(&sl_memoryRanges[0])
	}

	r = Result(execTrampoline(vkInvalidateMappedMemoryRanges, uintptr(device), uintptr(memoryRangeCount), uintptr(unsafe.Pointer(pMemoryRanges))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkInvalidateMappedMemoryRanges = &vkCommand{"vkInvalidateMappedMemoryRanges", 3, true, nil}

// LatencySleepNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkLatencySleepNV.html
func LatencySleepNV(device Device, swapchain SwapchainKHR, sleepInfo *LatencySleepInfoNV) (r error) {
	// Parameter is a singular input, requires translation - sleepInfo
	var pSleepInfo *_vkLatencySleepInfoNV
	if sleepInfo != nil {
		pSleepInfo = sleepInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkLatencySleepNV, uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pSleepInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkLatencySleepNV = &vkCommand{"vkLatencySleepNV", 3, true, nil}

// MapMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMapMemory.html
func MapMemory(device Device, memory DeviceMemory, offset DeviceSize, size DeviceSize, flags MemoryMapFlags) (pData *byte, r error) {
	// pData is a binding-allocated single return value and will be populated by Vulkan
	ptr_ppData := &pData

	r = Result(execTrampoline(vkMapMemory, uintptr(device), uintptr(memory), uintptr(offset), uintptr(size), uintptr(flags), uintptr(unsafe.Pointer(ptr_ppData))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkMapMemory = &vkCommand{"vkMapMemory", 6, true, nil}

// MapMemory2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMapMemory2KHR.html
func MapMemory2KHR(device Device, memoryMapInfo *MemoryMapInfoKHR) (pData *byte, r error) {
	// Parameter is a singular input, requires translation - memoryMapInfo
	var pMemoryMapInfo *_vkMemoryMapInfoKHR
	if memoryMapInfo != nil {
		pMemoryMapInfo = memoryMapInfo.Vulkanize()
	}

	// pData is a binding-allocated single return value and will be populated by Vulkan
	ptr_ppData := &pData

	r = Result(execTrampoline(vkMapMemory2KHR, uintptr(device), uintptr(unsafe.Pointer(pMemoryMapInfo)), uintptr(unsafe.Pointer(ptr_ppData))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkMapMemory2KHR = &vkCommand{"vkMapMemory2KHR", 3, true, nil}

// MergePipelineCaches: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMergePipelineCaches.html
func MergePipelineCaches(device Device, dstCache PipelineCache, srcCaches []PipelineCache) (r error) {
	srcCacheCount := len(srcCaches)
	// srcCaches is an input slice of values that do not need translation used
	var pSrcCaches unsafe.Pointer
	if srcCaches != nil {
		pSrcCaches = unsafe.Pointer(&srcCaches[0])
	}

	r = Result(execTrampoline(vkMergePipelineCaches, uintptr(device), uintptr(dstCache), uintptr(srcCacheCount), uintptr(unsafe.Pointer(pSrcCaches))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkMergePipelineCaches = &vkCommand{"vkMergePipelineCaches", 4, true, nil}

// MergeValidationCachesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMergeValidationCachesEXT.html
func MergeValidationCachesEXT(device Device, dstCache ValidationCacheEXT, srcCaches []ValidationCacheEXT) (r error) {
	srcCacheCount := len(srcCaches)
	// srcCaches is an input slice of values that do not need translation used
	var pSrcCaches unsafe.Pointer
	if srcCaches != nil {
		pSrcCaches = unsafe.Pointer(&srcCaches[0])
	}

	r = Result(execTrampoline(vkMergeValidationCachesEXT, uintptr(device), uintptr(dstCache), uintptr(srcCacheCount), uintptr(unsafe.Pointer(pSrcCaches))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkMergeValidationCachesEXT = &vkCommand{"vkMergeValidationCachesEXT", 4, true, nil}

// QueueBeginDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueBeginDebugUtilsLabelEXT.html
func QueueBeginDebugUtilsLabelEXT(queue Queue, labelInfo *DebugUtilsLabelEXT) {
	// Parameter is a singular input, requires translation - labelInfo
	var pLabelInfo *_vkDebugUtilsLabelEXT
	if labelInfo != nil {
		pLabelInfo = labelInfo.Vulkanize()
	}

	execTrampoline(vkQueueBeginDebugUtilsLabelEXT, uintptr(queue), uintptr(unsafe.Pointer(pLabelInfo)))

}

var vkQueueBeginDebugUtilsLabelEXT = &vkCommand{"vkQueueBeginDebugUtilsLabelEXT", 2, true, nil}

// QueueBindSparse: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueBindSparse.html
func QueueBindSparse(queue Queue, bindInfo []BindSparseInfo, fence Fence) (r error) {
	bindInfoCount := len(bindInfo)
	// bindInfo is an input slice that requires translation to an internal type
	var pBindInfo unsafe.Pointer
	if len(bindInfo) > 0 {
		sl_bindInfo := make([]_vkBindSparseInfo, bindInfoCount)
		for i, v := range bindInfo {
			sl_bindInfo[i] = *(v.Vulkanize())
		}
		pBindInfo = unsafe.Pointer(&sl_bindInfo[0])
	}

	r = Result(execTrampoline(vkQueueBindSparse, uintptr(queue), uintptr(bindInfoCount), uintptr(unsafe.Pointer(pBindInfo)), uintptr(fence)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkQueueBindSparse = &vkCommand{"vkQueueBindSparse", 4, true, nil}

// QueueEndDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueEndDebugUtilsLabelEXT.html
func QueueEndDebugUtilsLabelEXT(queue Queue) {

	execTrampoline(vkQueueEndDebugUtilsLabelEXT, uintptr(queue))

}

var vkQueueEndDebugUtilsLabelEXT = &vkCommand{"vkQueueEndDebugUtilsLabelEXT", 1, true, nil}

// QueueInsertDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueInsertDebugUtilsLabelEXT.html
func QueueInsertDebugUtilsLabelEXT(queue Queue, labelInfo *DebugUtilsLabelEXT) {
	// Parameter is a singular input, requires translation - labelInfo
	var pLabelInfo *_vkDebugUtilsLabelEXT
	if labelInfo != nil {
		pLabelInfo = labelInfo.Vulkanize()
	}

	execTrampoline(vkQueueInsertDebugUtilsLabelEXT, uintptr(queue), uintptr(unsafe.Pointer(pLabelInfo)))

}

var vkQueueInsertDebugUtilsLabelEXT = &vkCommand{"vkQueueInsertDebugUtilsLabelEXT", 2, true, nil}

// QueueNotifyOutOfBandNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueNotifyOutOfBandNV.html
func QueueNotifyOutOfBandNV(queue Queue, queueTypeInfo *OutOfBandQueueTypeInfoNV) {
	// Parameter is a singular input, requires translation - queueTypeInfo
	var pQueueTypeInfo *_vkOutOfBandQueueTypeInfoNV
	if queueTypeInfo != nil {
		pQueueTypeInfo = queueTypeInfo.Vulkanize()
	}

	execTrampoline(vkQueueNotifyOutOfBandNV, uintptr(queue), uintptr(unsafe.Pointer(pQueueTypeInfo)))

}

var vkQueueNotifyOutOfBandNV = &vkCommand{"vkQueueNotifyOutOfBandNV", 2, true, nil}

// QueuePresentKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html
func QueuePresentKHR(queue Queue, presentInfo *PresentInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - presentInfo
	var pPresentInfo *_vkPresentInfoKHR
	if presentInfo != nil {
		pPresentInfo = presentInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkQueuePresentKHR, uintptr(queue), uintptr(unsafe.Pointer(pPresentInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkQueuePresentKHR = &vkCommand{"vkQueuePresentKHR", 2, true, nil}

// QueueSetPerformanceConfigurationINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSetPerformanceConfigurationINTEL.html
func QueueSetPerformanceConfigurationINTEL(queue Queue, configuration PerformanceConfigurationINTEL) (r error) {

	r = Result(execTrampoline(vkQueueSetPerformanceConfigurationINTEL, uintptr(queue), uintptr(configuration)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkQueueSetPerformanceConfigurationINTEL = &vkCommand{"vkQueueSetPerformanceConfigurationINTEL", 2, true, nil}

// QueueSubmit: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit.html
func QueueSubmit(queue Queue, submits []SubmitInfo, fence Fence) (r error) {
	submitCount := len(submits)
	// submits is an input slice that requires translation to an internal type
	var pSubmits unsafe.Pointer
	if len(submits) > 0 {
		sl_submits := make([]_vkSubmitInfo, submitCount)
		for i, v := range submits {
			sl_submits[i] = *(v.Vulkanize())
		}
		pSubmits = unsafe.Pointer(&sl_submits[0])
	}

	r = Result(execTrampoline(vkQueueSubmit, uintptr(queue), uintptr(submitCount), uintptr(unsafe.Pointer(pSubmits)), uintptr(fence)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkQueueSubmit = &vkCommand{"vkQueueSubmit", 4, true, nil}

// QueueSubmit2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit2.html
func QueueSubmit2(queue Queue, submits []SubmitInfo2, fence Fence) (r error) {
	submitCount := len(submits)
	// submits is an input slice that requires translation to an internal type
	var pSubmits unsafe.Pointer
	if len(submits) > 0 {
		sl_submits := make([]_vkSubmitInfo2, submitCount)
		for i, v := range submits {
			sl_submits[i] = *(v.Vulkanize())
		}
		pSubmits = unsafe.Pointer(&sl_submits[0])
	}

	r = Result(execTrampoline(vkQueueSubmit2, uintptr(queue), uintptr(submitCount), uintptr(unsafe.Pointer(pSubmits)), uintptr(fence)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkQueueSubmit2 = &vkCommand{"vkQueueSubmit2", 4, true, nil}
var QueueSubmit2KHR = QueueSubmit2

// QueueWaitIdle: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueWaitIdle.html
func QueueWaitIdle(queue Queue) (r error) {

	r = Result(execTrampoline(vkQueueWaitIdle, uintptr(queue)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkQueueWaitIdle = &vkCommand{"vkQueueWaitIdle", 1, true, nil}

// RegisterDeviceEventEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkRegisterDeviceEventEXT.html
func RegisterDeviceEventEXT(device Device, deviceEventInfo *DeviceEventInfoEXT, allocator *AllocationCallbacks) (fence Fence, r error) {
	// Parameter is a singular input, requires translation - deviceEventInfo
	var pDeviceEventInfo *_vkDeviceEventInfoEXT
	if deviceEventInfo != nil {
		pDeviceEventInfo = deviceEventInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// fence is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFence := &fence

	r = Result(execTrampoline(vkRegisterDeviceEventEXT, uintptr(device), uintptr(unsafe.Pointer(pDeviceEventInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pFence))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkRegisterDeviceEventEXT = &vkCommand{"vkRegisterDeviceEventEXT", 4, true, nil}

// RegisterDisplayEventEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkRegisterDisplayEventEXT.html
func RegisterDisplayEventEXT(device Device, display DisplayKHR, displayEventInfo *DisplayEventInfoEXT, allocator *AllocationCallbacks) (fence Fence, r error) {
	// Parameter is a singular input, requires translation - displayEventInfo
	var pDisplayEventInfo *_vkDisplayEventInfoEXT
	if displayEventInfo != nil {
		pDisplayEventInfo = displayEventInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// fence is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFence := &fence

	r = Result(execTrampoline(vkRegisterDisplayEventEXT, uintptr(device), uintptr(display), uintptr(unsafe.Pointer(pDisplayEventInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pFence))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkRegisterDisplayEventEXT = &vkCommand{"vkRegisterDisplayEventEXT", 5, true, nil}

// ReleaseDisplayEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleaseDisplayEXT.html
func ReleaseDisplayEXT(physicalDevice PhysicalDevice, display DisplayKHR) (r error) {

	r = Result(execTrampoline(vkReleaseDisplayEXT, uintptr(physicalDevice), uintptr(display)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkReleaseDisplayEXT = &vkCommand{"vkReleaseDisplayEXT", 2, true, nil}

// ReleasePerformanceConfigurationINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleasePerformanceConfigurationINTEL.html
func ReleasePerformanceConfigurationINTEL(device Device, configuration PerformanceConfigurationINTEL) (r error) {

	r = Result(execTrampoline(vkReleasePerformanceConfigurationINTEL, uintptr(device), uintptr(configuration)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkReleasePerformanceConfigurationINTEL = &vkCommand{"vkReleasePerformanceConfigurationINTEL", 2, true, nil}

// ReleaseProfilingLockKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleaseProfilingLockKHR.html
func ReleaseProfilingLockKHR(device Device) {

	execTrampoline(vkReleaseProfilingLockKHR, uintptr(device))

}

var vkReleaseProfilingLockKHR = &vkCommand{"vkReleaseProfilingLockKHR", 1, true, nil}

// ReleaseSwapchainImagesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleaseSwapchainImagesEXT.html
func ReleaseSwapchainImagesEXT(device Device, releaseInfo *ReleaseSwapchainImagesInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - releaseInfo
	var pReleaseInfo *_vkReleaseSwapchainImagesInfoEXT
	if releaseInfo != nil {
		pReleaseInfo = releaseInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkReleaseSwapchainImagesEXT, uintptr(device), uintptr(unsafe.Pointer(pReleaseInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkReleaseSwapchainImagesEXT = &vkCommand{"vkReleaseSwapchainImagesEXT", 2, true, nil}

// ResetCommandBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html
func ResetCommandBuffer(commandBuffer CommandBuffer, flags CommandBufferResetFlags) (r error) {

	r = Result(execTrampoline(vkResetCommandBuffer, uintptr(commandBuffer), uintptr(flags)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkResetCommandBuffer = &vkCommand{"vkResetCommandBuffer", 2, true, nil}

// ResetCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetCommandPool.html
func ResetCommandPool(device Device, commandPool CommandPool, flags CommandPoolResetFlags) (r error) {

	r = Result(execTrampoline(vkResetCommandPool, uintptr(device), uintptr(commandPool), uintptr(flags)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkResetCommandPool = &vkCommand{"vkResetCommandPool", 3, true, nil}

// ResetDescriptorPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetDescriptorPool.html
func ResetDescriptorPool(device Device, descriptorPool DescriptorPool, flags DescriptorPoolResetFlags) (r error) {

	r = Result(execTrampoline(vkResetDescriptorPool, uintptr(device), uintptr(descriptorPool), uintptr(flags)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkResetDescriptorPool = &vkCommand{"vkResetDescriptorPool", 3, true, nil}

// ResetEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetEvent.html
func ResetEvent(device Device, event Event) (r error) {

	r = Result(execTrampoline(vkResetEvent, uintptr(device), uintptr(event)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkResetEvent = &vkCommand{"vkResetEvent", 2, true, nil}

// ResetFences: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetFences.html
func ResetFences(device Device, fences []Fence) (r error) {
	fenceCount := len(fences)
	// fences is an input slice of values that do not need translation used
	var pFences unsafe.Pointer
	if fences != nil {
		pFences = unsafe.Pointer(&fences[0])
	}

	r = Result(execTrampoline(vkResetFences, uintptr(device), uintptr(fenceCount), uintptr(unsafe.Pointer(pFences))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkResetFences = &vkCommand{"vkResetFences", 3, true, nil}

// ResetQueryPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetQueryPool.html
func ResetQueryPool(device Device, queryPool QueryPool, firstQuery uint32, queryCount uint32) {

	execTrampoline(vkResetQueryPool, uintptr(device), uintptr(queryPool), uintptr(firstQuery), uintptr(queryCount))

}

var vkResetQueryPool = &vkCommand{"vkResetQueryPool", 4, true, nil}
var ResetQueryPoolEXT = ResetQueryPool

// SetDebugUtilsObjectNameEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetDebugUtilsObjectNameEXT.html
func SetDebugUtilsObjectNameEXT(device Device, nameInfo *DebugUtilsObjectNameInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - nameInfo
	var pNameInfo *_vkDebugUtilsObjectNameInfoEXT
	if nameInfo != nil {
		pNameInfo = nameInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkSetDebugUtilsObjectNameEXT, uintptr(device), uintptr(unsafe.Pointer(pNameInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkSetDebugUtilsObjectNameEXT = &vkCommand{"vkSetDebugUtilsObjectNameEXT", 2, true, nil}

// SetDebugUtilsObjectTagEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetDebugUtilsObjectTagEXT.html
func SetDebugUtilsObjectTagEXT(device Device, tagInfo *DebugUtilsObjectTagInfoEXT) (r error) {
	// Parameter is a singular input, requires translation - tagInfo
	var pTagInfo *_vkDebugUtilsObjectTagInfoEXT
	if tagInfo != nil {
		pTagInfo = tagInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkSetDebugUtilsObjectTagEXT, uintptr(device), uintptr(unsafe.Pointer(pTagInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkSetDebugUtilsObjectTagEXT = &vkCommand{"vkSetDebugUtilsObjectTagEXT", 2, true, nil}

// SetDeviceMemoryPriorityEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetDeviceMemoryPriorityEXT.html
func SetDeviceMemoryPriorityEXT(device Device, memory DeviceMemory, priority float32) {

	execTrampoline(vkSetDeviceMemoryPriorityEXT, uintptr(device), uintptr(memory), uintptr(priority))

}

var vkSetDeviceMemoryPriorityEXT = &vkCommand{"vkSetDeviceMemoryPriorityEXT", 3, true, nil}

// SetEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetEvent.html
func SetEvent(device Device, event Event) (r error) {

	r = Result(execTrampoline(vkSetEvent, uintptr(device), uintptr(event)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkSetEvent = &vkCommand{"vkSetEvent", 2, true, nil}

// SetHdrMetadataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetHdrMetadataEXT.html
func SetHdrMetadataEXT(device Device, swapchains []SwapchainKHR, metadata []HdrMetadataEXT) {
	swapchainCount := len(swapchains)
	// swapchains is an input slice of values that do not need translation used
	var pSwapchains unsafe.Pointer
	if swapchains != nil {
		pSwapchains = unsafe.Pointer(&swapchains[0])
	}

	// metadata is an input slice that requires translation to an internal type
	var pMetadata unsafe.Pointer
	if len(metadata) > 0 {
		sl_metadata := make([]_vkHdrMetadataEXT, swapchainCount)
		for i, v := range metadata {
			sl_metadata[i] = *(v.Vulkanize())
		}
		pMetadata = unsafe.Pointer(&sl_metadata[0])
	}

	execTrampoline(vkSetHdrMetadataEXT, uintptr(device), uintptr(swapchainCount), uintptr(unsafe.Pointer(pSwapchains)), uintptr(unsafe.Pointer(pMetadata)))

}

var vkSetHdrMetadataEXT = &vkCommand{"vkSetHdrMetadataEXT", 4, true, nil}

// SetLatencyMarkerNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetLatencyMarkerNV.html
func SetLatencyMarkerNV(device Device, swapchain SwapchainKHR, latencyMarkerInfo *SetLatencyMarkerInfoNV) {
	// Parameter is a singular input, requires translation - latencyMarkerInfo
	var pLatencyMarkerInfo *_vkSetLatencyMarkerInfoNV
	if latencyMarkerInfo != nil {
		pLatencyMarkerInfo = latencyMarkerInfo.Vulkanize()
	}

	execTrampoline(vkSetLatencyMarkerNV, uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pLatencyMarkerInfo)))

}

var vkSetLatencyMarkerNV = &vkCommand{"vkSetLatencyMarkerNV", 3, true, nil}

// SetLatencySleepModeNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetLatencySleepModeNV.html
func SetLatencySleepModeNV(device Device, swapchain SwapchainKHR, sleepModeInfo *LatencySleepModeInfoNV) (r error) {
	// Parameter is a singular input, requires translation - sleepModeInfo
	var pSleepModeInfo *_vkLatencySleepModeInfoNV
	if sleepModeInfo != nil {
		pSleepModeInfo = sleepModeInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkSetLatencySleepModeNV, uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pSleepModeInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkSetLatencySleepModeNV = &vkCommand{"vkSetLatencySleepModeNV", 3, true, nil}

// SetLocalDimmingAMD: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetLocalDimmingAMD.html
func SetLocalDimmingAMD(device Device, swapChain SwapchainKHR, localDimmingEnable bool) {
	localDimmingEnable_Bool32 := translateInternal_Bool32(localDimmingEnable)

	execTrampoline(vkSetLocalDimmingAMD, uintptr(device), uintptr(swapChain), uintptr(localDimmingEnable_Bool32))

}

var vkSetLocalDimmingAMD = &vkCommand{"vkSetLocalDimmingAMD", 3, true, nil}

// SetPrivateData: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetPrivateData.html
func SetPrivateData(device Device, objectType ObjectType, objectHandle uint64, privateDataSlot PrivateDataSlot, data uint64) (r error) {

	r = Result(execTrampoline(vkSetPrivateData, uintptr(device), uintptr(objectType), uintptr(objectHandle), uintptr(privateDataSlot), uintptr(data)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkSetPrivateData = &vkCommand{"vkSetPrivateData", 5, true, nil}
var SetPrivateDataEXT = SetPrivateData

// SignalSemaphore: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSignalSemaphore.html
func SignalSemaphore(device Device, signalInfo *SemaphoreSignalInfo) (r error) {
	// Parameter is a singular input, requires translation - signalInfo
	var pSignalInfo *_vkSemaphoreSignalInfo
	if signalInfo != nil {
		pSignalInfo = signalInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkSignalSemaphore, uintptr(device), uintptr(unsafe.Pointer(pSignalInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkSignalSemaphore = &vkCommand{"vkSignalSemaphore", 2, true, nil}
var SignalSemaphoreKHR = SignalSemaphore

// SubmitDebugUtilsMessageEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSubmitDebugUtilsMessageEXT.html
func SubmitDebugUtilsMessageEXT(instance Instance, messageSeverity DebugUtilsMessageSeverityFlagBitsEXT, messageTypes DebugUtilsMessageTypeFlagsEXT, callbackData *DebugUtilsMessengerCallbackDataEXT) {
	// Parameter is a singular input, requires translation - callbackData
	var pCallbackData *_vkDebugUtilsMessengerCallbackDataEXT
	if callbackData != nil {
		pCallbackData = callbackData.Vulkanize()
	}

	execTrampoline(vkSubmitDebugUtilsMessageEXT, uintptr(instance), uintptr(messageSeverity), uintptr(messageTypes), uintptr(unsafe.Pointer(pCallbackData)))

}

var vkSubmitDebugUtilsMessageEXT = &vkCommand{"vkSubmitDebugUtilsMessageEXT", 4, true, nil}

// TransitionImageLayoutEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkTransitionImageLayoutEXT.html
func TransitionImageLayoutEXT(device Device, transitions []HostImageLayoutTransitionInfoEXT) (r error) {
	transitionCount := len(transitions)
	// transitions is an input slice that requires translation to an internal type
	var pTransitions unsafe.Pointer
	if len(transitions) > 0 {
		sl_transitions := make([]_vkHostImageLayoutTransitionInfoEXT, transitionCount)
		for i, v := range transitions {
			sl_transitions[i] = *(v.Vulkanize())
		}
		pTransitions = unsafe.Pointer(&sl_transitions[0])
	}

	r = Result(execTrampoline(vkTransitionImageLayoutEXT, uintptr(device), uintptr(transitionCount), uintptr(unsafe.Pointer(pTransitions))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkTransitionImageLayoutEXT = &vkCommand{"vkTransitionImageLayoutEXT", 3, true, nil}

// TrimCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkTrimCommandPool.html
func TrimCommandPool(device Device, commandPool CommandPool, flags CommandPoolTrimFlags) {

	execTrampoline(vkTrimCommandPool, uintptr(device), uintptr(commandPool), uintptr(flags))

}

var vkTrimCommandPool = &vkCommand{"vkTrimCommandPool", 3, true, nil}
var TrimCommandPoolKHR = TrimCommandPool

// UninitializePerformanceApiINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUninitializePerformanceApiINTEL.html
func UninitializePerformanceApiINTEL(device Device) {

	execTrampoline(vkUninitializePerformanceApiINTEL, uintptr(device))

}

var vkUninitializePerformanceApiINTEL = &vkCommand{"vkUninitializePerformanceApiINTEL", 1, true, nil}

// UnmapMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUnmapMemory.html
func UnmapMemory(device Device, memory DeviceMemory) {

	execTrampoline(vkUnmapMemory, uintptr(device), uintptr(memory))

}

var vkUnmapMemory = &vkCommand{"vkUnmapMemory", 2, true, nil}

// UnmapMemory2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUnmapMemory2KHR.html
func UnmapMemory2KHR(device Device, memoryUnmapInfo *MemoryUnmapInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - memoryUnmapInfo
	var pMemoryUnmapInfo *_vkMemoryUnmapInfoKHR
	if memoryUnmapInfo != nil {
		pMemoryUnmapInfo = memoryUnmapInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkUnmapMemory2KHR, uintptr(device), uintptr(unsafe.Pointer(pMemoryUnmapInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkUnmapMemory2KHR = &vkCommand{"vkUnmapMemory2KHR", 2, true, nil}

// UpdateDescriptorSetWithTemplate: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateDescriptorSetWithTemplate.html
func UpdateDescriptorSetWithTemplate(device Device, descriptorSet DescriptorSet, descriptorUpdateTemplate DescriptorUpdateTemplate, data *byte) {
	// Parameter is a singular input, pass direct - data
	var pData unsafe.Pointer
	if data != nil {
		pData = unsafe.Pointer(data)
	}

	execTrampoline(vkUpdateDescriptorSetWithTemplate, uintptr(device), uintptr(descriptorSet), uintptr(descriptorUpdateTemplate), uintptr(unsafe.Pointer(pData)))

}

var vkUpdateDescriptorSetWithTemplate = &vkCommand{"vkUpdateDescriptorSetWithTemplate", 4, true, nil}
var UpdateDescriptorSetWithTemplateKHR = UpdateDescriptorSetWithTemplate

// UpdateDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateDescriptorSets.html
func UpdateDescriptorSets(device Device, descriptorWrites []WriteDescriptorSet, descriptorCopies []CopyDescriptorSet) {
	descriptorWriteCount := len(descriptorWrites)
	// descriptorWrites is an input slice that requires translation to an internal type
	var pDescriptorWrites unsafe.Pointer
	if len(descriptorWrites) > 0 {
		sl_descriptorWrites := make([]_vkWriteDescriptorSet, descriptorWriteCount)
		for i, v := range descriptorWrites {
			sl_descriptorWrites[i] = *(v.Vulkanize())
		}
		pDescriptorWrites = unsafe.Pointer(&sl_descriptorWrites[0])
	}

	descriptorCopyCount := len(descriptorCopies)
	// descriptorCopies is an input slice that requires translation to an internal type
	var pDescriptorCopies unsafe.Pointer
	if len(descriptorCopies) > 0 {
		sl_descriptorCopies := make([]_vkCopyDescriptorSet, descriptorCopyCount)
		for i, v := range descriptorCopies {
			sl_descriptorCopies[i] = *(v.Vulkanize())
		}
		pDescriptorCopies = unsafe.Pointer(&sl_descriptorCopies[0])
	}

	execTrampoline(vkUpdateDescriptorSets, uintptr(device), uintptr(descriptorWriteCount), uintptr(unsafe.Pointer(pDescriptorWrites)), uintptr(descriptorCopyCount), uintptr(unsafe.Pointer(pDescriptorCopies)))

}

var vkUpdateDescriptorSets = &vkCommand{"vkUpdateDescriptorSets", 5, true, nil}

// UpdateVideoSessionParametersKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateVideoSessionParametersKHR.html
func UpdateVideoSessionParametersKHR(device Device, videoSessionParameters VideoSessionParametersKHR, updateInfo *VideoSessionParametersUpdateInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - updateInfo
	var pUpdateInfo *_vkVideoSessionParametersUpdateInfoKHR
	if updateInfo != nil {
		pUpdateInfo = updateInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkUpdateVideoSessionParametersKHR, uintptr(device), uintptr(videoSessionParameters), uintptr(unsafe.Pointer(pUpdateInfo))))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkUpdateVideoSessionParametersKHR = &vkCommand{"vkUpdateVideoSessionParametersKHR", 3, true, nil}

// WaitForFences: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html
func WaitForFences(device Device, fences []Fence, waitAll bool, timeout uint64) (r error) {
	fenceCount := len(fences)
	// fences is an input slice of values that do not need translation used
	var pFences unsafe.Pointer
	if fences != nil {
		pFences = unsafe.Pointer(&fences[0])
	}

	waitAll_Bool32 := translateInternal_Bool32(waitAll)

	r = Result(execTrampoline(vkWaitForFences, uintptr(device), uintptr(fenceCount), uintptr(unsafe.Pointer(pFences)), uintptr(waitAll_Bool32), uintptr(timeout)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkWaitForFences = &vkCommand{"vkWaitForFences", 5, true, nil}

// WaitForPresentKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitForPresentKHR.html
func WaitForPresentKHR(device Device, swapchain SwapchainKHR, presentId uint64, timeout uint64) (r error) {

	r = Result(execTrampoline(vkWaitForPresentKHR, uintptr(device), uintptr(swapchain), uintptr(presentId), uintptr(timeout)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkWaitForPresentKHR = &vkCommand{"vkWaitForPresentKHR", 4, true, nil}

// WaitSemaphores: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitSemaphores.html
func WaitSemaphores(device Device, waitInfo *SemaphoreWaitInfo, timeout uint64) (r error) {
	// Parameter is a singular input, requires translation - waitInfo
	var pWaitInfo *_vkSemaphoreWaitInfo
	if waitInfo != nil {
		pWaitInfo = waitInfo.Vulkanize()
	}

	r = Result(execTrampoline(vkWaitSemaphores, uintptr(device), uintptr(unsafe.Pointer(pWaitInfo)), uintptr(timeout)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkWaitSemaphores = &vkCommand{"vkWaitSemaphores", 3, true, nil}
var WaitSemaphoresKHR = WaitSemaphores

// WriteAccelerationStructuresPropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWriteAccelerationStructuresPropertiesKHR.html
func WriteAccelerationStructuresPropertiesKHR(device Device, accelerationStructures []AccelerationStructureKHR, queryType QueryType, data []byte, stride uintptr) (r error) {
	accelerationStructureCount := len(accelerationStructures)
	// accelerationStructures is an input slice of values that do not need translation used
	var pAccelerationStructures unsafe.Pointer
	if accelerationStructures != nil {
		pAccelerationStructures = unsafe.Pointer(&accelerationStructures[0])
	}

	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	r = Result(execTrampoline(vkWriteAccelerationStructuresPropertiesKHR, uintptr(device), uintptr(accelerationStructureCount), uintptr(unsafe.Pointer(pAccelerationStructures)), uintptr(queryType), uintptr(dataSize), uintptr(unsafe.Pointer(pData)), uintptr(stride)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkWriteAccelerationStructuresPropertiesKHR = &vkCommand{"vkWriteAccelerationStructuresPropertiesKHR", 7, true, nil}

// WriteMicromapsPropertiesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWriteMicromapsPropertiesEXT.html
func WriteMicromapsPropertiesEXT(device Device, micromaps []MicromapEXT, queryType QueryType, data []byte, stride uintptr) (r error) {
	micromapCount := len(micromaps)
	// micromaps is an input slice of values that do not need translation used
	var pMicromaps unsafe.Pointer
	if micromaps != nil {
		pMicromaps = unsafe.Pointer(&micromaps[0])
	}

	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	r = Result(execTrampoline(vkWriteMicromapsPropertiesEXT, uintptr(device), uintptr(micromapCount), uintptr(unsafe.Pointer(pMicromaps)), uintptr(queryType), uintptr(dataSize), uintptr(unsafe.Pointer(pData)), uintptr(stride)))

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkWriteMicromapsPropertiesEXT = &vkCommand{"vkWriteMicromapsPropertiesEXT", 7, true, nil}
