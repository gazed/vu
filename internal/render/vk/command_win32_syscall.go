//go:build windows

// Code generated by go-vk from vk.xml at 2025-10-08 11:06:16.104738 -0400 EDT m=+0.925384293. DO NOT EDIT.

package vk

import (
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

// AcquireFullScreenExclusiveModeEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireFullScreenExclusiveModeEXT.html
func AcquireFullScreenExclusiveModeEXT(device Device, swapchain SwapchainKHR) (r error) {
	var rsys uintptr

	if vkAcquireFullScreenExclusiveModeEXT.fnHandle == nil {
		vkAcquireFullScreenExclusiveModeEXT.fnHandle = dlHandle.NewProc("vkAcquireFullScreenExclusiveModeEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkAcquireFullScreenExclusiveModeEXT.fnHandle.Addr(), uintptr(device), uintptr(swapchain))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAcquireFullScreenExclusiveModeEXT = &vkCommand{"vkAcquireFullScreenExclusiveModeEXT", 2, true, nil}

// AcquireWinrtDisplayNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireWinrtDisplayNV.html
func AcquireWinrtDisplayNV(physicalDevice PhysicalDevice, display DisplayKHR) (r error) {
	var rsys uintptr

	if vkAcquireWinrtDisplayNV.fnHandle == nil {
		vkAcquireWinrtDisplayNV.fnHandle = dlHandle.NewProc("vkAcquireWinrtDisplayNV")
	}
	rsys, _, _ = syscall.SyscallN(vkAcquireWinrtDisplayNV.fnHandle.Addr(), uintptr(physicalDevice), uintptr(display))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkAcquireWinrtDisplayNV = &vkCommand{"vkAcquireWinrtDisplayNV", 2, true, nil}

// CreateWin32SurfaceKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateWin32SurfaceKHR.html
func CreateWin32SurfaceKHR(instance Instance, createInfo *Win32SurfaceCreateInfoKHR, allocator *AllocationCallbacks) (surface SurfaceKHR, r error) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkWin32SurfaceCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// surface is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSurface := &surface

	var rsys uintptr

	if vkCreateWin32SurfaceKHR.fnHandle == nil {
		vkCreateWin32SurfaceKHR.fnHandle = dlHandle.NewProc("vkCreateWin32SurfaceKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkCreateWin32SurfaceKHR.fnHandle.Addr(), uintptr(instance), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSurface)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkCreateWin32SurfaceKHR = &vkCommand{"vkCreateWin32SurfaceKHR", 4, true, nil}

// GetDeviceGroupSurfacePresentModes2EXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupSurfacePresentModes2EXT.html
func GetDeviceGroupSurfacePresentModes2EXT(device Device, surfaceInfo *PhysicalDeviceSurfaceInfo2KHR) (modes DeviceGroupPresentModeFlagsKHR, r error) {
	// Parameter is a singular input, requires translation - surfaceInfo
	var pSurfaceInfo *_vkPhysicalDeviceSurfaceInfo2KHR
	if surfaceInfo != nil {
		pSurfaceInfo = surfaceInfo.Vulkanize()
	}

	// modes is a binding-allocated single return value and will be populated by Vulkan
	ptr_pModes := &modes

	var rsys uintptr

	if vkGetDeviceGroupSurfacePresentModes2EXT.fnHandle == nil {
		vkGetDeviceGroupSurfacePresentModes2EXT.fnHandle = dlHandle.NewProc("vkGetDeviceGroupSurfacePresentModes2EXT")
	}
	rsys, _, _ = syscall.SyscallN(vkGetDeviceGroupSurfacePresentModes2EXT.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pSurfaceInfo)), uintptr(unsafe.Pointer(ptr_pModes)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetDeviceGroupSurfacePresentModes2EXT = &vkCommand{"vkGetDeviceGroupSurfacePresentModes2EXT", 3, true, nil}

// GetFenceWin32HandleKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceWin32HandleKHR.html
func GetFenceWin32HandleKHR(device Device, getWin32HandleInfo *FenceGetWin32HandleInfoKHR) (handle windows.Handle, r error) {
	// Parameter is a singular input, requires translation - getWin32HandleInfo
	var pGetWin32HandleInfo *_vkFenceGetWin32HandleInfoKHR
	if getWin32HandleInfo != nil {
		pGetWin32HandleInfo = getWin32HandleInfo.Vulkanize()
	}

	// handle is a binding-allocated single return value and will be populated by Vulkan
	ptr_pHandle := &handle

	var rsys uintptr

	if vkGetFenceWin32HandleKHR.fnHandle == nil {
		vkGetFenceWin32HandleKHR.fnHandle = dlHandle.NewProc("vkGetFenceWin32HandleKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetFenceWin32HandleKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pGetWin32HandleInfo)), uintptr(unsafe.Pointer(ptr_pHandle)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetFenceWin32HandleKHR = &vkCommand{"vkGetFenceWin32HandleKHR", 3, true, nil}

// GetMemoryWin32HandleKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryWin32HandleKHR.html
func GetMemoryWin32HandleKHR(device Device, getWin32HandleInfo *MemoryGetWin32HandleInfoKHR) (handle windows.Handle, r error) {
	// Parameter is a singular input, requires translation - getWin32HandleInfo
	var pGetWin32HandleInfo *_vkMemoryGetWin32HandleInfoKHR
	if getWin32HandleInfo != nil {
		pGetWin32HandleInfo = getWin32HandleInfo.Vulkanize()
	}

	// handle is a binding-allocated single return value and will be populated by Vulkan
	ptr_pHandle := &handle

	var rsys uintptr

	if vkGetMemoryWin32HandleKHR.fnHandle == nil {
		vkGetMemoryWin32HandleKHR.fnHandle = dlHandle.NewProc("vkGetMemoryWin32HandleKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetMemoryWin32HandleKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pGetWin32HandleInfo)), uintptr(unsafe.Pointer(ptr_pHandle)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetMemoryWin32HandleKHR = &vkCommand{"vkGetMemoryWin32HandleKHR", 3, true, nil}

// GetMemoryWin32HandleNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryWin32HandleNV.html
func GetMemoryWin32HandleNV(device Device, memory DeviceMemory, handleType ExternalMemoryHandleTypeFlagsNV) (handle windows.Handle, r error) {
	// handle is a binding-allocated single return value and will be populated by Vulkan
	ptr_pHandle := &handle

	var rsys uintptr

	if vkGetMemoryWin32HandleNV.fnHandle == nil {
		vkGetMemoryWin32HandleNV.fnHandle = dlHandle.NewProc("vkGetMemoryWin32HandleNV")
	}
	rsys, _, _ = syscall.SyscallN(vkGetMemoryWin32HandleNV.fnHandle.Addr(), uintptr(device), uintptr(memory), uintptr(handleType), uintptr(unsafe.Pointer(ptr_pHandle)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetMemoryWin32HandleNV = &vkCommand{"vkGetMemoryWin32HandleNV", 4, true, nil}

// GetMemoryWin32HandlePropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryWin32HandlePropertiesKHR.html
func GetMemoryWin32HandlePropertiesKHR(device Device, handleType ExternalMemoryHandleTypeFlagBits, handle windows.Handle) (memoryWin32HandleProperties MemoryWin32HandlePropertiesKHR, r error) {
	// memoryWin32HandleProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryWin32HandleProperties *_vkMemoryWin32HandlePropertiesKHR = memoryWin32HandleProperties.Vulkanize()

	var rsys uintptr

	if vkGetMemoryWin32HandlePropertiesKHR.fnHandle == nil {
		vkGetMemoryWin32HandlePropertiesKHR.fnHandle = dlHandle.NewProc("vkGetMemoryWin32HandlePropertiesKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetMemoryWin32HandlePropertiesKHR.fnHandle.Addr(), uintptr(device), uintptr(handleType), uintptr(handle), uintptr(unsafe.Pointer(pMemoryWin32HandleProperties)))
	r = Result(rsys)

	memoryWin32HandleProperties = *(pMemoryWin32HandleProperties.Goify())
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetMemoryWin32HandlePropertiesKHR = &vkCommand{"vkGetMemoryWin32HandlePropertiesKHR", 4, true, nil}

// GetPhysicalDeviceSurfacePresentModes2EXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfacePresentModes2EXT.html
func GetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice PhysicalDevice, surfaceInfo *PhysicalDeviceSurfaceInfo2KHR) (presentModes []PresentModeKHR, r error) {
	// Parameter is a singular input, requires translation - surfaceInfo
	var pSurfaceInfo *_vkPhysicalDeviceSurfaceInfo2KHR
	if surfaceInfo != nil {
		pSurfaceInfo = surfaceInfo.Vulkanize()
	}

	// presentModes is a double-call array output
	var presentModeCount uint32
	pPresentModeCount := &presentModeCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pPresentModes *PresentModeKHR
	var rsys uintptr

	if vkGetPhysicalDeviceSurfacePresentModes2EXT.fnHandle == nil {
		vkGetPhysicalDeviceSurfacePresentModes2EXT.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSurfacePresentModes2EXT")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceSurfacePresentModes2EXT.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pSurfaceInfo)), uintptr(unsafe.Pointer(pPresentModeCount)), uintptr(unsafe.Pointer(pPresentModes)))
	r = Result(rsys)

	sl_pPresentModes := make([]PresentModeKHR, presentModeCount)
	presentModes = make([]PresentModeKHR, presentModeCount)
	pPresentModes = &sl_pPresentModes[0]

	// Trampoline call after last array allocation
	if vkGetPhysicalDeviceSurfacePresentModes2EXT.fnHandle == nil {
		vkGetPhysicalDeviceSurfacePresentModes2EXT.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceSurfacePresentModes2EXT")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceSurfacePresentModes2EXT.fnHandle.Addr(), uintptr(physicalDevice), uintptr(unsafe.Pointer(pSurfaceInfo)), uintptr(unsafe.Pointer(pPresentModeCount)), uintptr(unsafe.Pointer(pPresentModes)))
	r = Result(rsys)

	for i := range sl_pPresentModes {
		presentModes[i] = *&sl_pPresentModes[i]
	}
	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetPhysicalDeviceSurfacePresentModes2EXT = &vkCommand{"vkGetPhysicalDeviceSurfacePresentModes2EXT", 4, true, nil}

// GetPhysicalDeviceWin32PresentationSupportKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceWin32PresentationSupportKHR.html
func GetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice PhysicalDevice, queueFamilyIndex uint32) (r bool) {
	var rsys uintptr

	if vkGetPhysicalDeviceWin32PresentationSupportKHR.fnHandle == nil {
		vkGetPhysicalDeviceWin32PresentationSupportKHR.fnHandle = dlHandle.NewProc("vkGetPhysicalDeviceWin32PresentationSupportKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetPhysicalDeviceWin32PresentationSupportKHR.fnHandle.Addr(), uintptr(physicalDevice), uintptr(queueFamilyIndex))
	rval := Bool32(rsys)
	r = translatePublic_Bool32(rval)

	return
}

var vkGetPhysicalDeviceWin32PresentationSupportKHR = &vkCommand{"vkGetPhysicalDeviceWin32PresentationSupportKHR", 2, true, nil}

// GetSemaphoreWin32HandleKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreWin32HandleKHR.html
func GetSemaphoreWin32HandleKHR(device Device, getWin32HandleInfo *SemaphoreGetWin32HandleInfoKHR) (handle windows.Handle, r error) {
	// Parameter is a singular input, requires translation - getWin32HandleInfo
	var pGetWin32HandleInfo *_vkSemaphoreGetWin32HandleInfoKHR
	if getWin32HandleInfo != nil {
		pGetWin32HandleInfo = getWin32HandleInfo.Vulkanize()
	}

	// handle is a binding-allocated single return value and will be populated by Vulkan
	ptr_pHandle := &handle

	var rsys uintptr

	if vkGetSemaphoreWin32HandleKHR.fnHandle == nil {
		vkGetSemaphoreWin32HandleKHR.fnHandle = dlHandle.NewProc("vkGetSemaphoreWin32HandleKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkGetSemaphoreWin32HandleKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pGetWin32HandleInfo)), uintptr(unsafe.Pointer(ptr_pHandle)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetSemaphoreWin32HandleKHR = &vkCommand{"vkGetSemaphoreWin32HandleKHR", 3, true, nil}

// GetWinrtDisplayNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetWinrtDisplayNV.html
func GetWinrtDisplayNV(physicalDevice PhysicalDevice, deviceRelativeId uint32) (display DisplayKHR, r error) {
	// display is a binding-allocated single return value and will be populated by Vulkan
	ptr_pDisplay := &display

	var rsys uintptr

	if vkGetWinrtDisplayNV.fnHandle == nil {
		vkGetWinrtDisplayNV.fnHandle = dlHandle.NewProc("vkGetWinrtDisplayNV")
	}
	rsys, _, _ = syscall.SyscallN(vkGetWinrtDisplayNV.fnHandle.Addr(), uintptr(physicalDevice), uintptr(deviceRelativeId), uintptr(unsafe.Pointer(ptr_pDisplay)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkGetWinrtDisplayNV = &vkCommand{"vkGetWinrtDisplayNV", 3, true, nil}

// ImportFenceWin32HandleKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportFenceWin32HandleKHR.html
func ImportFenceWin32HandleKHR(device Device, importFenceWin32HandleInfo *ImportFenceWin32HandleInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - importFenceWin32HandleInfo
	var pImportFenceWin32HandleInfo *_vkImportFenceWin32HandleInfoKHR
	if importFenceWin32HandleInfo != nil {
		pImportFenceWin32HandleInfo = importFenceWin32HandleInfo.Vulkanize()
	}

	var rsys uintptr

	if vkImportFenceWin32HandleKHR.fnHandle == nil {
		vkImportFenceWin32HandleKHR.fnHandle = dlHandle.NewProc("vkImportFenceWin32HandleKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkImportFenceWin32HandleKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pImportFenceWin32HandleInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkImportFenceWin32HandleKHR = &vkCommand{"vkImportFenceWin32HandleKHR", 2, true, nil}

// ImportSemaphoreWin32HandleKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportSemaphoreWin32HandleKHR.html
func ImportSemaphoreWin32HandleKHR(device Device, importSemaphoreWin32HandleInfo *ImportSemaphoreWin32HandleInfoKHR) (r error) {
	// Parameter is a singular input, requires translation - importSemaphoreWin32HandleInfo
	var pImportSemaphoreWin32HandleInfo *_vkImportSemaphoreWin32HandleInfoKHR
	if importSemaphoreWin32HandleInfo != nil {
		pImportSemaphoreWin32HandleInfo = importSemaphoreWin32HandleInfo.Vulkanize()
	}

	var rsys uintptr

	if vkImportSemaphoreWin32HandleKHR.fnHandle == nil {
		vkImportSemaphoreWin32HandleKHR.fnHandle = dlHandle.NewProc("vkImportSemaphoreWin32HandleKHR")
	}
	rsys, _, _ = syscall.SyscallN(vkImportSemaphoreWin32HandleKHR.fnHandle.Addr(), uintptr(device), uintptr(unsafe.Pointer(pImportSemaphoreWin32HandleInfo)))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkImportSemaphoreWin32HandleKHR = &vkCommand{"vkImportSemaphoreWin32HandleKHR", 2, true, nil}

// ReleaseFullScreenExclusiveModeEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleaseFullScreenExclusiveModeEXT.html
func ReleaseFullScreenExclusiveModeEXT(device Device, swapchain SwapchainKHR) (r error) {
	var rsys uintptr

	if vkReleaseFullScreenExclusiveModeEXT.fnHandle == nil {
		vkReleaseFullScreenExclusiveModeEXT.fnHandle = dlHandle.NewProc("vkReleaseFullScreenExclusiveModeEXT")
	}
	rsys, _, _ = syscall.SyscallN(vkReleaseFullScreenExclusiveModeEXT.fnHandle.Addr(), uintptr(device), uintptr(swapchain))
	r = Result(rsys)

	if r == Result(0) {
		r = SUCCESS
	}
	return
}

var vkReleaseFullScreenExclusiveModeEXT = &vkCommand{"vkReleaseFullScreenExclusiveModeEXT", 2, true, nil}
