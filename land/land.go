// Copyright Â© 2014-2015 Galvanized Logic Inc.
// Use is governed by a BSD-style license found in the LICENSE file.

// Package land is used to procedurally generate world terrain height maps.
// Generated lands are unique to a supplied random seed so they can be
// different or identical based on need. They can also be as detailed
// as desired although maps at higher level of detail will need to be managed
// since only a portion will fit in main memory and an even smaller portion
// in graphics memory.
//
// Package land is provided as part of the vu (virtual universe) 3D engine.
package land

import (
	"image"
	"image/color"
	"math"
)

// FUTURE: Ideas for possible future improvements:
// Procedural content generation:
//    http://unigine.com/articles/130605-procedural-content-generation/
//    http://unigine.com/articles/131016-procedural-content-generation2/
// Other methods of generating random landscapes:
//    http://www.lighthouse3d.com/opengl/terrain/index.php3?fault
//    http://www.lighthouse3d.com/opengl/terrain/index.php3?circles

// Land provides the ability to procedurally generate terrain height information.
// The higher the level of detail the larger the terrain. Land is created
// using land.New().
type Land interface {
	Lod() int         // Level of detail (max zoom) for this land.
	TileSize() int    // Land tile width, height. Standard is 256
	Size(lod int) int // Width and height at the given level of detail.

	// Allocate and populate the indicated land tile with height data.
	//   lod   : indicates the resolution/size/level-of-detail.
	//   tx, ty: topo/tile index at given zoom.
	NewTile(lod, tx, ty int) Tile
	FillTile(tile Tile) // (Re)populates an existing tile with height data.
}

// New initializes the procedural land generator. The seed determines land
// shape, such that lands created from the same seed will be the same. The
// level of detail lod determines the overall size of the land (limit to 8
// or less pending stress testing). For example if tileSize is 256 then
// increasing the level of detail results in the following sizes:
//    lod  0 :  256*2^0  = 256
//    lod  1 :  256*2^1  = 512
//    lod  2 :  256*2^2  = 1024     ~1km2
//    lod  3 :  256*2^3  = 2048
//    lod  4 :  256*2^4  = 4096
//    lod  5 :  256*2^5  = 8192
//    lod  6 :  256*2^6  = 16384
//    lod  7 :  256*2^7  = 37768
//    lod  8 :  256*2^8  = 65536    ~65km2 Medium size city.
//    lod  9 :  256*2^9  = 131072
//    lod 10 :  256*2^10 = 262144
//    lod 11 :  256*2^11 = 524288
//    lod 12 :  256*2^12 = 1048576  ~1,000,000km2 Size of Ontario
//    lod 13 :  256*2^13 = 2097152
//                         3162000  ~10,000,000km2 Size of Canada
//    lod 14 :  256*2^14 = 4194304
//    lod 15 :  256*2^15 = 8388608
//    lod 16 :  256*2^16 = 16777216
//                         22583000 ~510,000,000km2 Size of Earth
//    lod 17 :  256*2^17 = 33554472
// Land heights are generated by creating tiles at a particular zoom level.
// It is up to the caller to store/cache or regenerate tiles as needed.
func New(lod, tileSize int, seed int64) Land {
	return newLand(lod, tileSize, seed)
}

// Land interface
// ============================================================================
// land is a default implemention of Land

// land creates the world height map.
// There is a limit to the number of map sections held in memory at any one
// time. Map tiles are expected to be generated as needed for large worlds.
//
// Nice article on how map level of detail can be organized at:
//   http://msdn.microsoft.com/en-us/library/bb259689.aspx
//   http://www.microimages.com/documentation/TechGuides/76BingStructure.pdf
type land struct {
	n    *noise // perlin simplex noise maker.
	seed int64  // for all random calcuations.
	lod  int    // lod is the zoom at the maximum map size where 1pixel = 1meter.
	size int    // land tile width and height.
}

// newLand initializes the data needed to create a world land map. The higher
// the level of detail (lod), the larger the map and more map tiles needed at
// each zoom level.
func newLand(lod, size int, seed int64) *land {
	l := &land{}
	l.seed = seed
	l.size = size
	l.lod = lod
	l.n = newNoise(l.seed)
	return l
}

// Lod implements Land.
func (l *land) Lod() int { return int(l.lod) }

// Size implements Land.
func (l *land) Size(atZoom int) int { return int(math.Pow(2, float64(atZoom))) * l.size }

// TileSize implements Land.
func (l *land) TileSize() int { return l.size }

// NewTile implements Land.
func (l *land) NewTile(atZoom, x, y int) Tile { return l.newTile(atZoom, x, y) }
func (l *land) newTile(atZoom, x, y int) *tile {
	topo := NewTopo(uint(l.size), uint(l.size))
	tile := newTile(topo, atZoom, x, y)
	l.FillTile(tile)
	return tile
}

// FillTile implements Land.
func (l *land) FillTile(landTile Tile) {
	t, _ := landTile.(*tile)
	l.fill(t.topo, t.zoom, t.x, t.y)
}

// fill populates the given tile, indentified by px, py, with height data
// calculated using the world random seed.
func (l *land) fill(topo Topo, atZoom, px, py int) {
	if len(topo) == l.size && len(topo[0]) == l.size {
		topo.generate(uint(atZoom), uint(px), uint(py), l.n)
	}
}

// image creates a png image of a land mass. Expected to be used for
// debugging. This is limited to zoom levels of 3 or less so as to avoid
// creating overly large images.
func (l *land) image(landSplit float64) *image.NRGBA {
	if l.lod > 3 {
		return image.NewNRGBA(image.Rect(0, 0, 16, 16))
	}
	sections := int(math.Pow(2, float64(l.lod)))
	topo := NewTopo(uint(l.size), uint(l.size))
	pixels := sections * l.size
	img := image.NewNRGBA(image.Rect(0, 0, pixels, pixels))
	var c *color.NRGBA
	for tx := 0; tx < sections; tx++ {
		for ty := 0; ty < sections; ty++ {
			l.fill(topo, l.lod, tx, ty)
			for px := range topo {
				for py := range topo[px] {
					c = topo.paint(topo[px][py], -0.25)
					img.SetNRGBA(tx*l.size+px, ty*l.size+py, *c)
				}
			}
		}
	}
	return img
}
